# Performance Optimization Notes

## SWR (Stale-While-Revalidate) 缓存策略

### 核心思想

"先用旧、后台拉新" - 优先返回本地缓存（即使稍微过期），同时在后台刷新数据。这种策略在列表页面中提供了接近原生应用的秒开体验。

### 实现方案

**工具模块**: `miniprogram/utils/cache.js`

**核心函数**: `swrFetch(key, fetcher, options)`

**工作流程**:
1. **首次加载（无缓存）**: 直接调用 fetcher 获取数据，并缓存
2. **缓存未过期**: 立即返回缓存，同时在后台调用 fetcher 刷新
3. **缓存过期**: 调用 fetcher 获取新数据，失败时降级返回过期缓存
4. **强制刷新**: 忽略缓存，直接获取新数据，失败时降级返回缓存

### TTL 选择策略

| 数据类型 | TTL | 理由 |
|---------|-----|------|
| 市场书籍列表 | 30 秒 | 库存变化频繁，需要较快更新 |
| 推荐书籍列表 | 60 秒 | 推荐算法结果变化慢，可容忍更长缓存 |
| 用户资料 | 5 分钟 | 个人信息修改频率低 |
| 静态内容 | 24 小时 | 几乎不变的内容 |

**TTL 权衡**:
- **太短**: 频繁网络请求，浪费流量和服务器资源
- **太长**: 用户看到过期数据的概率增加

### 应用场景

**已应用**:
- ✅ `miniprogram/pages/market/index.js`
  - `fetchAvailableBooks()` - 市场列表 (TTL: 30s)
  - `fetchRecommendations()` - 推荐列表 (TTL: 60s)

**下拉刷新行为**:
- 使用 `forceRefresh: true` 强制获取最新数据
- 并行刷新多个数据源 (`Promise.all`)
- 失败时保留旧数据，不显示空白页

### 性能收益

**预期指标**:
| 指标 | 优化前 | 优化后 |
|-----|-------|-------|
| 列表页二次进入时间 | ~800ms (API RTT) | <50ms (本地缓存) |
| 下拉刷新失败用户体验 | 显示空白或错误 | 保留旧数据可用 |
| 服务器 QPS | 基准 | -30%（缓存命中减少请求） |

**用户体验改进**:
- 页面切换几乎无感知延迟
- 弱网环境下仍可浏览旧数据
- 后台刷新对用户透明

### 实现细节

**缓存存储**: `wx.storage` (微信小程序本地存储)
- 容量限制: 单个小程序 10MB
- 同步读取: `wx.getStorageSync()` (避免异步开销)
- 异步写入: `wx.setStorage()` (不阻塞主线程)

**缓存键设计**:
```javascript
// 包含搜索词，不同搜索结果不同缓存
`market:list:${searchTerm}`

// 全局唯一键
'market:recommendations:v1'
```

**版本控制**: 缓存键包含版本号（如 `:v1`），便于 API 变更时强制失效旧缓存。

### 降级策略

1. **后台刷新失败**: 静默处理，不影响已返回的缓存数据
2. **强制刷新失败**: 降级返回缓存（即使过期），避免空白页
3. **存储写入失败**: 捕获异常，不影响数据获取流程

### 未来优化方向

1. **ETag 支持**: 与后端协商缓存（需后端支持 `If-None-Match`）
2. **LRU 淘汰**: 自动清理最久未使用的缓存（当前依赖小程序自动管理）
3. **预加载**: 预测用户行为，提前刷新即将过期的缓存
4. **缓存分析**: 记录命中率，优化 TTL 配置

### 注意事项

⚠️ **不适用场景**:
- 支付、订单等强一致性要求的操作
- 用户个人敏感信息（如订单详情）
- 实时性要求极高的数据（如库存预留状态）

⚠️ **调试建议**:
- 开发时可设置短 TTL（如 5 秒）观察刷新行为
- 使用微信开发者工具 Storage 面板查看缓存内容
- 清除缓存：`require('../../utils/cache').clear()`

---

**最后更新**: 2025-10-18
**维护者**: bookworm-miniprogram team
