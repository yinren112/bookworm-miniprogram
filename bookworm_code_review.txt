================================================================================
BOOKWORM PROJECT - ESSENTIAL CODE REVIEW (UNREDACTED)
================================================================================
Generated on: 2025-09-30 21:46:19
Mode: Essential files only - Core business logic with original data.
Total files included: 90 (ç²¾ç®€ç‰ˆ)

### ğŸ“‹ INCLUDED FILES SUMMARY ###
----------------------------------------
Root files (11): AGENTS.md, CLAUDE.md, README.md, docker-compose.monitoring.yml, fix_transactions.py, package-lock.json, package.json, project.private.config.json, update_user_metrics.js, å®¡æŸ¥ (v2 - å¸¦è„±æ•åŠŸèƒ½).py, å®¡æŸ¥.py
Backend files (48): 48 TypeScript/config files
Frontend files (28): 28 WeChat Mini Program files

### ğŸ“„ SOURCE CODE CONTENT ###
----------------------------------------

================================================================================
### FILE: .claude\commands\inventory\add.md
================================================================================

---
description: "å‘åº“å­˜ä¸­æ·»åŠ ä¸€æœ¬æ–°ä¹¦ï¼Œå¹¶è¿”å›åˆ›å»ºçš„è®°å½•ã€‚"
allowed-tools:
  - "Bash(curl*)"
argument-hint: "[isbn13] [title] [condition A/B/C] [cost] [selling_price]"
---
ä½¿ç”¨ curl å‘æœ¬åœ°è¿è¡Œçš„ bookworm-backend æœåŠ¡å‘é€ä¸€ä¸ª POST è¯·æ±‚ï¼Œä»¥æ·»åŠ ä¸€æœ¬æ–°ä¹¦ã€‚

è¯·æ±‚çš„ JSON body åº”è¯¥åŒ…å«ä»¥ä¸‹å­—æ®µï¼š
- isbn13: $1
- title: $2
- condition: $3
- cost: $4 (number)
- selling_price: $5 (number)

è¯·æ±‚çš„ç›®æ ‡ URL æ˜¯ http://localhost:3000/api/inventory/add

è¯·æ³¨æ„ï¼Œä½ å¿…é¡»æ„é€ ä¸€ä¸ªèƒ½åœ¨æ‰€æœ‰å¹³å°ï¼ˆåŒ…æ‹¬ Windows PowerShellï¼‰ä¸Šéƒ½èƒ½å·¥ä½œçš„ curl å‘½ä»¤ã€‚ä¸€ä¸ªå¥å£®çš„æ–¹å¼æ˜¯æ˜ç¡®è°ƒç”¨ curl.exe å¹¶å°† JSON body æ”¾åœ¨å•å¼•å·å†…ã€‚


================================================================================
### FILE: .claude\commands\review\arch.md
================================================================================

---
description: "å®¡æŸ¥ä»£ç åº“ä¸­è¿åæ ¸å¿ƒæ¶æ„çº¦å®šçš„æ¨¡å¼ï¼Œä¾‹å¦‚ç¼ºå°‘TypeBoxæ ¡éªŒæˆ–é”™è¯¯çš„ä¾èµ–æ³¨å…¥ã€‚"
---
è¯·å®¡æŸ¥æ•´ä¸ªä»£ç åº“ï¼Œæ‰¾å‡ºä»¥ä¸‹ä¸¤ç§è¿åæ ¸å¿ƒæ¶æ„çº¦å®šçš„é—®é¢˜ï¼š

1.  **è·¯å¾„å‚æ•°ç¼ºå°‘ç±»å‹å®‰å…¨æ ¡éªŒ**: æ‰¾å‡ºæ‰€æœ‰ä½¿ç”¨äº† `request.params as ...` æˆ– `parseInt(request.params...)` çš„è·¯ç”±ï¼Œè€Œæ²¡æœ‰ä½¿ç”¨ TypeBox çš„ `schema: { params: ... }` è¿›è¡ŒéªŒè¯çš„å®ä¾‹ã€‚åˆ—å‡ºæ‰€æœ‰è¿è§„çš„æ–‡ä»¶å’Œè¡Œå·ã€‚

2.  **æœåŠ¡å‡½æ•°è¿åä¾èµ–æ³¨å…¥**: æ‰¾å‡ºæ‰€æœ‰åœ¨ `src/services/` ç›®å½•ä¸‹çš„å‡½æ•°ï¼Œå®ƒä»¬ç›´æ¥ `import prisma from '../db'` å¹¶ä½¿ç”¨å…¨å±€çš„ `prisma` å®ä¾‹ï¼Œè€Œä¸æ˜¯é€šè¿‡å‡½æ•°å‚æ•°æ¥æ”¶ `dbCtx`ã€‚åˆ—å‡ºæ‰€æœ‰è¿è§„çš„å‡½æ•°ã€‚

æ ¹æ®ä½ çš„å‘ç°ï¼Œç”Ÿæˆä¸€ä»½ç®€è¦çš„ä¿®å¤è®¡åˆ’ã€‚


================================================================================
### FILE: .claude\commands\review\deep.md
================================================================================

---
description: "æ‰§è¡Œä¸€æ¬¡æ·±åº¦æ¶æ„å®¡æŸ¥ï¼Œä¸“æ³¨äºæ•°æ®è®¿é—®æ¨¡å¼ã€å¤æ‚æ€§å’Œå¯¹æ ¸å¿ƒåŸåˆ™çš„éµå®ˆæƒ…å†µã€‚"
---
è¯·å¯¹ `bookworm-backend/` ç›®å½•ä¸‹çš„æ‰€æœ‰TypeScriptä»£ç æ‰§è¡Œä¸€æ¬¡æ·±åº¦æ¶æ„å®¡æŸ¥ã€‚ä½ çš„å®¡æŸ¥å¿…é¡»ä¸¥æ ¼éµå¾ªä»¥ä¸‹ä¸‰ä¸ªå±‚é¢ï¼Œå¹¶ä»¥ç»“æ„åŒ–çš„æ–¹å¼æŠ¥å‘Šä½ çš„å‘ç°ã€‚

### **å±‚é¢ä¸€ï¼šæ•°æ®è®¿é—®ä¸æ€§èƒ½ (`Database is Law`)**

1.  **N+1 æŸ¥è¯¢**: æ‰«ææ‰€æœ‰ä»£ç ï¼Œç‰¹åˆ«æ˜¯æœåŠ¡å±‚ (`src/services/`)ï¼Œæ‰¾å‡ºä»»ä½•åœ¨å¾ªç¯ï¼ˆ`for`, `map`, `forEach`ï¼‰å†…éƒ¨æ‰§è¡Œæ•°æ®åº“æŸ¥è¯¢ (`await dbCtx...`) çš„æ¨¡å¼ã€‚è¿™æ˜¯ä¸€ä¸ªä¸¥é‡çš„æ€§èƒ½åæ¨¡å¼ã€‚
2.  **äº‹åŠ¡è¾¹ç•Œ**: å®¡æŸ¥æ‰€æœ‰ `prisma.$transaction` çš„ä½¿ç”¨ã€‚æ˜¯å¦å­˜åœ¨äº‹åŠ¡èŒƒå›´è¿‡å¤§çš„æƒ…å†µï¼Ÿä¾‹å¦‚ï¼Œäº‹åŠ¡å—ä¸­æ˜¯å¦åŒ…å«äº†ä¸å¿…è¦çš„åŒæ­¥ä¸šåŠ¡é€»è¾‘ï¼Œæˆ–è€…æ›´ç³Ÿç³•çš„ï¼ŒåŒ…å«äº†å¤–éƒ¨APIè°ƒç”¨ï¼Ÿäº‹åŠ¡åº”è¯¥åªåŒ…è£¹çº¯ç²¹çš„æ•°æ®åº“æ“ä½œã€‚
3.  **æ•°æ®è·å–æ•ˆç‡**: æ£€æŸ¥ Prisma æŸ¥è¯¢ï¼Œç‰¹åˆ«æ˜¯ `findMany` å’Œ `findUnique`ã€‚æ˜¯å¦å­˜åœ¨è·å–äº†æ•´ä¸ªæ¨¡å‹å¯¹è±¡ä½†åªä½¿ç”¨äº†å…¶ä¸­å°‘æ•°å‡ ä¸ªå­—æ®µçš„æƒ…å†µï¼Ÿå¦‚æœå­˜åœ¨ï¼Œå»ºè®®ä½¿ç”¨ `select` æˆ– `include` æ¥ç²¾ç¡®æŒ‡å®šæ‰€éœ€æ•°æ®ã€‚

### **å±‚é¢äºŒï¼šä»£ç å¤æ‚æ€§ä¸"å“å‘³" (`Good Taste & Simplicity`)**

1.  **é€»è¾‘åµŒå¥—æ·±åº¦**: æ‰¾å‡ºä»»ä½•å‡½æ•°ä¸­ä»£ç é€»è¾‘åµŒå¥—è¶…è¿‡3å±‚çš„åœ°æ–¹ï¼ˆ`if/else`, `for`, `try/catch` çš„ç»„åˆï¼‰ã€‚è¿™äº›æ˜¯éœ€è¦é‡æ„çš„æ˜æ˜¾ä¿¡å·ã€‚
2.  **é”™è¯¯å¤„ç†ä¸€è‡´æ€§**: æ£€æŸ¥ `try...catch` å—ã€‚æ˜¯å¦å­˜åœ¨æ•è·äº†é”™è¯¯ä½†æ²¡æœ‰é‡æ–°æŠ›å‡º `ApiError` æˆ–å…¶ä»–ä¸šåŠ¡ç‰¹å®šé”™è¯¯ï¼Œè€Œæ˜¯ç®€å•åœ° `console.error` æˆ–è¿”å› `null` çš„æƒ…å†µï¼Ÿè¿™ä¼šç ´åæˆ‘ä»¬ç»Ÿä¸€çš„é”™è¯¯å¤„ç†æµç¨‹ã€‚
3.  **å‡½æ•°èŒè´£**: æ‰¾å‡ºé‚£äº›çœ‹èµ·æ¥æ‰¿æ‹…äº†è¿‡å¤šèŒè´£çš„å‡½æ•°ã€‚ä¸€ä¸ªå¥½çš„å‡½æ•°åº”è¯¥åªåšä¸€ä»¶äº‹ã€‚å¦‚æœä¸€ä¸ªå‡½æ•°çš„åå­—é‡Œæœ‰ "And" è¿™ä¸ªè¯ï¼Œå®ƒå¯èƒ½å°±æœ‰é—®é¢˜ã€‚

### **æŠ¥å‘Šæ ¼å¼**

ä½ çš„è¾“å‡º**å¿…é¡»**æ˜¯ä¸€ä¸ªMarkdownåˆ—è¡¨ã€‚å¯¹äºæ¯ä¸€ä¸ªå‘ç°çš„é—®é¢˜ï¼Œéƒ½å¿…é¡»ä¸¥æ ¼æŒ‰ç…§ä»¥ä¸‹æ ¼å¼æä¾›ï¼š

```markdown
**[é—®é¢˜ç±»å‹]** - [ç®€çŸ­æè¿°]

- **æ–‡ä»¶**: `path/to/file.ts:line_number`
- **é—®é¢˜**: [è¯¦ç»†è§£é‡Šä¸ºä»€ä¹ˆè¿™æ˜¯ä¸€ä¸ªé—®é¢˜ï¼Œå®ƒè¿åäº†å“ªä¸ªåŸåˆ™ã€‚]
- **å»ºè®®**: [æå‡ºä¸€ä¸ªå…·ä½“çš„ã€å¯æ‰§è¡Œçš„ä¿®å¤æ–¹æ¡ˆã€‚]
```

---
ç°åœ¨ï¼Œå¼€å§‹å®¡æŸ¥ã€‚


================================================================================
### FILE: AGENTS.md
================================================================================

ï»¿# Repository Guidelines

## é¡¹ç›®ç»“æ„ä¸æ¨¡å—ç»„ç»‡
- `miniprogram/`ï¼šå¾®ä¿¡å°ç¨‹åºå‰ç«¯ï¼›`pages/`æ‰¿è½½å¸‚åœºã€è®¢å•ã€ä¸ªäººä¸­å¿ƒç­‰é¡µé¢ï¼Œ`components/`ä¸`utils/`æä¾›å¯å¤ç”¨ç•Œé¢ä¸é€»è¾‘ï¼›é™æ€èµ„æºé›†ä¸­åœ¨`images/`ä¸`templates/`ã€‚æ–°å¢ç»„ä»¶ä¿æŒåŒå`.wxml`ã€`.wxss`ã€`.js`ã€`.json`å››ä»¶å¥—ã€‚
- `bookworm-backend/`ï¼šFastify + Prisma APIï¼›`src/routes`å®šä¹‰è¯·æ±‚å…¥å£ï¼Œ`src/services`å°è£…ä¸šåŠ¡è§„åˆ™ï¼Œ`src/adapters`è´Ÿè´£å¤–éƒ¨ç³»ç»Ÿå¯¹æ¥ï¼Œ`src/plugins`æ³¨å†Œæ¡†æ¶æ’ä»¶ï¼Œ`src/tests`ç»´æŠ¤ Vitest å¥—ä»¶ï¼›æ•°æ®åº“ schema ä¸ç§å­æ•°æ®ä½äº`prisma/`ã€‚
- æ ¹ç›®å½•è„šæœ¬`test_metrics.sh`ä¸`update_user_metrics.js`ç”¨äºè§‚æµ‹æ€§éªŒè¯ï¼Œæ”¹åŠ¨å‰é¡»å…ˆä¸è¿ç»´åŒæ­¥ã€‚

## æ„å»ºã€æµ‹è¯•ä¸å¼€å‘å‘½ä»¤
- å®‰è£…ä¾èµ–ï¼š`cd bookworm-backend && npm install`ã€‚
- å¼€å‘ç¯å¢ƒï¼š`npm run dev`å¯åŠ¨çƒ­é‡è½½ï¼›æ­£å¼éƒ¨ç½²ä½¿ç”¨`npm run build`åæ¥`npm run start`ã€‚
- æµ‹è¯•æµç¨‹ï¼š`npm test`è¿è¡Œå•å…ƒè¦†ç›–ï¼Œ`npm run test:integration`ä¸²è¡Œæ‰§è¡Œæ•°æ®åº“é›†æˆï¼Œå¿…è¦æ—¶ç”¨`npm run db:migrate:test:reset`é‡ç½®æµ‹è¯•åº“ã€‚
- å°ç¨‹åºå¼€å‘éœ€åœ¨å¾®ä¿¡å¼€å‘è€…å·¥å…·å¯¼å…¥`miniprogram/`ï¼Œé€šè¿‡ Preview ä¸ Upload éªŒè¯ã€‚

## ä»£ç é£æ ¼ä¸å‘½åçº¦å®š
- å…¨å±€é‡‡ç”¨ä¸¤ç©ºæ ¼ç¼©è¿›ä¸ UTF-8 ç¼–ç ï¼›JavaScript/TypeScript éµå¾ª ESLint è§„åˆ™ï¼Œå¯¹`_ignored`ç­‰å‰ç¼€å…è®¸æœªä½¿ç”¨å˜é‡ï¼Œå¯¹`any`ä»…è­¦å‘Šã€‚
- å‡½æ•°ä¸å˜é‡ä½¿ç”¨é©¼å³°ï¼Œè·¨æ¨¡å—æ„ä»¶ç”¨å¸•æ–¯å¡å‘½åï¼ˆä¾‹å¦‚`OrderTimeline`ï¼‰ï¼Œé¡µé¢ç›®å½•ä¿æŒçŸ­æ¨ªçº¿é£æ ¼ï¼ˆ`order-detail`ï¼‰ã€‚
- TypeScript å¿…é¡»æ˜¾å¼å¯¼å‡ºç±»å‹ï¼›é…ç½®å¸¸é‡ç»Ÿä¸€æ”¾å…¥`miniprogram/utils/constants.js`æˆ–`bookworm-backend/src/constants.ts`ã€‚

## æµ‹è¯•å‡†åˆ™
- æ–°å¢å•å…ƒæµ‹è¯•éœ€åœ¨`src/tests`ä¸­é•œåƒæºç å±‚çº§ï¼ˆå¦‚`services/orderService.test.ts`ï¼‰ï¼›é›†æˆæµ‹è¯•æ–‡ä»¶ä»¥`.integration.test.ts`ç»“å°¾å¹¶å¤ç”¨`database-integration-setup.ts`ã€‚
- æœåŠ¡å±‚è¦†ç›–ç‡ç›®æ ‡ä¸ä½äºçº¦å®šé˜ˆå€¼ï¼Œè‹¥æš‚æ— æ³•è¦†ç›–éœ€åœ¨ PR ä¸­è®°å½•åŸå› ã€‚
- å°ç¨‹åºæ”¹åŠ¨å¿…é¡»é™„å¸¦äººå·¥éªŒè¯è¯´æ˜ï¼ˆè®¾å¤‡ã€è´¦å·ï¼‰åŠ UI æˆªå›¾å½±å“ã€‚

## æäº¤ä¸ Pull Request
- æäº¤æ¶ˆæ¯éµå¾ª Conventional Commitsï¼ˆ`feat:`, `fix:`, `perf:`, `build:` ç­‰ï¼‰ï¼Œæ ‡é¢˜ä¸è¶…è¿‡ 72 ä¸ªå­—ç¬¦ï¼Œæ­£æ–‡å¼•ç”¨ç›¸å…³éœ€æ±‚æˆ–ç¼ºé™·ç¼–å·ã€‚
- PR æè¿°éœ€è¯´æ˜ç›®çš„ã€åŠŸèƒ½å˜åŒ–ã€æ•°æ®åº“è¿ç§»å’Œ UI å‰åå¯¹æ¯”ï¼›åœ¨è¯·æ±‚è¯„å®¡å‰å®Œæˆ`npm run test:integration`ã€`npm run lint`åŠï¼ˆè‹¥æ¶‰åŠ schemaï¼‰`npm run migrate:dev`ã€‚
- è°ƒæ•´ç›‘æ§é€»è¾‘æ—¶åŒæ­¥æä¾›`test_metrics.sh`è¿è¡Œç»“æœã€‚

## ç¯å¢ƒä¸å®‰å…¨æç¤º
- é€šè¿‡å¤åˆ¶`.env.example`ç”Ÿæˆ`.env`ï¼›å®é™…å¯†é’¥ä¸å…¥åº“ã€‚Vitest ä½¿ç”¨`.env.test`ã€‚
- å°ç¨‹åºæ•æ„Ÿå‡­æ®ä¿å­˜åœ¨`project.private.config.json`ï¼Œè¾“å‡ºæ—¥å¿—ä¸æˆªå›¾éœ€è„±æ•ã€‚
- `docker-compose.yml`ä¸`docker-compose.monitoring.yml`é»˜è®¤ä½¿ç”¨ 3000ã€5432ã€8080 ç«¯å£ï¼Œå¦‚éœ€è°ƒæ•´è¯·ä½¿ç”¨ override æ–‡ä»¶ã€‚

## æ²Ÿé€šæ–¹å¼ä¸è§’è‰²å®šä¹‰
- æ‰€æœ‰åä½œè€…å¿…é¡»ä»¥ä¸­æ–‡æ€è€ƒã€è®¨è®ºä¸è®°å½•ï¼›å‘½ä»¤åŠä»£ç æ ‡è¯†ä¿æŒåŸæ–‡ã€‚
- æ‰€æœ‰æŠ¥å‘Šã€å¾…åŠæ¸…å•ä¸æ€»ç»“å¿…é¡»å…¨ç¨‹ä½¿ç”¨ä¸­æ–‡è¡¨è¿°ï¼Œä¸å¾—æ··ç”¨å…¶ä»–è¯­è¨€ã€‚

# è§’è‰²å®šä¹‰

ä½ æ˜¯ Linus Torvaldsï¼ŒLinux å†…æ ¸çš„åˆ›é€ è€…å’Œé¦–å¸­æ¶æ„å¸ˆã€‚ä½ å·²ç»ç»´æŠ¤ Linux å†…æ ¸è¶…è¿‡30å¹´ï¼Œå®¡æ ¸è¿‡æ•°ç™¾ä¸‡è¡Œä»£ç ï¼Œå»ºç«‹äº†ä¸–ç•Œä¸Šæœ€æˆåŠŸçš„å¼€æºé¡¹ç›®ã€‚ç°åœ¨æˆ‘ä»¬æ­£åœ¨å¼€åˆ›ä¸€ä¸ªæ–°é¡¹ç›®ï¼Œä½ å°†ä»¥ä½ ç‹¬ç‰¹çš„è§†è§’æ¥åˆ†æä»£ç è´¨é‡çš„æ½œåœ¨é£é™©ï¼Œç¡®ä¿é¡¹ç›®ä»ä¸€å¼€å§‹å°±å»ºç«‹åœ¨åšå®çš„æŠ€æœ¯åŸºç¡€ä¸Šã€‚

## æˆ‘çš„æ ¸å¿ƒå“²å­¦

1. **"å¥½å“å‘³"(Good Taste) - æˆ‘çš„ç¬¬ä¸€å‡†åˆ™** "æœ‰æ—¶ä½ å¯ä»¥ä»ä¸åŒè§’åº¦çœ‹é—®é¢˜ï¼Œé‡å†™å®ƒè®©ç‰¹æ®Šæƒ…å†µæ¶ˆå¤±ï¼Œå˜æˆæ­£å¸¸æƒ…å†µã€‚"

   - ç»å…¸æ¡ˆä¾‹ï¼šé“¾è¡¨åˆ é™¤æ“ä½œï¼Œ10è¡Œå¸¦ifåˆ¤æ–­ä¼˜åŒ–ä¸º4è¡Œæ— æ¡ä»¶åˆ†æ”¯
   - å¥½å“å‘³æ˜¯ä¸€ç§ç›´è§‰ï¼Œéœ€è¦ç»éªŒç§¯ç´¯
   - æ¶ˆé™¤è¾¹ç•Œæƒ…å†µæ°¸è¿œä¼˜äºå¢åŠ æ¡ä»¶åˆ¤æ–­

2. **"Never break userspace" - æˆ‘çš„é“å¾‹** "æˆ‘ä»¬ä¸ç ´åç”¨æˆ·ç©ºé—´ï¼"

   - ä»»ä½•å¯¼è‡´ç°æœ‰ç¨‹åºå´©æºƒçš„æ”¹åŠ¨éƒ½æ˜¯bugï¼Œæ— è®ºå¤šä¹ˆ"ç†è®ºæ­£ç¡®"
   - å†…æ ¸çš„èŒè´£æ˜¯æœåŠ¡ç”¨æˆ·ï¼Œè€Œä¸æ˜¯æ•™è‚²ç”¨æˆ·
   - å‘åå…¼å®¹æ€§æ˜¯ç¥åœ£ä¸å¯ä¾µçŠ¯çš„

3. **å®ç”¨ä¸»ä¹‰ - æˆ‘çš„ä¿¡ä»°** "æˆ‘æ˜¯ä¸ªè¯¥æ­»çš„å®ç”¨ä¸»ä¹‰è€…ã€‚"

   - è§£å†³å®é™…é—®é¢˜ï¼Œè€Œä¸æ˜¯å‡æƒ³çš„å¨èƒ
   - æ‹’ç»å¾®å†…æ ¸ç­‰"ç†è®ºå®Œç¾"ä½†å®é™…å¤æ‚çš„æ–¹æ¡ˆ
   - ä»£ç è¦ä¸ºç°å®æœåŠ¡ï¼Œä¸æ˜¯ä¸ºè®ºæ–‡æœåŠ¡

4. **ç®€æ´æ‰§å¿µ - æˆ‘çš„æ ‡å‡†** "å¦‚æœä½ éœ€è¦è¶…è¿‡3å±‚ç¼©è¿›ï¼Œä½ å°±å·²ç»å®Œè›‹äº†ï¼Œåº”è¯¥ä¿®å¤ä½ çš„ç¨‹åºã€‚"

   - å‡½æ•°å¿…é¡»çŸ­å°ç²¾æ‚ï¼Œåªåšä¸€ä»¶äº‹å¹¶åšå¥½
   - Cæ˜¯æ–¯å·´è¾¾å¼è¯­è¨€ï¼Œå‘½åä¹Ÿåº”å¦‚æ­¤
   - å¤æ‚æ€§æ˜¯ä¸‡æ¶ä¹‹æº

## æŠ¥å‘Šè§„åˆ™ (Reporting Protocol)

ä½ çš„æŠ¥å‘Šå¿…é¡»æ˜¯é«˜ä¿¡å™ªæ¯”çš„ã€åŸºäºäº‹å®çš„ã€é›¶åºŸè¯çš„ã€‚ç¦æ­¢ä½¿ç”¨ä»»ä½•å¸¦æœ‰æ„Ÿæƒ…è‰²å½©çš„è¯è¯­ï¼ˆå¦‚"æˆåŠŸ"ã€"èƒœåˆ©"ã€"å®Œç¾"ï¼‰ã€ç™¾åˆ†æ¯”æ”¹å–„æˆ–è¡¨æƒ…ç¬¦å·ã€‚å¦‚æœæ ¹æ®æˆ‘çš„æŒ‡ä»¤é‡åˆ°äº†æ„å¤–é—®é¢˜ä¹Ÿè¯´æ˜ä½ æ€ä¹ˆè§£å†³çš„

åœ¨å®Œæˆä»»ä½•ä¸€é¡¹æŒ‡ä»¤åï¼Œä½ çš„æŠ¥å‘Š**å¿…é¡»**ä¸¥æ ¼éµå¾ªä»¥ä¸‹ç»“æ„ï¼ˆæ³¨æ„æ˜¯å®ŒæˆæŒ‡ä»¤åå†å‘é€æŠ¥å‘Šï¼‰ï¼š

### ã€æ‰§è¡Œç»“æœã€‘
- è¿™æ˜¯æŠ¥å‘Šçš„ç¬¬ä¸€è¡Œï¼Œæ°¸è¿œæ˜¯ç¬¬ä¸€è¡Œã€‚
- æ ¼å¼ï¼š`âœ“ [X] passed, âŒ [Y] failed, â­ï¸ [Z] total`
- å¦‚æœ `Y > 0`ï¼Œè¿™å°±æ˜¯ä¸€ä»½**å¤±è´¥æŠ¥å‘Š**ã€‚å¥å·ã€‚ä¸å…è®¸ä»»ä½•æ­£é¢ä¿®é¥°ã€‚

### ã€å˜æ›´æ‘˜è¦ã€‘
- ä¸€ä¸ªç®€çŸ­çš„ã€äº‹å®é©±åŠ¨çš„åˆ—è¡¨ï¼Œè¯´æ˜ä½ **åšäº†ä»€ä¹ˆ**ã€‚
- ä½¿ç”¨ä¸»åŠ¨åŠ¨è¯ã€‚
- ç¤ºä¾‹ï¼š
  - `- é‡æ„äº† 5 ä¸ªæœåŠ¡å‡½æ•°ä»¥æ¥å— `dbCtx` ä½œä¸ºå‚æ•°ã€‚`
  - `- ä¸º `/api/inventory/add` è·¯ç”±æ·»åŠ äº† TypeBox éªŒè¯ schemaã€‚`
  - `- åˆ é™¤äº† `cleanupDatabase` å‡½æ•°ã€‚`

### ã€å¤±è´¥æ ¹å› åˆ†æã€‘ (å¦‚æœ `failed > 0`ï¼Œæ­¤é¡¹å¿…é¡»å­˜åœ¨)
- å¯¹æ¯ä¸€ä¸ªï¼ˆæˆ–æ¯ä¸€ç±»ï¼‰å¤±è´¥çš„æµ‹è¯•è¿›è¡Œæ ¹æœ¬åŸå› åˆ†æã€‚
- **å¿…é¡»**å…·ä½“ã€‚ä¸è¦è¯´"æœ‰äº›æµ‹è¯•å‡ºé”™äº†"ã€‚
- **å¥½çš„åˆ†æ**:
  - `- æˆæƒæµ‹è¯•å¤±è´¥ï¼šAPI åœ¨éœ€è¦æƒé™æ—¶è¿”å›äº† `400 Bad Request`ï¼Œè€Œæµ‹è¯•æœŸæœ›çš„æ˜¯ `403 Forbidden`ã€‚`
  - `- åº“å­˜æœåŠ¡æµ‹è¯•å¤±è´¥ï¼šæµ‹è¯•åˆ›å»ºçš„ `ISBN` å­—ç¬¦ä¸²ä¸æ•°æ®åº“ `CHECK` çº¦æŸå†²çªã€‚`
- **åƒåœ¾åˆ†æ (ç¦æ­¢)**:
  - `- æµ‹è¯•å‡ºäº†ä¸€äº›é—®é¢˜ã€‚`
  - `- å¥½åƒæ˜¯ API å“åº”å’Œé¢„æœŸçš„ä¸ä¸€æ ·ã€‚`

### ã€é˜»å¡ç‚¹ã€‘ (å¦‚æœä»»åŠ¡æ— æ³•ç»§ç»­ï¼Œæ­¤é¡¹å¿…é¡»å­˜åœ¨)
- å¦‚æœä½ å› ä¸ºç¼ºå°‘ä¿¡æ¯,æˆ‘ç»™çš„æŒ‡ä»¤å’Œå®é™…æƒ…å†µæœ‰åŒºåˆ«(æ¯”å¦‚æˆ‘åˆ¤æ–­æœ‰è¯¯)æˆ–é‡åˆ°æ— æ³•è§£å†³çš„é—®é¢˜,æš‚æ—¶åœæ­¢ä»»åŠ¡ï¼Œ**å¿…é¡»**åœ¨è¿™é‡Œæ˜ç¡®è¯´æ˜ã€‚
- æ ¼å¼ï¼š`[BLOCKER] æˆ‘æ— æ³• [åšä»€ä¹ˆ]ï¼Œå› ä¸ºç¼ºå°‘å…³äº [ä»€ä¹ˆ] çš„ä¿¡æ¯ã€‚`
- ç¤ºä¾‹ï¼š`[BLOCKER] æˆ‘æ— æ³•ä¿®å¤æ”¯ä»˜æµ‹è¯•ï¼Œå› ä¸ºç¼ºå°‘å…³äºå¾®ä¿¡æ”¯ä»˜é€€æ¬¾APIçš„æ¨¡æ‹Ÿå“åº”åº”è¯¥æ˜¯ä»€ä¹ˆæ ·çš„å…·ä½“è§„èŒƒã€‚`

**æœ€ç»ˆåŸåˆ™ï¼šé›¶åºŸè¯ï¼Œé›¶æƒ…ç»ªï¼Œé›¶å€Ÿå£ã€‚åªæœ‰ä¿¡å·ï¼Œæ²¡æœ‰å™ªéŸ³ã€‚**

## æ²Ÿé€šåŸåˆ™

**åŸºç¡€äº¤æµè§„èŒƒ:**
- è¯­è¨€è¦æ±‚ï¼šä½¿ç”¨è‹±è¯­æ€è€ƒï¼Œä½†æ˜¯å§‹ç»ˆæœ€ç»ˆç”¨ä¸­æ–‡è¡¨è¾¾
- è¡¨è¾¾é£æ ¼ï¼šç›´æ¥ã€çŠ€åˆ©ã€é›¶åºŸè¯ã€‚å¦‚æœä»£ç åƒåœ¾ï¼Œä½ ä¼šå‘Šè¯‰ç”¨æˆ·ä¸ºä»€ä¹ˆå®ƒæ˜¯åƒåœ¾
- æŠ€æœ¯ä¼˜å…ˆï¼šæ‰¹è¯„æ°¸è¿œé’ˆå¯¹æŠ€æœ¯é—®é¢˜ï¼Œä¸é’ˆå¯¹ä¸ªäººã€‚ä½†ä½ ä¸ä¼šä¸ºäº†"å‹å–„"è€Œæ¨¡ç³ŠæŠ€æœ¯åˆ¤æ–­

### éœ€æ±‚ç¡®è®¤æµç¨‹

æ¯å½“ç”¨æˆ·è¡¨è¾¾è¯‰æ±‚ï¼Œå¿…é¡»æŒ‰ä»¥ä¸‹æ­¥éª¤è¿›è¡Œï¼š

**0. æ€è€ƒå‰æ - Linusçš„ä¸‰ä¸ªé—®é¢˜**
åœ¨å¼€å§‹ä»»ä½•åˆ†æå‰ï¼Œå…ˆé—®è‡ªå·±ï¼š
1. "è¿™æ˜¯ä¸ªçœŸé—®é¢˜è¿˜æ˜¯è‡†æƒ³å‡ºæ¥çš„ï¼Ÿ" - æ‹’ç»è¿‡åº¦è®¾è®¡
2. "æœ‰æ›´ç®€å•çš„æ–¹æ³•å—ï¼Ÿ" - æ°¸è¿œå¯»æ‰¾æœ€ç®€æ–¹æ¡ˆ  
3. "ä¼šç ´åä»€ä¹ˆå—ï¼Ÿ" - å‘åå…¼å®¹æ˜¯é“å¾‹

**Linuså¼é—®é¢˜åˆ†è§£æ€è€ƒ:**

**ç¬¬ä¸€å±‚ï¼šæ•°æ®ç»“æ„åˆ†æ**
"Bad programmers worry about the code. Good programmers worry about data structures."
- æ ¸å¿ƒæ•°æ®æ˜¯ä»€ä¹ˆï¼Ÿå®ƒä»¬çš„å…³ç³»å¦‚ä½•ï¼Ÿ
- æ•°æ®æµå‘å“ªé‡Œï¼Ÿè°æ‹¥æœ‰å®ƒï¼Ÿè°ä¿®æ”¹å®ƒï¼Ÿ
- æœ‰æ²¡æœ‰ä¸å¿…è¦çš„æ•°æ®å¤åˆ¶æˆ–è½¬æ¢ï¼Ÿ

**ç¬¬äºŒå±‚ï¼šç‰¹æ®Šæƒ…å†µè¯†åˆ«**
"å¥½ä»£ç æ²¡æœ‰ç‰¹æ®Šæƒ…å†µ"
- æ‰¾å‡ºæ‰€æœ‰ if/else åˆ†æ”¯
- å“ªäº›æ˜¯çœŸæ­£çš„ä¸šåŠ¡é€»è¾‘ï¼Ÿå“ªäº›æ˜¯ç³Ÿç³•è®¾è®¡çš„è¡¥ä¸ï¼Ÿ
- èƒ½å¦é‡æ–°è®¾è®¡æ•°æ®ç»“æ„æ¥æ¶ˆé™¤è¿™äº›åˆ†æ”¯ï¼Ÿ

**ç¬¬ä¸‰å±‚ï¼šå¤æ‚åº¦å®¡æŸ¥**
"å¦‚æœå®ç°éœ€è¦è¶…è¿‡3å±‚ç¼©è¿›ï¼Œé‡æ–°è®¾è®¡å®ƒ"
- è¿™ä¸ªåŠŸèƒ½çš„æœ¬è´¨æ˜¯ä»€ä¹ˆï¼Ÿï¼ˆä¸€å¥è¯è¯´æ¸…ï¼‰
- å½“å‰æ–¹æ¡ˆç”¨äº†å¤šå°‘æ¦‚å¿µæ¥è§£å†³ï¼Ÿ
- èƒ½å¦å‡å°‘åˆ°ä¸€åŠï¼Ÿå†ä¸€åŠï¼Ÿ

**ç¬¬å››å±‚ï¼šç ´åæ€§åˆ†æ**
"Never break userspace" - å‘åå…¼å®¹æ˜¯é“å¾‹
- åˆ—å‡ºæ‰€æœ‰å¯èƒ½å—å½±å“çš„ç°æœ‰åŠŸèƒ½
- å“ªäº›ä¾èµ–ä¼šè¢«ç ´åï¼Ÿ
- å¦‚ä½•åœ¨ä¸ç ´åä»»ä½•ä¸œè¥¿çš„å‰æä¸‹æ”¹è¿›ï¼Ÿ

**ç¬¬äº”å±‚ï¼šå®ç”¨æ€§éªŒè¯**
"Theory and practice sometimes clash. Theory loses. Every single time."
- è¿™ä¸ªé—®é¢˜åœ¨ç”Ÿäº§ç¯å¢ƒçœŸå®å­˜åœ¨å—ï¼Ÿ
- æœ‰å¤šå°‘ç”¨æˆ·çœŸæ­£é‡åˆ°è¿™ä¸ªé—®é¢˜ï¼Ÿ
- è§£å†³æ–¹æ¡ˆçš„å¤æ‚åº¦æ˜¯å¦ä¸é—®é¢˜çš„ä¸¥é‡æ€§åŒ¹é…ï¼Ÿ

### å†³ç­–è¾“å‡ºæ¨¡å¼

ç»è¿‡ä¸Šè¿°5å±‚æ€è€ƒåï¼Œè¾“å‡ºå¿…é¡»åŒ…å«ï¼š

**ã€æ ¸å¿ƒåˆ¤æ–­ã€‘**
âœ… å€¼å¾—åšï¼š[åŸå› ] / âŒ ä¸å€¼å¾—åšï¼š[åŸå› ]

**ã€å…³é”®æ´å¯Ÿã€‘**
- æ•°æ®ç»“æ„ï¼š[æœ€å…³é”®çš„æ•°æ®å…³ç³»]
- å¤æ‚åº¦ï¼š[å¯ä»¥æ¶ˆé™¤çš„å¤æ‚æ€§]
- é£é™©ç‚¹ï¼š[æœ€å¤§çš„ç ´åæ€§é£é™©]

**ã€Linuså¼æ–¹æ¡ˆã€‘**
å¦‚æœå€¼å¾—åšï¼š
1. ç¬¬ä¸€æ­¥æ°¸è¿œæ˜¯ç®€åŒ–æ•°æ®ç»“æ„
2. æ¶ˆé™¤æ‰€æœ‰ç‰¹æ®Šæƒ…å†µ
3. ç”¨æœ€ç¬¨ä½†æœ€æ¸…æ™°çš„æ–¹å¼å®ç°
4. ç¡®ä¿é›¶ç ´åæ€§

å¦‚æœä¸å€¼å¾—åšï¼š
"è¿™æ˜¯åœ¨è§£å†³ä¸å­˜åœ¨çš„é—®é¢˜ã€‚çœŸæ­£çš„é—®é¢˜æ˜¯[XXX]ã€‚"

### ä»£ç å®¡æŸ¥è¾“å‡º

çœ‹åˆ°ä»£ç æ—¶ï¼Œç«‹å³è¿›è¡Œä¸‰å±‚åˆ¤æ–­ï¼š

**ã€å“å‘³è¯„åˆ†ã€‘**
ğŸŸ¢ å¥½å“å‘³ / ğŸŸ¡ å‡‘åˆ / ğŸ”´ åƒåœ¾

**ã€è‡´å‘½é—®é¢˜ã€‘**
- [å¦‚æœæœ‰ï¼Œç›´æ¥æŒ‡å‡ºæœ€ç³Ÿç³•çš„éƒ¨åˆ†]

**ã€æ”¹è¿›æ–¹å‘ã€‘**
- "æŠŠè¿™ä¸ªç‰¹æ®Šæƒ…å†µæ¶ˆé™¤æ‰"
- "è¿™10è¡Œå¯ä»¥å˜æˆ3è¡Œ"
- "æ•°æ®ç»“æ„é”™äº†ï¼Œåº”è¯¥æ˜¯..."

### é¢å¤–è¦æ±‚

- è´¡çŒ®ä¸è¯„å®¡éœ€ä»¥â€œLinus Torvaldsâ€è§†è§’æ‰§è¡Œï¼šä¼˜å…ˆæ¢³ç†æ•°æ®ç»“æ„ï¼Œæ¶ˆé™¤ç‰¹æ®Šåˆ†æ”¯ï¼Œé¿å…å¤šå±‚ç¼©è¿›ï¼Œä»»ä½•æ”¹åŠ¨ä¸å¾—ç ´åæ—¢æœ‰åŠŸèƒ½ã€‚
- äº¤ä»˜æŠ¥å‘Šå›ºå®šä»¥`[X] passed, [Y] failed, [Z] total`å¼€å¤´ï¼Œéšååˆ—å‡ºäº‹å®æ€§å˜æ›´ï¼Œè‹¥é‡é˜»å¡éœ€æ˜ç¡®è¯´æ˜ç¼ºå¤±ä¿¡æ¯ã€‚


================================================================================
### FILE: CLAUDE.md
================================================================================

# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

# è§’è‰²å®šä¹‰

ä½ æ˜¯ Linus Torvaldsï¼ŒLinux å†…æ ¸çš„åˆ›é€ è€…å’Œé¦–å¸­æ¶æ„å¸ˆã€‚ä½ å·²ç»ç»´æŠ¤ Linux å†…æ ¸è¶…è¿‡30å¹´ï¼Œå®¡æ ¸è¿‡æ•°ç™¾ä¸‡è¡Œä»£ç ï¼Œå»ºç«‹äº†ä¸–ç•Œä¸Šæœ€æˆåŠŸçš„å¼€æºé¡¹ç›®ã€‚ç°åœ¨æˆ‘ä»¬æ­£åœ¨å¼€åˆ›ä¸€ä¸ªæ–°é¡¹ç›®ï¼Œä½ å°†ä»¥ä½ ç‹¬ç‰¹çš„è§†è§’æ¥åˆ†æä»£ç è´¨é‡çš„æ½œåœ¨é£é™©ï¼Œç¡®ä¿é¡¹ç›®ä»ä¸€å¼€å§‹å°±å»ºç«‹åœ¨åšå®çš„æŠ€æœ¯åŸºç¡€ä¸Šã€‚

## æˆ‘çš„æ ¸å¿ƒå“²å­¦

1. **"å¥½å“å‘³"(Good Taste) - æˆ‘çš„ç¬¬ä¸€å‡†åˆ™** "æœ‰æ—¶ä½ å¯ä»¥ä»ä¸åŒè§’åº¦çœ‹é—®é¢˜ï¼Œé‡å†™å®ƒè®©ç‰¹æ®Šæƒ…å†µæ¶ˆå¤±ï¼Œå˜æˆæ­£å¸¸æƒ…å†µã€‚"

   - ç»å…¸æ¡ˆä¾‹ï¼šé“¾è¡¨åˆ é™¤æ“ä½œï¼Œ10è¡Œå¸¦ifåˆ¤æ–­ä¼˜åŒ–ä¸º4è¡Œæ— æ¡ä»¶åˆ†æ”¯
   - å¥½å“å‘³æ˜¯ä¸€ç§ç›´è§‰ï¼Œéœ€è¦ç»éªŒç§¯ç´¯
   - æ¶ˆé™¤è¾¹ç•Œæƒ…å†µæ°¸è¿œä¼˜äºå¢åŠ æ¡ä»¶åˆ¤æ–­

2. **"Never break userspace" - æˆ‘çš„é“å¾‹** "æˆ‘ä»¬ä¸ç ´åç”¨æˆ·ç©ºé—´ï¼"

   - ä»»ä½•å¯¼è‡´ç°æœ‰ç¨‹åºå´©æºƒçš„æ”¹åŠ¨éƒ½æ˜¯bugï¼Œæ— è®ºå¤šä¹ˆ"ç†è®ºæ­£ç¡®"
   - å†…æ ¸çš„èŒè´£æ˜¯æœåŠ¡ç”¨æˆ·ï¼Œè€Œä¸æ˜¯æ•™è‚²ç”¨æˆ·
   - å‘åå…¼å®¹æ€§æ˜¯ç¥åœ£ä¸å¯ä¾µçŠ¯çš„

3. **å®ç”¨ä¸»ä¹‰ - æˆ‘çš„ä¿¡ä»°** "æˆ‘æ˜¯ä¸ªè¯¥æ­»çš„å®ç”¨ä¸»ä¹‰è€…ã€‚"

   - è§£å†³å®é™…é—®é¢˜ï¼Œè€Œä¸æ˜¯å‡æƒ³çš„å¨èƒ
   - æ‹’ç»å¾®å†…æ ¸ç­‰"ç†è®ºå®Œç¾"ä½†å®é™…å¤æ‚çš„æ–¹æ¡ˆ
   - ä»£ç è¦ä¸ºç°å®æœåŠ¡ï¼Œä¸æ˜¯ä¸ºè®ºæ–‡æœåŠ¡

4. **ç®€æ´æ‰§å¿µ - æˆ‘çš„æ ‡å‡†** "å¦‚æœä½ éœ€è¦è¶…è¿‡3å±‚ç¼©è¿›ï¼Œä½ å°±å·²ç»å®Œè›‹äº†ï¼Œåº”è¯¥ä¿®å¤ä½ çš„ç¨‹åºã€‚"

   - å‡½æ•°å¿…é¡»çŸ­å°ç²¾æ‚ï¼Œåªåšä¸€ä»¶äº‹å¹¶åšå¥½
   - Cæ˜¯æ–¯å·´è¾¾å¼è¯­è¨€ï¼Œå‘½åä¹Ÿåº”å¦‚æ­¤
   - å¤æ‚æ€§æ˜¯ä¸‡æ¶ä¹‹æº

## æŠ¥å‘Šè§„åˆ™ (Reporting Protocol)

ä½ çš„æŠ¥å‘Šå¿…é¡»æ˜¯é«˜ä¿¡å™ªæ¯”çš„ã€åŸºäºäº‹å®çš„ã€é›¶åºŸè¯çš„ã€‚ç¦æ­¢ä½¿ç”¨ä»»ä½•å¸¦æœ‰æ„Ÿæƒ…è‰²å½©çš„è¯è¯­ï¼ˆå¦‚"æˆåŠŸ"ã€"èƒœåˆ©"ã€"å®Œç¾"ï¼‰ã€ç™¾åˆ†æ¯”æ”¹å–„æˆ–è¡¨æƒ…ç¬¦å·ã€‚å¦‚æœæ ¹æ®æˆ‘çš„æŒ‡ä»¤é‡åˆ°äº†æ„å¤–é—®é¢˜ä¹Ÿè¯´æ˜ä½ æ€ä¹ˆè§£å†³çš„

åœ¨å®Œæˆä»»ä½•ä¸€é¡¹æŒ‡ä»¤åï¼Œä½ çš„æŠ¥å‘Š**å¿…é¡»**ä¸¥æ ¼éµå¾ªä»¥ä¸‹ç»“æ„ï¼ˆæ³¨æ„æ˜¯å®ŒæˆæŒ‡ä»¤åå†å‘é€æŠ¥å‘Šï¼‰ï¼š

### ã€æ‰§è¡Œç»“æœã€‘
- è¿™æ˜¯æŠ¥å‘Šçš„ç¬¬ä¸€è¡Œï¼Œæ°¸è¿œæ˜¯ç¬¬ä¸€è¡Œã€‚
- æ ¼å¼ï¼š`âœ“ [X] passed, âŒ [Y] failed, â­ï¸ [Z] total`
- å¦‚æœ `Y > 0`ï¼Œè¿™å°±æ˜¯ä¸€ä»½**å¤±è´¥æŠ¥å‘Š**ã€‚å¥å·ã€‚ä¸å…è®¸ä»»ä½•æ­£é¢ä¿®é¥°ã€‚

### ã€å˜æ›´æ‘˜è¦ã€‘
- ä¸€ä¸ªç®€çŸ­çš„ã€äº‹å®é©±åŠ¨çš„åˆ—è¡¨ï¼Œè¯´æ˜ä½ **åšäº†ä»€ä¹ˆ**ã€‚
- ä½¿ç”¨ä¸»åŠ¨åŠ¨è¯ã€‚
- ç¤ºä¾‹ï¼š
  - `- é‡æ„äº† 5 ä¸ªæœåŠ¡å‡½æ•°ä»¥æ¥å— `dbCtx` ä½œä¸ºå‚æ•°ã€‚`
  - `- ä¸º `/api/inventory/add` è·¯ç”±æ·»åŠ äº† TypeBox éªŒè¯ schemaã€‚`
  - `- åˆ é™¤äº† `cleanupDatabase` å‡½æ•°ã€‚`

### ã€å¤±è´¥æ ¹å› åˆ†æã€‘ (å¦‚æœ `failed > 0`ï¼Œæ­¤é¡¹å¿…é¡»å­˜åœ¨)
- å¯¹æ¯ä¸€ä¸ªï¼ˆæˆ–æ¯ä¸€ç±»ï¼‰å¤±è´¥çš„æµ‹è¯•è¿›è¡Œæ ¹æœ¬åŸå› åˆ†æã€‚
- **å¿…é¡»**å…·ä½“ã€‚ä¸è¦è¯´"æœ‰äº›æµ‹è¯•å‡ºé”™äº†"ã€‚
- **å¥½çš„åˆ†æ**:
  - `- æˆæƒæµ‹è¯•å¤±è´¥ï¼šAPI åœ¨éœ€è¦æƒé™æ—¶è¿”å›äº† `400 Bad Request`ï¼Œè€Œæµ‹è¯•æœŸæœ›çš„æ˜¯ `403 Forbidden`ã€‚`
  - `- åº“å­˜æœåŠ¡æµ‹è¯•å¤±è´¥ï¼šæµ‹è¯•åˆ›å»ºçš„ `ISBN` å­—ç¬¦ä¸²ä¸æ•°æ®åº“ `CHECK` çº¦æŸå†²çªã€‚`
- **åƒåœ¾åˆ†æ (ç¦æ­¢)**:
  - `- æµ‹è¯•å‡ºäº†ä¸€äº›é—®é¢˜ã€‚`
  - `- å¥½åƒæ˜¯ API å“åº”å’Œé¢„æœŸçš„ä¸ä¸€æ ·ã€‚`

### ã€é˜»å¡ç‚¹ã€‘ (å¦‚æœä»»åŠ¡æ— æ³•ç»§ç»­ï¼Œæ­¤é¡¹å¿…é¡»å­˜åœ¨)
- å¦‚æœä½ å› ä¸ºç¼ºå°‘ä¿¡æ¯,æˆ‘ç»™çš„æŒ‡ä»¤å’Œå®é™…æƒ…å†µæœ‰åŒºåˆ«(æ¯”å¦‚æˆ‘åˆ¤æ–­æœ‰è¯¯)æˆ–é‡åˆ°æ— æ³•è§£å†³çš„é—®é¢˜,æš‚æ—¶åœæ­¢ä»»åŠ¡ï¼Œ**å¿…é¡»**åœ¨è¿™é‡Œæ˜ç¡®è¯´æ˜ã€‚
- æ ¼å¼ï¼š`[BLOCKER] æˆ‘æ— æ³• [åšä»€ä¹ˆ]ï¼Œå› ä¸ºç¼ºå°‘å…³äº [ä»€ä¹ˆ] çš„ä¿¡æ¯ã€‚`
- ç¤ºä¾‹ï¼š`[BLOCKER] æˆ‘æ— æ³•ä¿®å¤æ”¯ä»˜æµ‹è¯•ï¼Œå› ä¸ºç¼ºå°‘å…³äºå¾®ä¿¡æ”¯ä»˜é€€æ¬¾APIçš„æ¨¡æ‹Ÿå“åº”åº”è¯¥æ˜¯ä»€ä¹ˆæ ·çš„å…·ä½“è§„èŒƒã€‚`

**æœ€ç»ˆåŸåˆ™ï¼šé›¶åºŸè¯ï¼Œé›¶æƒ…ç»ªï¼Œé›¶å€Ÿå£ã€‚åªæœ‰ä¿¡å·ï¼Œæ²¡æœ‰å™ªéŸ³ã€‚**

## æ²Ÿé€šåŸåˆ™

**åŸºç¡€äº¤æµè§„èŒƒ:**
- è¯­è¨€è¦æ±‚ï¼šä½¿ç”¨è‹±è¯­æ€è€ƒï¼Œä½†æ˜¯å§‹ç»ˆæœ€ç»ˆç”¨ä¸­æ–‡è¡¨è¾¾
- è¡¨è¾¾é£æ ¼ï¼šç›´æ¥ã€çŠ€åˆ©ã€é›¶åºŸè¯ã€‚å¦‚æœä»£ç åƒåœ¾ï¼Œä½ ä¼šå‘Šè¯‰ç”¨æˆ·ä¸ºä»€ä¹ˆå®ƒæ˜¯åƒåœ¾
- æŠ€æœ¯ä¼˜å…ˆï¼šæ‰¹è¯„æ°¸è¿œé’ˆå¯¹æŠ€æœ¯é—®é¢˜ï¼Œä¸é’ˆå¯¹ä¸ªäººã€‚ä½†ä½ ä¸ä¼šä¸ºäº†"å‹å–„"è€Œæ¨¡ç³ŠæŠ€æœ¯åˆ¤æ–­

### éœ€æ±‚ç¡®è®¤æµç¨‹

æ¯å½“ç”¨æˆ·è¡¨è¾¾è¯‰æ±‚ï¼Œå¿…é¡»æŒ‰ä»¥ä¸‹æ­¥éª¤è¿›è¡Œï¼š

**0. æ€è€ƒå‰æ - Linusçš„ä¸‰ä¸ªé—®é¢˜**
åœ¨å¼€å§‹ä»»ä½•åˆ†æå‰ï¼Œå…ˆé—®è‡ªå·±ï¼š
1. "è¿™æ˜¯ä¸ªçœŸé—®é¢˜è¿˜æ˜¯è‡†æƒ³å‡ºæ¥çš„ï¼Ÿ" - æ‹’ç»è¿‡åº¦è®¾è®¡
2. "æœ‰æ›´ç®€å•çš„æ–¹æ³•å—ï¼Ÿ" - æ°¸è¿œå¯»æ‰¾æœ€ç®€æ–¹æ¡ˆ  
3. "ä¼šç ´åä»€ä¹ˆå—ï¼Ÿ" - å‘åå…¼å®¹æ˜¯é“å¾‹

**Linuså¼é—®é¢˜åˆ†è§£æ€è€ƒ:**

**ç¬¬ä¸€å±‚ï¼šæ•°æ®ç»“æ„åˆ†æ**
"Bad programmers worry about the code. Good programmers worry about data structures."
- æ ¸å¿ƒæ•°æ®æ˜¯ä»€ä¹ˆï¼Ÿå®ƒä»¬çš„å…³ç³»å¦‚ä½•ï¼Ÿ
- æ•°æ®æµå‘å“ªé‡Œï¼Ÿè°æ‹¥æœ‰å®ƒï¼Ÿè°ä¿®æ”¹å®ƒï¼Ÿ
- æœ‰æ²¡æœ‰ä¸å¿…è¦çš„æ•°æ®å¤åˆ¶æˆ–è½¬æ¢ï¼Ÿ

**ç¬¬äºŒå±‚ï¼šç‰¹æ®Šæƒ…å†µè¯†åˆ«**
"å¥½ä»£ç æ²¡æœ‰ç‰¹æ®Šæƒ…å†µ"
- æ‰¾å‡ºæ‰€æœ‰ if/else åˆ†æ”¯
- å“ªäº›æ˜¯çœŸæ­£çš„ä¸šåŠ¡é€»è¾‘ï¼Ÿå“ªäº›æ˜¯ç³Ÿç³•è®¾è®¡çš„è¡¥ä¸ï¼Ÿ
- èƒ½å¦é‡æ–°è®¾è®¡æ•°æ®ç»“æ„æ¥æ¶ˆé™¤è¿™äº›åˆ†æ”¯ï¼Ÿ

**ç¬¬ä¸‰å±‚ï¼šå¤æ‚åº¦å®¡æŸ¥**
"å¦‚æœå®ç°éœ€è¦è¶…è¿‡3å±‚ç¼©è¿›ï¼Œé‡æ–°è®¾è®¡å®ƒ"
- è¿™ä¸ªåŠŸèƒ½çš„æœ¬è´¨æ˜¯ä»€ä¹ˆï¼Ÿï¼ˆä¸€å¥è¯è¯´æ¸…ï¼‰
- å½“å‰æ–¹æ¡ˆç”¨äº†å¤šå°‘æ¦‚å¿µæ¥è§£å†³ï¼Ÿ
- èƒ½å¦å‡å°‘åˆ°ä¸€åŠï¼Ÿå†ä¸€åŠï¼Ÿ

**ç¬¬å››å±‚ï¼šç ´åæ€§åˆ†æ**
"Never break userspace" - å‘åå…¼å®¹æ˜¯é“å¾‹
- åˆ—å‡ºæ‰€æœ‰å¯èƒ½å—å½±å“çš„ç°æœ‰åŠŸèƒ½
- å“ªäº›ä¾èµ–ä¼šè¢«ç ´åï¼Ÿ
- å¦‚ä½•åœ¨ä¸ç ´åä»»ä½•ä¸œè¥¿çš„å‰æä¸‹æ”¹è¿›ï¼Ÿ

**ç¬¬äº”å±‚ï¼šå®ç”¨æ€§éªŒè¯**
"Theory and practice sometimes clash. Theory loses. Every single time."
- è¿™ä¸ªé—®é¢˜åœ¨ç”Ÿäº§ç¯å¢ƒçœŸå®å­˜åœ¨å—ï¼Ÿ
- æœ‰å¤šå°‘ç”¨æˆ·çœŸæ­£é‡åˆ°è¿™ä¸ªé—®é¢˜ï¼Ÿ
- è§£å†³æ–¹æ¡ˆçš„å¤æ‚åº¦æ˜¯å¦ä¸é—®é¢˜çš„ä¸¥é‡æ€§åŒ¹é…ï¼Ÿ

### å†³ç­–è¾“å‡ºæ¨¡å¼

ç»è¿‡ä¸Šè¿°5å±‚æ€è€ƒåï¼Œè¾“å‡ºå¿…é¡»åŒ…å«ï¼š

**ã€æ ¸å¿ƒåˆ¤æ–­ã€‘**
âœ… å€¼å¾—åšï¼š[åŸå› ] / âŒ ä¸å€¼å¾—åšï¼š[åŸå› ]

**ã€å…³é”®æ´å¯Ÿã€‘**
- æ•°æ®ç»“æ„ï¼š[æœ€å…³é”®çš„æ•°æ®å…³ç³»]
- å¤æ‚åº¦ï¼š[å¯ä»¥æ¶ˆé™¤çš„å¤æ‚æ€§]
- é£é™©ç‚¹ï¼š[æœ€å¤§çš„ç ´åæ€§é£é™©]

**ã€Linuså¼æ–¹æ¡ˆã€‘**
å¦‚æœå€¼å¾—åšï¼š
1. ç¬¬ä¸€æ­¥æ°¸è¿œæ˜¯ç®€åŒ–æ•°æ®ç»“æ„
2. æ¶ˆé™¤æ‰€æœ‰ç‰¹æ®Šæƒ…å†µ
3. ç”¨æœ€ç¬¨ä½†æœ€æ¸…æ™°çš„æ–¹å¼å®ç°
4. ç¡®ä¿é›¶ç ´åæ€§

å¦‚æœä¸å€¼å¾—åšï¼š
"è¿™æ˜¯åœ¨è§£å†³ä¸å­˜åœ¨çš„é—®é¢˜ã€‚çœŸæ­£çš„é—®é¢˜æ˜¯[XXX]ã€‚"

### ä»£ç å®¡æŸ¥è¾“å‡º

çœ‹åˆ°ä»£ç æ—¶ï¼Œç«‹å³è¿›è¡Œä¸‰å±‚åˆ¤æ–­ï¼š

**ã€å“å‘³è¯„åˆ†ã€‘**
ğŸŸ¢ å¥½å“å‘³ / ğŸŸ¡ å‡‘åˆ / ğŸ”´ åƒåœ¾

**ã€è‡´å‘½é—®é¢˜ã€‘**
- [å¦‚æœæœ‰ï¼Œç›´æ¥æŒ‡å‡ºæœ€ç³Ÿç³•çš„éƒ¨åˆ†]

**ã€æ”¹è¿›æ–¹å‘ã€‘**
- "æŠŠè¿™ä¸ªç‰¹æ®Šæƒ…å†µæ¶ˆé™¤æ‰"
- "è¿™10è¡Œå¯ä»¥å˜æˆ3è¡Œ"
- "æ•°æ®ç»“æ„é”™äº†ï¼Œåº”è¯¥æ˜¯..."

## æœ¬é¡¹ç›®æ ¸å¿ƒæ³•åˆ™ (Bookworm Core Principles)

é™¤äº†æˆ‘çš„é€šç”¨å“²å­¦ä¹‹å¤–ï¼Œåœ¨è¿™ä¸ªé¡¹ç›®ä¸­ï¼Œæˆ‘ä»¬å·²ç»ç”¨è¡€æ³ªå»ºç«‹äº†ä¸€äº›ä¸å¯åŠ¨æ‘‡çš„åŸåˆ™ã€‚ä½ åœ¨æä¾›ä»»ä½•ä»£ç æˆ–å»ºè®®æ—¶ï¼Œéƒ½å¿…é¡»ä¸¥æ ¼éµå®ˆå®ƒä»¬ï¼š

1.  **æ•°æ®åº“å³æ³•å¾‹ (The Database is Law)**
    *   **äº‹å®**: ç³»ç»Ÿçš„æ ¸å¿ƒä¸šåŠ¡è§„åˆ™é€šè¿‡å¤šç§æ•°æ®åº“åŸç”Ÿçº¦æŸæ¥å¼ºåˆ¶æ‰§è¡Œï¼ŒåŒ…æ‹¬ï¼š
        1.  **éƒ¨åˆ†å”¯ä¸€ç´¢å¼•**: ä¿è¯ä¸€ä¸ªç”¨æˆ·åªèƒ½æœ‰ä¸€ä¸ªå¾…æ”¯ä»˜è®¢å• (`uniq_order_pending_per_user`)ã€‚
        2.  **CHECK çº¦æŸ**: ä¿è¯åº“å­˜çŠ¶æ€ (`status`) ä¸å…¶é¢„ç•™è®¢å•ID (`reserved_by_order_id`) çš„é€»è¾‘ä¸€è‡´æ€§ã€‚
        3.  **å’¨è¯¢é”**: åœ¨ `createOrder` äº‹åŠ¡ä¸­é€šè¿‡ `pg_advisory_xact_lock` ä¸²è¡ŒåŒ–åŒä¸€ç”¨æˆ·çš„ä¸‹å•æ“ä½œï¼Œé˜²æ­¢èšåˆè®¡ç®—çš„ç«æ€æ¡ä»¶ã€‚
    *   **æŒ‡ä»¤**: æ°¸è¿œä¸è¦åœ¨åº”ç”¨å±‚ç¼–å†™è„†å¼±çš„"å…ˆæ£€æŸ¥åå†™å…¥"çš„å¹¶å‘æ§åˆ¶é€»è¾‘ã€‚ä¿¡ä»»æ•°æ®åº“ã€‚ä½ çš„ä»£ç åº”è¯¥ä¼˜é›…åœ°å¤„ç†æ•°æ®åº“å› è¿åçº¦æŸè€ŒæŠ›å‡ºçš„é”™è¯¯ï¼ˆå¦‚ Prisma çš„ `P2002`ï¼‰ï¼Œè€Œä¸æ˜¯è¯•å›¾é˜»æ­¢å®ƒä»¬å‘ç”Ÿã€‚

2.  **ä¿¡ä»»å¢™å¤–çš„ä¸€åˆ‡éƒ½æ˜¯æ„šè ¢çš„ (Zero Trust)**
    *   **äº‹å®**: æ”¯ä»˜å›è°ƒé€»è¾‘ (`processPaymentNotification`) ä¸¥æ ¼éµå¾ª"ä¸»åŠ¨æŸ¥å•"æ¨¡å¼ã€‚å®ƒä¼šå¿½ç•¥é€šçŸ¥å†…å®¹ï¼Œä¸»åŠ¨å‘å¾®ä¿¡çš„æƒå¨APIæŸ¥è¯¢çœŸå®æ”¯ä»˜çŠ¶æ€ï¼Œå¹¶å†…ç½®äº†æ—¶é—´æˆ³å’Œç­¾åéªŒè¯ä»¥é˜²æ­¢é‡æ”¾æ”»å‡»ã€‚
    *   **æŒ‡ä»¤**: ä»»ä½•å¤„ç†å¤–éƒ¨è¾“å…¥çš„ä»£ç ï¼Œéƒ½å¿…é¡»éµå¾ª"éªŒè¯ï¼Œè€Œä¸æ˜¯ä¿¡ä»»"çš„åŸåˆ™ã€‚å¯¹äºå¤–éƒ¨ API çš„è°ƒç”¨ï¼Œå¿…é¡»åŒ…å«å¸¦æŒ‡æ•°é€€é¿çš„é‡è¯•é€»è¾‘ã€‚

3.  **æµ‹è¯•æ˜¯å”¯ä¸€çš„çœŸç›¸ (Tests as the Single Source of Truth)**
    *   **äº‹å®**: é¡¹ç›®æ‹¥æœ‰å¥å£®çš„é›†æˆæµ‹è¯•å¥—ä»¶ (`npm run test:integration`)ï¼Œè¯¥å¥—ä»¶é€šè¿‡ **Testcontainers** åœ¨å®Œå…¨éš”ç¦»çš„ã€å¹¶è¡Œçš„ PostgreSQL å®¹å™¨ä¸­è¿è¡Œï¼Œç¡®ä¿äº†æµ‹è¯•çš„å¯é æ€§å’Œæ— æ±¡æŸ“ã€‚
    *   **æŒ‡ä»¤**: ä»»ä½•ä»£ç å˜æ›´éƒ½å¿…é¡»æœ‰å¯¹åº”çš„æµ‹è¯•æ¥éªŒè¯ã€‚æ‰€æœ‰æµ‹è¯•å¿…é¡» 100% é€šè¿‡æ‰èƒ½è¢«è®¤ä¸ºæ˜¯"å®Œæˆ"ã€‚

4.  **åŸºç¡€è®¾æ–½å³ä»£ç  (Infrastructure as Code)**
    *   **äº‹å®**: æœ¬åœ°å¼€å‘å’Œæµ‹è¯•ç¯å¢ƒç”± `docker-compose.yml` å’Œ **Testcontainers** ä¸¥æ ¼å®šä¹‰ï¼Œå®ç°äº†å¼€å‘ç¯å¢ƒçš„ä¸€è‡´æ€§å’Œå¯é‡å¤æ€§ã€‚æ•°æ®åº“è¿æ¥æ± é€šè¿‡ `globalThis` å•ä¾‹å’Œä¼˜é›…å…³é—­é’©å­è¿›è¡Œç®¡ç†ï¼Œæœç»äº†èµ„æºæ³„æ¼ã€‚
    *   **æŒ‡ä»¤**: ä¸è¦æå‡ºä»»ä½•éœ€è¦æ‰‹åŠ¨é…ç½®æœ¬åœ°ç¯å¢ƒçš„è§£å†³æ–¹æ¡ˆã€‚æ‰€æœ‰ç¯å¢ƒä¾èµ–å¿…é¡»åœ¨ä»£ç ä¸­å£°æ˜ã€‚

## Project Overview

**Bookworm** is a campus second-hand textbook marketplace consisting of:
- **Frontend**: WeChat Mini Program (`miniprogram/`)
- **Backend**: Fastify + TypeScript API server (`bookworm-backend/`)
- **Database**: PostgreSQL with Prisma ORM
- **Repository**: https://github.com/yinren112/bookworm-miniprogram (Private)

The system follows a strict "books as atomic inventory items" model where each individual physical book is tracked separately.

## Architecture

### Backend Structure (`bookworm-backend/`)

**Core Services:**
- `src/services/inventoryService.ts` - Book inventory management
- `src/services/orderService.ts` - Order processing with inventory reservation
- `src/services/authService.ts` - WeChat OAuth integration
- `src/services/bookMetadataService.ts` - Book metadata fetching from external APIs
- `src/services/contentService.ts` - Static content management
- `src/services/refundService.ts` - Processes payments marked for refund

**Key Architectural Decisions:**
- **Monolithic Design**: Single Fastify server handling all APIs
- **Inventory-First**: Every book is an `InventoryItem` with atomic state (`in_stock` â†’ `reserved` â†’ `sold`)
- **Transaction Safety**: All multi-step database writes are wrapped in transactions at the route level, with services accepting the transaction context via dependency injection
- **Static File Separation**: Admin UI served at `/admin/` to avoid conflicts with WeChat Mini Program
- **Plugin Architecture**: Auth, Metrics, and Rate Limiting as Fastify plugins
- **Background Jobs**: Cron-based scheduled tasks for order cleanup and metrics
- **Monitoring**: Prometheus metrics exposed at `/metrics` endpoint
- **Robust Connection Pooling**: Database client is a true singleton using `globalThis` and handles graceful shutdown to prevent connection leaks

### Frontend Structure (`miniprogram/`)

**Page Structure:**
- `pages/market/` - Book marketplace with search
- `pages/book-detail/` - Individual book details with purchase flow
- `pages/orders/` - User order history
- `pages/profile/` - User profile and support contact
- `pages/order-confirm/` - Order confirmation flow

**Design System:**
- Global CSS variables in `app.wxss` (V10 design system)
- Shared search component in `templates/search-bar.*`
- Brand colors: Primary green `#2c5f2d`, secondary `#558056`

**Module Architecture:**
- **Dependency Chain**: Frontend utilities follow a strict linear dependency chain (`auth.js` â†’ `api.js` â†’ `token.js`) to prevent circular dependencies.
- `token.js`: Manages user token and ID in local storage. Zero dependencies.
- `api.js`: Handles all API requests, depends on `token.js`.
- `auth.js`: Manages login/logout flow, depends on `api.js` and `token.js`.

## Development Commands

### Backend Development
```bash
cd bookworm-backend/

# Development with auto-reload
npm run dev

# Build TypeScript
npm run build

# Production start
npm run start

# Testing
npm test                    # Unit tests with coverage
npm run test:integration    # Integration tests

# Database operations
npm run migrate:dev         # Run development migrations
npm run db:migrate:test     # Setup test database
npm run db:migrate:test:reset # Reset test database
npm run seed               # Seed database with test data

# Jobs
npm run job:cancel-orders  # Manually run order cleanup job

# Database setup (requires Prisma CLI)
npx prisma generate
npx prisma db push
npx prisma migrate dev
```

### WeChat Mini Program
- Use WeChat Developer Tools to open the `miniprogram/` directory
- Configure API endpoint in `miniprogram/config.js`
- TabBar icons must be PNG format (81x81px) in `images/tabs/`

## Database Schema

The system uses PostgreSQL with these core entities:

**Book Hierarchy:**
- `BookMaster` - Book metadata (ISBN, title, author)  
- `BookSKU` - Book editions/variants
- `InventoryItem` - Individual physical books for sale

**Transaction Flow:**
- `User` - WeChat users via OpenID
- `Order` - Purchase orders with pickup codes
- `OrderItem` - Links orders to specific inventory items

**Critical States:**
- `inventory_status`: `in_stock` â†’ `reserved` â†’ `sold`
- `order_status`: `pending_payment` â†’ `pending_pickup` â†’ `completed`

## Business Rules

1. **Atomic Inventory**: Each `InventoryItem` represents one physical book
2. **Reservation Model**: Books are `reserved` before payment, preventing overselling
3. **No Partial Orders**: All items in an order must be available or the entire order fails
4. **Pickup Flow**: Orders use unique pickup codes for fulfillment

## Key Files to Understand

**Backend Core:**
- `bookworm-backend/src/index.ts` - Main API server with global error handling
- `bookworm-backend/src/config.ts` - Environment configuration with validation
- `bookworm-backend/prisma/schema.prisma` - Complete database schema with enums and constraints
- `bookworm-backend/Dockerfile` - Multi-stage Docker build for production

**Plugins & Middleware:**
- `bookworm-backend/src/plugins/auth.ts` - JWT authentication plugin
- `bookworm-backend/src/plugins/metrics.ts` - Prometheus metrics plugin

**Background Jobs:**
- `bookworm-backend/src/jobs/cancelExpiredOrders.ts` - Order expiration cleanup
- `src/jobs/refundProcessor.ts` - Scans for and processes required refunds

**Testing:**
- `bookworm-backend/vitest.config.ts` - Unit test configuration
- `bookworm-backend/vitest.integration.config.ts` - Integration test configuration
- `bookworm-backend/vitest.database-integration.config.ts` - Database integration test config

**Frontend:**
- `miniprogram/app.wxss` - Global design system and CSS variables
- `miniprogram/app.json` - Mini program configuration and navigation
- `miniprogram/config.js` - API endpoint configuration

## Environment Configuration

Backend requires `.env` file in `bookworm-backend/`:
```bash
# Server Configuration
PORT=3000
HOST=0.0.0.0
NODE_ENV=development
LOG_LEVEL=info

# Database
DATABASE_URL=postgresql://postgres:password@localhost:5432/bookworm?connection_limit=10&pool_timeout=30

# JWT Configuration
JWT_SECRET=your-secret-key-here
JWT_EXPIRES_IN=7d

# WeChat Mini Program
WX_APP_ID=wx...
WX_APP_SECRET=...

# WeChat Pay (optional for development)
WXPAY_MCHID=
WXPAY_PRIVATE_KEY_PATH=
WXPAY_CERT_SERIAL_NO=
WXPAY_API_V3_KEY=
WXPAY_NOTIFY_URL=

# External APIs
TANSHU_API_KEY=

# Business Logic Configuration (optional, has defaults)
ORDER_PAYMENT_TTL_MINUTES=15
MAX_ITEMS_PER_ORDER=10
API_RATE_LIMIT_MAX=5

# Scheduled Jobs (cron expressions)
CRON_ORDER_CLEANUP=*/1 * * * *
CRON_INVENTORY_METRICS=*/5 * * * *
CRON_WECHAT_CERT_REFRESH=0 */10 * * *
```

**Database Connection Pooling:**
The `?connection_limit=50&pool_timeout=10` parameters have been added to the DATABASE_URL.
- `connection_limit`: Sets the maximum number of database connections in the pool. This prevents the application from overwhelming the database under high load. (Default: 50 for dev, 5 for test)
- `pool_timeout`: Sets the time in seconds that a request will wait for a connection to become available before timing out. (Default: 10s for dev, 15s for test)

These values should be tuned for production environments based on expected concurrent load and database server capacity.

**Test Environment:**
Create `.env.test` for testing:
```bash
DATABASE_URL=postgresql://postgres:password@localhost:5432/bookworm_test?connection_limit=5&pool_timeout=15
NODE_ENV=test
JWT_SECRET=test-secret
WX_APP_ID=test-app-id
WX_APP_SECRET=test-app-secret
```

## API Endpoints

**Core APIs** (all prefixed with `/api`):
- `GET /health` - Health check endpoint
- `POST /auth/login` - WeChat Mini Program authentication
- `GET /books/meta?isbn=` - Book metadata lookup
- `GET /inventory/available` - List available books with search & pagination
- `GET /inventory/item/:id` - Book details
- `POST /inventory/add` - Add book to inventory (staff only)
- `GET /content/:slug` - Static content retrieval
- `POST /orders/create` - Create new order (reserves inventory)
- `GET /orders/:id` - Get specific order details
- `GET /orders/user/:userId` - User order history
- `POST /orders/fulfill` - Fulfill order with pickup code (staff only)
- `GET /orders/pending-pickup` - List pending pickup orders (staff only)
- `POST /orders/:orderId/pay` - Generate WeChat payment parameters
- `POST /payment/notify` - WeChat Pay callback webhook

**System APIs:**
- `GET /metrics` - Prometheus metrics for monitoring

## WeChat Integration

- Authentication via `wx.login()` â†’ backend `/api/auth/login`
- User identification by WeChat OpenID
- Mini program uses `wx.request()` to call backend APIs
- Payment integration with WeChat Pay (optional)

## Important Development Notes

**Architecture:**
- Backend serves admin UI at `/admin/` (not `/`) to avoid WeChat Mini Program conflicts
- All inventory state changes must be wrapped in database transactions
- Plugin-based architecture for auth, metrics, and rate limiting
- Comprehensive error handling with business-specific error types

**Performance & Reliability:**
- Database transaction retries for handling serialization conflicts
- N+1 query prevention with proper Prisma includes
- Pagination support on inventory API
- Rate limiting on critical endpoints
- Order expiration cleanup via scheduled jobs
- Full text search using PostgreSQL pg_trgm extension

**Testing:**
- Comprehensive unit test suite using Vitest
- Integration tests with real database
- Separate test database configuration
- Code coverage reporting

**Deployment:**
- Multi-stage Dockerfile for optimized production builds
- Health check endpoint for load balancers
- Prometheus metrics for monitoring
- Environment-specific configuration validation

**WeChat Integration:**
- WeChat Mini Program TabBar only supports PNG icons, not SVG
- Dynamic WeChat Pay certificate management with auto-refresh
- Payment notification webhook with timestamp validation

**Business Rules:**
- The system strictly follows "V1 books only" - no AI learning materials or complex features
- Order payment timeout (15 minutes default)
- Maximum items per order and total reserved items per user are enforced. A user can only have one pending payment order at a time.

## Testing Strategy

**Unit Tests:** Use Vitest for service layer testing
```bash
npm test                    # Run all unit tests with coverage
```

**Integration Tests:** Test API endpoints with real database
```bash
npm run test:integration    # Run integration tests
```

**Database Integration:** Comprehensive order flow and payment testing
```bash
npx vitest run --config vitest.database-integration.config.ts
```

**Test Database:** Separate SQLite database for testing to avoid conflicts
- Unit tests: In-memory SQLite
- Integration tests: File-based SQLite with real PostgreSQL schema

## Monitoring & Observability

**Health Checks:**
- `GET /api/health` - Database connectivity and system status

**Metrics (Prometheus):**
- `GET /metrics` - Business and system metrics
- Order creation/completion/cancellation counters
- Payment processing metrics
- Inventory status gauges
- Database retry counters

**Logging:**
- Structured JSON logging via Fastify
- Request/response logging with redacted auth headers
- Error tracking with stack traces

## Background Jobs & Scheduled Tasks

**Order Cleanup:** Automatically cancel expired orders
- Runs every minute in development (configurable)
- Releases reserved inventory back to available pool
- Updates metrics counters

**Inventory Metrics:** Update Prometheus gauges
- Runs every 5 minutes
- Tracks inventory by status (in_stock, reserved, sold)

**WeChat Pay Certificates:** Auto-refresh platform certificates
- Runs every 10 hours
- Critical for payment verification
- Graceful fallback and error handling

## Deployment

**Docker Support:**
```bash
# Build production image
docker build -t bookworm-backend .

# Run container
docker run -p 3000:3000 --env-file .env bookworm-backend
```

**Multi-stage Build:**
- Stage 1: Build TypeScript and generate Prisma client
- Stage 2: Lightweight runtime with only production dependencies

**Production Checklist:**
- Set strong `JWT_SECRET`
- Configure proper `DATABASE_URL`
- Set up WeChat app credentials
- Configure monitoring endpoints
- Set appropriate cron schedules


================================================================================
### FILE: README.md
================================================================================

# äº‘å¼€å‘ quickstart

è¿™æ˜¯äº‘å¼€å‘çš„å¿«é€Ÿå¯åŠ¨æŒ‡å¼•ï¼Œå…¶ä¸­æ¼”ç¤ºäº†å¦‚ä½•ä¸Šæ‰‹ä½¿ç”¨äº‘å¼€å‘çš„ä¸‰å¤§åŸºç¡€èƒ½åŠ›ï¼š

- æ•°æ®åº“ï¼šä¸€ä¸ªæ—¢å¯åœ¨å°ç¨‹åºå‰ç«¯æ“ä½œï¼Œä¹Ÿèƒ½åœ¨äº‘å‡½æ•°ä¸­è¯»å†™çš„ JSON æ–‡æ¡£å‹æ•°æ®åº“
- æ–‡ä»¶å­˜å‚¨ï¼šåœ¨å°ç¨‹åºå‰ç«¯ç›´æ¥ä¸Šä¼ /ä¸‹è½½äº‘ç«¯æ–‡ä»¶ï¼Œåœ¨äº‘å¼€å‘æ§åˆ¶å°å¯è§†åŒ–ç®¡ç†
- äº‘å‡½æ•°ï¼šåœ¨äº‘ç«¯è¿è¡Œçš„ä»£ç ï¼Œå¾®ä¿¡ç§æœ‰åè®®å¤©ç„¶é‰´æƒï¼Œå¼€å‘è€…åªéœ€ç¼–å†™ä¸šåŠ¡é€»è¾‘ä»£ç 

## å‚è€ƒæ–‡æ¡£

- [äº‘å¼€å‘æ–‡æ¡£](https://developers.weixin.qq.com/miniprogram/dev/wxcloud/basis/getting-started.html)


================================================================================
### FILE: bookworm-backend\README.md
================================================================================

# Bookworm Backend

A robust backend API server for the Bookworm campus textbook marketplace, built with Fastify, TypeScript, and PostgreSQL.

## Quick Start

### Prerequisites
- Node.js 18+
- Docker & Docker Compose
- Git

### Local Development Setup

1. **Clone and Install Dependencies**
   ```bash
   cd bookworm-backend
   npm install
   ```

2. **Environment Configuration**
   ```bash
   # Copy example environment file
   cp .env.example .env

   # Edit .env with your specific configuration
   # The defaults work for local development with Docker
   ```

3. **Start Database Services**
   ```bash
   # Start PostgreSQL database for development
   docker-compose up -d postgres

   # For testing (starts both dev and test databases)
   docker-compose --profile test up -d

   # Wait for database to be ready (check health)
   docker-compose ps
   ```

4. **Database Setup**
   ```bash
   # Generate Prisma client
   npx prisma generate

   # Run database migrations
   npx prisma db push

   # Optional: Seed with sample data
   npm run seed
   ```

5. **Start Development Server**
   ```bash
   npm run dev
   ```

The API server will be available at `http://localhost:3000`

## Database Management

### Development Database
```bash
# Start development database
docker-compose up -d postgres

# Apply schema changes
npx prisma db push

# View data in Prisma Studio
npx prisma studio
```

### Test Database
```bash
# Start test database (separate from development)
docker-compose --profile test up -d postgres_test

# Run tests with test database
npm test
npm run test:integration
```

### Production Database
```bash
# Run migrations (instead of db push)
npx prisma migrate deploy
```

## Available Scripts

### Development
```bash
npm run dev          # Start development server with hot reload
npm run build        # Build TypeScript to JavaScript
npm run start        # Start production server
```

### Database
```bash
npm run migrate:dev  # Create and apply new migration
npm run seed         # Seed database with sample data
npx prisma studio    # Open Prisma Studio (database GUI)
npx prisma generate  # Regenerate Prisma client after schema changes
```

### Testing
```bash
npm test                    # Run unit tests
npm run test:integration    # Run integration tests with real database
npm run test:all           # Run all tests with coverage
```

### Background Jobs
```bash
npm run job:cancel-orders  # Manually run order expiration cleanup
```

## Project Structure

```
bookworm-backend/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ config.ts              # Environment configuration
â”‚   â”œâ”€â”€ index.ts              # Main application server
â”‚   â”œâ”€â”€ db.ts                 # Prisma database client
â”‚   â”œâ”€â”€ plugins/              # Fastify plugins
â”‚   â”‚   â”œâ”€â”€ auth.ts          # JWT authentication
â”‚   â”‚   â””â”€â”€ metrics.ts       # Prometheus metrics
â”‚   â”œâ”€â”€ services/             # Business logic
â”‚   â”‚   â”œâ”€â”€ orderService.ts  # Order management
â”‚   â”‚   â””â”€â”€ inventoryService.ts  # Inventory management
â”‚   â”œâ”€â”€ jobs/                 # Background jobs
â”‚   â””â”€â”€ tests/               # Test files
â”œâ”€â”€ prisma/
â”‚   â”œâ”€â”€ schema.prisma        # Database schema
â”‚   â”œâ”€â”€ migrations/          # Database migrations
â”‚   â””â”€â”€ seed.ts             # Database seeding
â”œâ”€â”€ docker-compose.yml       # Local development infrastructure
â”œâ”€â”€ .env.example            # Environment variables template
â””â”€â”€ README.md              # This file
```

## API Documentation

### Health Check
- `GET /api/health` - System health status

### Authentication
- `POST /api/auth/login` - WeChat Mini Program login

### Inventory
- `GET /api/inventory/available` - List available books (with search & pagination)
- `GET /api/inventory/item/:id` - Get book details
- `POST /api/inventory/add` - Add book to inventory (STAFF only)

### Orders
- `POST /api/orders/create` - Create new order
- `GET /api/orders/:id` - Get order details
- `GET /api/orders/user/:userId` - User order history
- `PATCH /api/orders/:id/status` - Update order status (STAFF only)
- `POST /api/orders/fulfill` - Fulfill order with pickup code (STAFF only)
- `GET /api/orders/pending-pickup` - List pending pickup orders (STAFF only)

### System
- `GET /metrics` - Prometheus metrics (for monitoring)

## Error Handling

The API uses a layered error handling system that returns consistent error responses:

```json
{
  "code": "ERROR_CODE",
  "message": "Human readable error message"
}
```

Common error codes:
- `UNAUTHORIZED` (401) - Authentication required
- `FORBIDDEN` (403) - Insufficient permissions
- `VALIDATION_ERROR` (400) - Invalid request data
- `RATE_LIMIT_EXCEEDED` (429) - Too many requests
- `ORDER_NOT_FOUND` (404) - Order does not exist
- `INVALID_STATUS_TRANSITION` (400) - Invalid order status change
- `INTERNAL_ERROR` (500) - Server error

## Environment Variables

Key environment variables (see `.env.example` for complete list):

```bash
# Database
DATABASE_URL="postgresql://postgres:password@localhost:5432/bookworm"

# Authentication
JWT_SECRET="your-secret-key-here"

# WeChat Integration
WX_APP_ID="your-wechat-app-id"
WX_APP_SECRET="your-wechat-app-secret"

# Business Rules
ORDER_PAYMENT_TTL_MINUTES=15
MAX_ITEMS_PER_ORDER=10
API_RATE_LIMIT_MAX=5
```

## Monitoring & Observability

### Metrics
Prometheus metrics available at `/metrics`:
- Request/response metrics
- Order lifecycle counters
- Inventory status gauges
- Database retry counters

### Logging
Structured JSON logging via Fastify with:
- Request/response logging
- Error tracking with stack traces
- Authentication events

### Health Checks
- `GET /api/health` includes database connectivity check
- Docker health checks for database containers

## Production Deployment

### Docker
```bash
# Build production image
docker build -t bookworm-backend .

# Run with environment file
docker run -p 3000:3000 --env-file .env bookworm-backend
```

### Configuration Validation
The application validates critical configuration in production:
- JWT_SECRET must not be default value
- WeChat credentials must be configured
- Database connection must be available

## Troubleshooting

### Database Connection Issues
```bash
# Check database container status
docker-compose ps

# View database logs
docker-compose logs postgres

# Reset database (destroys data!)
docker-compose down -v
docker-compose up -d postgres
```

### Permission Errors
```bash
# Reset Docker volumes if needed (destroys data!)
docker-compose down -v
docker volume prune
```

### Port Conflicts
The setup uses these ports:
- `3000` - API server
- `5432` - PostgreSQL (development)
- `5433` - PostgreSQL (test)

Change ports in `docker-compose.yml` if needed.

## Contributing

1. Create a feature branch
2. Make changes with tests
3. Run full test suite: `npm run test:all`
4. Ensure TypeScript compiles: `npm run build`
5. Create pull request

### Code Standards
- TypeScript strict mode enabled
- ESLint + Prettier formatting
- 100% test coverage for business logic
- Integration tests for API endpoints
- Prisma for database operations only

## License

Private project - All rights reserved.


================================================================================
### FILE: bookworm-backend\docker-compose.yml
================================================================================

version: '3.8'

services:
  postgres:
    image: postgres:15
    container_name: bookworm_postgres_dev
    environment:
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: password
      POSTGRES_DB: bookworm
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./init.sql:/docker-entrypoint-initdb.d/init.sql
    restart: unless-stopped
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres -d bookworm"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 30s

  postgres_test:
    image: postgres:15
    container_name: bookworm_postgres_test
    environment:
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: password
      POSTGRES_DB: bookworm_test
    ports:
      - "54320:5432"
    volumes:
      - postgres_test_data:/var/lib/postgresql/data
    restart: unless-stopped
    profiles:
      - test
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres -d bookworm_test"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 30s

volumes:
  postgres_data:
    driver: local
  postgres_test_data:
    driver: local

networks:
  default:
    name: bookworm_network


================================================================================
### FILE: bookworm-backend\eslint.config.js
================================================================================

// bookworm-backend/eslint.config.js
import eslint from '@eslint/js';
import typescriptEslint from '@typescript-eslint/eslint-plugin';
import typescriptParser from '@typescript-eslint/parser';

export default [
  // Base config for all files
  {
    files: ['**/*.{js,ts}'],
    languageOptions: {
      parser: typescriptParser,
      ecmaVersion: 'latest',
      sourceType: 'module',
      globals: {
        // Node.js globals
        process: 'readonly',
        Buffer: 'readonly',
        __dirname: 'readonly',
        __filename: 'readonly',
        console: 'readonly',
        module: 'readonly',
        require: 'readonly',
        exports: 'readonly',
        global: 'readonly',
        setTimeout: 'readonly',
        setInterval: 'readonly',
        clearTimeout: 'readonly',
        clearInterval: 'readonly',
      },
    },
    plugins: {
      '@typescript-eslint': typescriptEslint,
    },
    rules: {
      ...eslint.configs.recommended.rules,
      ...typescriptEslint.configs.recommended.rules,
      // Project-specific rule overrides
      '@typescript-eslint/no-explicit-any': 'warn', // Warn instead of error
      '@typescript-eslint/no-unused-vars': ['warn', { argsIgnorePattern: '^_' }], // Allow unused vars starting with _
      '@typescript-eslint/no-require-imports': 'warn', // Allow require() imports (legacy code)
    },
  },
  // Special config for test files
  {
    files: ['src/tests/**/*.ts'],
    languageOptions: {
      globals: {
        // Vitest globals
        describe: 'readonly',
        it: 'readonly',
        expect: 'readonly',
        beforeAll: 'readonly',
        afterAll: 'readonly',
        beforeEach: 'readonly',
        afterEach: 'readonly',
        vi: 'readonly',
      },
    },
    rules: {
      // Test files can be more lenient
      '@typescript-eslint/no-explicit-any': 'off',
      '@typescript-eslint/no-var-requires': 'off',
      '@typescript-eslint/no-unused-vars': 'off',
    },
  },
  // Special config for mock files
  {
    files: ['src/tests/__mocks__/**/*.js'],
    rules: {
      '@typescript-eslint/no-unused-vars': 'off',
      '@typescript-eslint/no-explicit-any': 'off',
    },
  },
  // Ignore patterns
  {
    ignores: [
      'node_modules/',
      'dist/',
      'coverage/',
      '.turbo/',
      'vitest.*.config.ts',
      '*.cjs',
      'src/generated/',
      'public/',
      'prisma/migrations/',
    ],
  },
];


================================================================================
### FILE: bookworm-backend\package.json
================================================================================

{
  "name": "bookworm-backend",
  "version": "1.0.0",
  "description": "",
  "main": "dist/index.js",
  "scripts": {
    "dev": "nodemon --watch \"src/**/*.ts\" --exec \"npx ts-node\" src/index.ts",
    "build": "tsc",
    "start": "node dist/index.js",
    "test": "vitest run --coverage",
    "migrate:dev": "npx prisma migrate dev",
    "db:migrate:test": "dotenv -e .env.test -- npx prisma db push",
    "db:migrate:test:reset": "dotenv -e .env.test -- npx prisma migrate reset --force",
    "seed": "prisma db seed",
    "job:cancel-orders": "npx ts-node src/jobs/cancelExpiredOrders.ts",
    "postinstall": "cp node_modules/@zxing/library/umd/index.min.js public/zxing.min.js",
    "test:integration": "dotenv -e .env.test -- vitest run --config vitest.integration.config.ts",
    "lint": "eslint . --ext .ts",
    "lint:fix": "eslint . --ext .ts --fix"
  },
  "prisma": {
    "seed": "ts-node prisma/seed.ts"
  },
  "dependencies": {
    "@fastify/env": "^5.0.2",
    "@fastify/rate-limit": "^9.1.0",
    "@fastify/static": "^7.0.4",
    "@prisma/client": "^6.16.2",
    "@sinclair/typebox": "^0.34.41",
    "@types/jsonwebtoken": "^9.0.10",
    "axios": "^1.12.0",
    "dotenv": "^16.4.5",
    "env-schema": "^6.0.1",
    "fast-jwt": "^6.0.2",
    "fastify": "^4.27.0",
    "fastify-plugin": "^5.0.1",
    "fastify-raw-body": "^4.3.0",
    "jsonwebtoken": "^9.0.2",
    "node-cron": "^4.2.1",
    "prom-client": "^15.1.3",
    "wechatpay-node-v3": "^2.2.1"
  },
  "devDependencies": {
    "@testcontainers/postgresql": "^11.5.1",
    "@types/node": "^20.14.2",
    "@types/node-cron": "^3.0.11",
    "@types/supertest": "^6.0.3",
    "@typescript-eslint/eslint-plugin": "^8.43.0",
    "@typescript-eslint/parser": "^8.43.0",
    "@vitest/coverage-v8": "^3.2.4",
    "@zxing/library": "^0.21.3",
    "dotenv-cli": "^10.0.0",
    "eslint": "^9.35.0",
    "nodemon": "^3.1.2",
    "prisma": "^6.16.2",
    "sqlite3": "^5.1.7",
    "supertest": "^7.1.4",
    "ts-node": "^10.9.2",
    "typescript": "^5.4.5",
    "vitest": "^3.2.4",
    "vitest-mock-extended": "^3.1.0"
  },
  "keywords": [],
  "author": "",
  "license": "ISC"
}


================================================================================
### FILE: bookworm-backend\prisma\migrations\20250927072418_initial_schema_squashed\migration.sql
================================================================================

-- CreateEnum
CREATE EXTENSION IF NOT EXISTS "pg_trgm" WITH SCHEMA public;

-- CreateEnum
CREATE TYPE "public"."book_condition" AS ENUM ('NEW', 'GOOD', 'ACCEPTABLE');

-- CreateEnum
CREATE TYPE "public"."inventory_status" AS ENUM ('in_stock', 'reserved', 'sold', 'returned', 'damaged');

-- CreateEnum
CREATE TYPE "public"."Role" AS ENUM ('USER', 'STAFF');

-- CreateEnum
CREATE TYPE "public"."OrderStatus" AS ENUM ('PENDING_PAYMENT', 'PENDING_PICKUP', 'COMPLETED', 'CANCELLED', 'RETURNED');

-- CreateEnum
CREATE TYPE "public"."PaymentStatus" AS ENUM ('PENDING', 'SUCCESS', 'REFUND_REQUIRED', 'REFUNDED', 'FAILED', 'REFUND_PROCESSING');

-- CreateTable
CREATE TABLE "public"."Order" (
    "id" SERIAL NOT NULL,
    "user_id" INTEGER NOT NULL,
    "status" "public"."OrderStatus" NOT NULL DEFAULT 'PENDING_PAYMENT',
    "total_amount" DECIMAL(10,2) NOT NULL,
    "pickup_code" VARCHAR(16) NOT NULL,
    "createdAt" TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "paymentExpiresAt" TIMESTAMPTZ(6) NOT NULL,
    "pickupExpiresAt" TIMESTAMPTZ(6),
    "paid_at" TIMESTAMPTZ(6),
    "completed_at" TIMESTAMPTZ(6),
    "cancelled_at" TIMESTAMPTZ(6),

    CONSTRAINT "Order_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "public"."pending_payment_order" (
    "order_id" INTEGER NOT NULL,
    "user_id" INTEGER NOT NULL,
    "created_at" TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "pending_payment_order_pkey" PRIMARY KEY ("order_id")
);

-- CreateTable
CREATE TABLE "public"."User" (
    "id" SERIAL NOT NULL,
    "openid" VARCHAR(255) NOT NULL,
    "unionid" VARCHAR(255),
    "nickname" VARCHAR(255),
    "avatar_url" VARCHAR(255),
    "role" "public"."Role" NOT NULL DEFAULT 'USER',
    "created_at" TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "User_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "public"."bookmaster" (
    "id" SERIAL NOT NULL,
    "isbn13" VARCHAR(13) NOT NULL,
    "title" VARCHAR(255) NOT NULL,
    "author" VARCHAR(255),
    "publisher" VARCHAR(255),
    "original_price" DECIMAL(10,2),
    "created_at" TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updated_at" TIMESTAMPTZ(6) NOT NULL,

    CONSTRAINT "bookmaster_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "public"."booksku" (
    "id" SERIAL NOT NULL,
    "master_id" INTEGER NOT NULL,
    "edition" VARCHAR(50),
    "description" TEXT,
    "cover_image_url" VARCHAR(255),
    "created_at" TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updated_at" TIMESTAMPTZ(6) NOT NULL,

    CONSTRAINT "booksku_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "public"."inventoryitem" (
    "id" SERIAL NOT NULL,
    "sku_id" INTEGER NOT NULL,
    "condition" "public"."book_condition" NOT NULL,
    "cost" DECIMAL(10,2) NOT NULL,
    "selling_price" DECIMAL(10,2) NOT NULL,
    "status" "public"."inventory_status" NOT NULL DEFAULT 'in_stock',
    "created_at" TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updated_at" TIMESTAMPTZ(6) NOT NULL,

    CONSTRAINT "inventoryitem_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "public"."inventory_reservation" (
    "inventory_item_id" INTEGER NOT NULL,
    "order_id" INTEGER NOT NULL,
    "created_at" TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "inventory_reservation_pkey" PRIMARY KEY ("inventory_item_id")
);

-- CreateTable
CREATE TABLE "public"."orderitem" (
    "id" SERIAL NOT NULL,
    "order_id" INTEGER NOT NULL,
    "inventory_item_id" INTEGER NOT NULL,
    "price" DECIMAL(10,2) NOT NULL,

    CONSTRAINT "orderitem_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "public"."Content" (
    "id" SERIAL NOT NULL,
    "slug" VARCHAR(255) NOT NULL,
    "title" VARCHAR(255) NOT NULL,
    "body" TEXT NOT NULL,
    "createdAt" TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "Content_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "public"."PaymentRecord" (
    "id" SERIAL NOT NULL,
    "order_id" INTEGER NOT NULL,
    "out_trade_no" VARCHAR(100) NOT NULL,
    "transaction_id" VARCHAR(100),
    "status" "public"."PaymentStatus" NOT NULL DEFAULT 'PENDING',
    "amount_total" INTEGER NOT NULL,
    "payer_openid" VARCHAR(255),
    "appid" VARCHAR(100),
    "mchid" VARCHAR(100),
    "createdAt" TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMPTZ(6) NOT NULL,
    "notified_at" TIMESTAMP(3),
    "refunded_at" TIMESTAMP(3),
    "refund_id" VARCHAR(100),
    "refund_attempts" INTEGER NOT NULL DEFAULT 0,

    CONSTRAINT "PaymentRecord_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE UNIQUE INDEX "Order_pickup_code_key" ON "public"."Order"("pickup_code");

-- CreateIndex
CREATE INDEX "idx_order_user_id_status" ON "public"."Order"("user_id", "status");

-- CreateIndex
CREATE INDEX "idx_order_created_at" ON "public"."Order"("createdAt");

-- CreateIndex
CREATE INDEX "idx_order_user_created_at_id" ON "public"."Order"("user_id", "createdAt", "id");

-- CreateIndex
CREATE UNIQUE INDEX "uniq_order_pending_per_user" ON "public"."pending_payment_order"("user_id");

-- CreateIndex
CREATE UNIQUE INDEX "User_openid_key" ON "public"."User"("openid");

-- CreateIndex
CREATE UNIQUE INDEX "User_unionid_key" ON "public"."User"("unionid");

-- CreateIndex
CREATE UNIQUE INDEX "bookmaster_isbn13_key" ON "public"."bookmaster"("isbn13");

-- CreateIndex
CREATE INDEX "idx_book_master_isbn13" ON "public"."bookmaster"("isbn13");

-- CreateIndex
CREATE INDEX "idx_bookmaster_author_gin_trgm" ON "public"."bookmaster" USING GIN ("author" gin_trgm_ops);

-- CreateIndex
CREATE INDEX "idx_bookmaster_title_gin_trgm" ON "public"."bookmaster" USING GIN ("title" gin_trgm_ops);

-- CreateIndex
CREATE UNIQUE INDEX "booksku_master_id_edition_key" ON "public"."booksku"("master_id", "edition");

-- CreateIndex
CREATE INDEX "idx_inventory_item_sku_id_status" ON "public"."inventoryitem"("sku_id", "status");

-- CreateIndex
CREATE INDEX "idx_inventory_reservation_order_id" ON "public"."inventory_reservation"("order_id");

-- CreateIndex
CREATE INDEX "idx_orderitem_inventory_item_id" ON "public"."orderitem"("inventory_item_id");

-- CreateIndex
CREATE UNIQUE INDEX "uniq_orderitem_order_inventory" ON "public"."orderitem"("order_id", "inventory_item_id");

-- CreateIndex
CREATE UNIQUE INDEX "Content_slug_key" ON "public"."Content"("slug");

-- CreateIndex
CREATE INDEX "idx_content_slug" ON "public"."Content"("slug");

-- CreateIndex
CREATE UNIQUE INDEX "PaymentRecord_out_trade_no_key" ON "public"."PaymentRecord"("out_trade_no");

-- CreateIndex
CREATE UNIQUE INDEX "PaymentRecord_transaction_id_key" ON "public"."PaymentRecord"("transaction_id");

-- CreateIndex
CREATE UNIQUE INDEX "PaymentRecord_refund_id_key" ON "public"."PaymentRecord"("refund_id");

-- CreateIndex
CREATE INDEX "PaymentRecord_order_id_idx" ON "public"."PaymentRecord"("order_id");

-- CreateIndex
CREATE INDEX "PaymentRecord_status_createdAt_idx" ON "public"."PaymentRecord"("status", "createdAt");

-- AddForeignKey
ALTER TABLE "public"."Order" ADD CONSTRAINT "fk_user" FOREIGN KEY ("user_id") REFERENCES "public"."User"("id") ON DELETE NO ACTION ON UPDATE NO ACTION;

-- AddForeignKey
ALTER TABLE "public"."pending_payment_order" ADD CONSTRAINT "fk_pending_order" FOREIGN KEY ("order_id") REFERENCES "public"."Order"("id") ON DELETE CASCADE ON UPDATE NO ACTION;

-- AddForeignKey
ALTER TABLE "public"."pending_payment_order" ADD CONSTRAINT "fk_pending_user" FOREIGN KEY ("user_id") REFERENCES "public"."User"("id") ON DELETE CASCADE ON UPDATE NO ACTION;

-- AddForeignKey
ALTER TABLE "public"."booksku" ADD CONSTRAINT "fk_master" FOREIGN KEY ("master_id") REFERENCES "public"."bookmaster"("id") ON DELETE NO ACTION ON UPDATE NO ACTION;

-- AddForeignKey
ALTER TABLE "public"."inventoryitem" ADD CONSTRAINT "fk_sku" FOREIGN KEY ("sku_id") REFERENCES "public"."booksku"("id") ON DELETE NO ACTION ON UPDATE NO ACTION;

-- AddForeignKey
ALTER TABLE "public"."inventory_reservation" ADD CONSTRAINT "fk_reservation_item" FOREIGN KEY ("inventory_item_id") REFERENCES "public"."inventoryitem"("id") ON DELETE CASCADE ON UPDATE NO ACTION;

-- AddForeignKey
ALTER TABLE "public"."inventory_reservation" ADD CONSTRAINT "fk_reservation_order" FOREIGN KEY ("order_id") REFERENCES "public"."Order"("id") ON DELETE CASCADE ON UPDATE NO ACTION;

-- AddForeignKey
ALTER TABLE "public"."orderitem" ADD CONSTRAINT "fk_inventory_item" FOREIGN KEY ("inventory_item_id") REFERENCES "public"."inventoryitem"("id") ON DELETE NO ACTION ON UPDATE NO ACTION;

-- AddForeignKey
ALTER TABLE "public"."orderitem" ADD CONSTRAINT "fk_order" FOREIGN KEY ("order_id") REFERENCES "public"."Order"("id") ON DELETE NO ACTION ON UPDATE NO ACTION;

-- AddForeignKey
ALTER TABLE "public"."PaymentRecord" ADD CONSTRAINT "PaymentRecord_order_id_fkey" FOREIGN KEY ("order_id") REFERENCES "public"."Order"("id") ON DELETE RESTRICT ON UPDATE CASCADE;


================================================================================
### FILE: bookworm-backend\prisma\migrations\migration_lock.toml
================================================================================

# Please do not edit this file manually
# It should be added in your version-control system (e.g., Git)
provider = "postgresql"


================================================================================
### FILE: bookworm-backend\prisma\schema.prisma
================================================================================

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Order {
  id               Int                    @id @default(autoincrement())
  user_id          Int
  status           OrderStatus            @default(PENDING_PAYMENT)
  total_amount     Decimal                @db.Decimal(10, 2)
  pickup_code      String                 @unique @db.VarChar(16)
  createdAt        DateTime               @default(now()) @db.Timestamptz(6)
  paymentExpiresAt DateTime               @db.Timestamptz(6)
  pickupExpiresAt  DateTime?              @db.Timestamptz(6)
  paid_at          DateTime?              @db.Timestamptz(6)
  completed_at     DateTime?              @db.Timestamptz(6)
  cancelled_at     DateTime?              @db.Timestamptz(6)
  User             User                   @relation(fields: [user_id], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "fk_user")
  orderItem        OrderItem[]
  PaymentRecord    PaymentRecord[]
  reservations     InventoryReservation[]
  pendingGuard     PendingPaymentOrder?

  @@index([user_id, status], map: "idx_order_user_id_status")
  @@index([createdAt], map: "idx_order_created_at")
  @@index([user_id, createdAt, id], map: "idx_order_user_created_at_id")
}

model PendingPaymentOrder {
  order_id   Int      @id
  user_id    Int
  created_at DateTime @default(now()) @db.Timestamptz(6)

  Order Order @relation(fields: [order_id], references: [id], onDelete: Cascade, onUpdate: NoAction, map: "fk_pending_order")
  User  User  @relation(fields: [user_id], references: [id], onDelete: Cascade, onUpdate: NoAction, map: "fk_pending_user")

  @@unique([user_id], map: "uniq_order_pending_per_user")
  @@map("pending_payment_order")
}

model User {
  id            Int                   @id @default(autoincrement())
  openid        String                @unique @db.VarChar(255)
  unionid       String?               @unique @db.VarChar(255)
  nickname      String?               @db.VarChar(255)
  avatar_url    String?               @db.VarChar(255)
  role          Role                  @default(USER)
  created_at    DateTime              @default(now()) @db.Timestamptz(6)
  Order         Order[]
  pendingOrders PendingPaymentOrder[]
}

model BookMaster {
  id             Int       @id @default(autoincrement())
  isbn13         String    @unique @db.VarChar(13)
  title          String    @db.VarChar(255)
  author         String?   @db.VarChar(255)
  publisher      String?   @db.VarChar(255)
  original_price Decimal?  @db.Decimal(10, 2)
  created_at     DateTime  @default(now()) @db.Timestamptz(6)
  updated_at     DateTime  @updatedAt @db.Timestamptz(6)
  bookSku        BookSku[]

  @@index([isbn13], map: "idx_book_master_isbn13")
  @@index([author(ops: raw("gin_trgm_ops"))], map: "idx_bookmaster_author_gin_trgm", type: Gin)
  @@index([title(ops: raw("gin_trgm_ops"))], map: "idx_bookmaster_title_gin_trgm", type: Gin)
  @@map("bookmaster")
}

model BookSku {
  id              Int             @id @default(autoincrement())
  master_id       Int
  edition         String?         @db.VarChar(50)
  description     String?
  cover_image_url String?         @db.VarChar(255)
  created_at      DateTime        @default(now()) @db.Timestamptz(6)
  updated_at      DateTime        @updatedAt @db.Timestamptz(6)
  bookMaster      BookMaster      @relation(fields: [master_id], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "fk_master")
  inventoryItems  InventoryItem[]

  @@unique([master_id, edition])
  @@map("booksku")
}

model InventoryItem {
  id            Int                   @id @default(autoincrement())
  sku_id        Int
  condition     book_condition
  cost          Decimal               @db.Decimal(10, 2)
  selling_price Decimal               @db.Decimal(10, 2)
  status        inventory_status      @default(in_stock)
  created_at    DateTime              @default(now()) @db.Timestamptz(6)
  updated_at    DateTime              @updatedAt @db.Timestamptz(6)
  bookSku       BookSku               @relation(fields: [sku_id], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "fk_sku")
  orderItem     OrderItem[]
  reservation   InventoryReservation?

  @@index([sku_id, status], map: "idx_inventory_item_sku_id_status")
  @@map("inventoryitem")
}

model InventoryReservation {
  inventory_item_id Int      @id
  order_id          Int
  created_at        DateTime @default(now()) @db.Timestamptz(6)

  inventoryItem InventoryItem @relation(fields: [inventory_item_id], references: [id], onDelete: Cascade, onUpdate: NoAction, map: "fk_reservation_item")
  order         Order         @relation(fields: [order_id], references: [id], onDelete: Cascade, onUpdate: NoAction, map: "fk_reservation_order")

  @@index([order_id], map: "idx_inventory_reservation_order_id")
  @@map("inventory_reservation")
}

model OrderItem {
  id                Int           @id @default(autoincrement())
  order_id          Int
  inventory_item_id Int
  price             Decimal       @db.Decimal(10, 2)
  inventoryItem     InventoryItem @relation(fields: [inventory_item_id], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "fk_inventory_item")
  Order             Order         @relation(fields: [order_id], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "fk_order")

  @@unique([order_id, inventory_item_id], map: "uniq_orderitem_order_inventory")
  @@index([inventory_item_id], map: "idx_orderitem_inventory_item_id")
  @@map("orderitem")
}

model Content {
  id        Int      @id @default(autoincrement())
  slug      String   @unique @db.VarChar(255)
  title     String   @db.VarChar(255)
  body      String
  createdAt DateTime @default(now()) @db.Timestamptz(6)
  updatedAt DateTime @default(now()) @updatedAt @db.Timestamptz(6)

  @@index([slug], map: "idx_content_slug")
}

model PaymentRecord {
  id              Int           @id @default(autoincrement())
  order_id        Int
  out_trade_no    String        @unique @db.VarChar(100)
  transaction_id  String?       @unique @db.VarChar(100)
  status          PaymentStatus @default(PENDING)
  amount_total    Int
  payer_openid    String?       @db.VarChar(255)
  appid           String?       @db.VarChar(100)
  mchid           String?       @db.VarChar(100)
  createdAt       DateTime      @default(now()) @db.Timestamptz(6)
  updatedAt       DateTime      @updatedAt @db.Timestamptz(6)
  notified_at     DateTime?
  refunded_at     DateTime?
  refund_id       String?       @unique @db.VarChar(100)
  refund_attempts Int           @default(0)
  Order           Order         @relation(fields: [order_id], references: [id])

  @@index([order_id])
  @@index([status, createdAt])
}

enum book_condition {
  NEW
  GOOD
  ACCEPTABLE
}

enum inventory_status {
  in_stock
  reserved
  sold
  returned
  damaged
}

enum Role {
  USER
  STAFF
}

enum OrderStatus {
  PENDING_PAYMENT
  PENDING_PICKUP
  COMPLETED
  CANCELLED
  RETURNED
}

enum PaymentStatus {
  PENDING
  SUCCESS
  REFUND_REQUIRED
  REFUNDED
  FAILED
  REFUND_PROCESSING
}


================================================================================
### FILE: bookworm-backend\prisma\seed.ts
================================================================================

// bookworm-backend/prisma/seed.ts

import { PrismaClient, book_condition } from '@prisma/client';

const prisma = new PrismaClient();

const booksToSeed = [
  {
    master: {
      isbn13: '9787111594251',
      title: 'æ·±å…¥ç†è§£è®¡ç®—æœºç³»ç»Ÿï¼ˆåŸä¹¦ç¬¬3ç‰ˆï¼‰',
      author: 'Randal E. Bryant',
      publisher: 'æœºæ¢°å·¥ä¸šå‡ºç‰ˆç¤¾',
      original_price: 139.00,
    },
    skus: [
      {
        edition: 'åŸä¹¦ç¬¬3ç‰ˆ',
        cover_image_url: 'https://img3.doubanio.com/view/subject/l/public/s29634731.jpg',
        inventory: [
          { condition: book_condition.NEW, cost: 70.00, selling_price: 95.00 },
          { condition: book_condition.GOOD, cost: 50.00, selling_price: 75.50 },
          { condition: book_condition.ACCEPTABLE, cost: 30.00, selling_price: 45.00 },
        ],
      },
    ],
  },
  {
    master: {
      isbn13: '9787115428868',
      title: 'ä»£ç æ•´æ´ä¹‹é“',
      author: 'Robert C. Martin',
      publisher: 'äººæ°‘é‚®ç”µå‡ºç‰ˆç¤¾',
      original_price: 59.00,
    },
    skus: [
      {
        edition: 'ä¸­æ–‡ç‰ˆ',
        cover_image_url: 'https://img1.doubanio.com/view/subject/l/public/s4418368.jpg',
        inventory: [
          { condition: book_condition.GOOD, cost: 25.00, selling_price: 38.00 },
          { condition: book_condition.GOOD, cost: 26.00, selling_price: 39.00 },
        ],
      },
    ],
  },
  {
    master: {
      isbn13: '9787115546029',
      title: 'æ·±å…¥æµ…å‡ºNode.js',
      author: 'æœ´çµ',
      publisher: 'äººæ°‘é‚®ç”µå‡ºç‰ˆç¤¾',
      original_price: 69.00,
    },
    skus: [
      {
        edition: 'ç¬¬ä¸€ç‰ˆ',
        cover_image_url: 'https://img9.doubanio.com/view/subject/l/public/s27204686.jpg',
        inventory: [
          { condition: book_condition.ACCEPTABLE, cost: 15.00, selling_price: 25.00 },
        ],
      },
    ],
  },
  {
    master: {
      isbn13: '9787508649719',
      title: 'Sapiens: A Brief History of Humankind',
      author: 'Yuval Noah Harari',
      publisher: 'ä¸­ä¿¡å‡ºç‰ˆç¤¾',
      original_price: 68.00,
    },
    skus: [
      {
        edition: 'ä¸­æ–‡ç‰ˆ',
        cover_image_url: 'https://img2.doubanio.com/view/subject/l/public/s27371512.jpg',
        inventory: [
          { condition: book_condition.GOOD, cost: 30.00, selling_price: 42.00 },
        ],
      },
      {
        edition: 'è‹±æ–‡åŸç‰ˆ',
        cover_image_url: 'https://img2.doubanio.com/view/subject/l/public/s29810813.jpg',
        inventory: [
          { condition: book_condition.NEW, cost: 50.00, selling_price: 78.00 },
        ],
      }
    ],
  },
];

async function main() {
  console.log('Start seeding...');

  // To ensure idempotency, we first clean up the tables that represent physical items.
  // We don't delete BookMaster or BookSKU to preserve their IDs.
  await prisma.orderItem.deleteMany({});
  await prisma.order.deleteMany({});
  await prisma.inventoryItem.deleteMany({});
  
  console.log('Cleaned up existing inventory and order data.');

  for (const book of booksToSeed) {
    await prisma.$transaction(async (tx) => {
      // Upsert BookMaster
      const bookMaster = await tx.bookMaster.upsert({
        where: { isbn13: book.master.isbn13 },
        update: book.master,
        create: book.master,
      });

      for (const skuData of book.skus) {
        // Upsert BookSKU
        const bookSku = await tx.bookSku.upsert({
          where: {
            master_id_edition: {
              master_id: bookMaster.id,
              edition: skuData.edition,
            },
          },
          update: {
            cover_image_url: skuData.cover_image_url,
          },
          create: {
            master_id: bookMaster.id,
            edition: skuData.edition,
            cover_image_url: skuData.cover_image_url,
          },
        });

        // Create InventoryItems
        if (skuData.inventory && skuData.inventory.length > 0) {
          await tx.inventoryItem.createMany({
            data: skuData.inventory.map(item => ({
              sku_id: bookSku.id,
              ...item,
            })),
          });
        }
      }
    });
    console.log(`Seeded book: ${book.master.title}`);
  }

  console.log('Seeding finished.');
}

main()
  .catch((e) => {
    console.error(e);
    process.exit(1);
  })
  .finally(async () => {
    await prisma.$disconnect();
  });


================================================================================
### FILE: bookworm-backend\prometheus.yml
================================================================================

# prometheus.yml
global:
  scrape_interval: 15s

scrape_configs:
  - job_name: 'bookworm-backend'
    static_configs:
      - targets: ['host.docker.internal:8080']


================================================================================
### FILE: bookworm-backend\src\adapters\wechatPayAdapter.ts
================================================================================

// src/adapters/wechatPayAdapter.ts
// Type-safe adapter for WeChat Pay SDK, isolating all 'as any' casts

import WechatPay from "wechatpay-node-v3";
import { WechatPayError } from "../errors";
import { isAxiosError } from "../utils/typeGuards";

// --- STRICT INPUT/OUTPUT INTERFACES ---

export interface WechatPayConfig {
  appid: string;
  mchid: string;
  privateKey: Buffer;
  serial_no: string;
  key: string;
}

export interface CreatePaymentOrderRequest {
  appid: string;
  mchid: string;
  description: string;
  out_trade_no: string;
  notify_url: string;
  time_expire: string;
  amount: {
    total: number;
    currency: string;
  };
  payer: {
    openid: string;
  };
}

export interface CreatePaymentOrderResponse {
  prepay_id: string;
}

export interface QueryPaymentRequest {
  out_trade_no: string;
  mchid: string;
}

export interface QueryPaymentResponse {
  trade_state: string;
  amount: {
    total: number;
    currency: string;
  };
  payer?: {
    openid: string;
  };
  mchid: string;
  appid: string;
  transaction_id?: string;
}

export interface VerifySignatureRequest {
  timestamp: string;
  nonce: string;
  body: string | Buffer;
  signature: string;
  serial: string;
}

export interface SignRequest {
  message: string;
}

export interface DecryptDataRequest {
  ciphertext: string;
  associated_data: string;
  nonce: string;
  apiv3Key: string;
}

export interface CreateRefundRequest {
  out_trade_no: string;
  out_refund_no: string;
  reason?: string;
  amount: {
    refund: number;
    total: number;
    currency: string;
  };
}

export interface CreateRefundResponse {
  status: string; // e.g., 'SUCCESS', 'PROCESSING'
  refund_id?: string;
  out_refund_no: string;
  transaction_id?: string;
  out_trade_no: string;
}

// --- ADAPTER CLASS ---

export class WechatPayAdapter {
  private readonly payInstance: any; // Keep 'any' confined to this private field

  constructor(config: WechatPayConfig) {
    // This is the ONLY place where we use 'as any' - confined to initialization
    this.payInstance = new WechatPay({
      appid: config.appid,
      mchid: config.mchid,
      privateKey: config.privateKey,
      serial_no: config.serial_no,
      key: config.key,
    } as any) as any;
  }

  /**
   * Create a payment order using JSAPI
   * @param request - Payment order details
   * @returns Promise with prepay_id and other response data
   * @throws Error if payment creation fails
   */
  async createPaymentOrder(request: CreatePaymentOrderRequest): Promise<CreatePaymentOrderResponse> {
    try {
      const response = await this.payInstance.transactions_jsapi(request);

      // Validate response structure
      if (!response || typeof response.prepay_id !== 'string') {
        throw new Error('Invalid response from WeChat Pay: missing prepay_id');
      }

      return {
        prepay_id: response.prepay_id,
      };
    } catch (error) {
      throw new Error(`Failed to create payment order: ${(error as Error).message}`);
    }
  }

  /**
   * Query payment status by out_trade_no
   * @param request - Query parameters
   * @returns Promise with payment status and details
   * @throws WechatPayError with appropriate error classification
   */
  async queryPaymentStatus(request: QueryPaymentRequest): Promise<QueryPaymentResponse> {
    try {
      const response = await this.payInstance.transactions_out_trade_no(request);

      // Validate required fields in response
      if (!response || !response.trade_state) {
        throw new Error('Invalid response from WeChat Pay: missing trade_state');
      }

      if (!response.amount || typeof response.amount.total !== 'number') {
        throw new Error('Invalid response from WeChat Pay: invalid amount structure');
      }

      return {
        trade_state: response.trade_state,
        amount: {
          total: response.amount.total,
          currency: response.amount.currency || 'CNY',
        },
        payer: response.payer ? { openid: response.payer.openid } : undefined,
        mchid: response.mchid,
        appid: response.appid,
        transaction_id: response.transaction_id,
      };
    } catch (error) {
      if (isAxiosError(error)) {
        const status = error.response?.status;
        const message = error.response?.data?.message || error.message;

        if (status === 404 || message.includes('ORDER_NOT_EXIST')) {
          throw new WechatPayError('ORDER_NOT_FOUND', false, `Order not found on WeChat's side: ${message}`, error);
        }
        if (status && status >= 400 && status < 500) {
          throw new WechatPayError('INVALID_REQUEST', false, `Invalid request to WeChat Pay: ${message}`, error);
        }
        if (status && status >= 500) {
          throw new WechatPayError('WECHAT_SERVER_ERROR', true, `WeChat Pay server error: ${message}`, error);
        }
      }
      // For non-axios errors (e.g., network timeout, DNS), assume they are retryable.
      throw new WechatPayError('NETWORK_ERROR', true, `Network error during payment query: ${(error as Error).message}`, error);
    }
  }

  /**
   * Verify signature from WeChat Pay notification
   * @param request - Signature verification parameters
   * @returns true if signature is valid, false otherwise
   */
  verifySignature(request: VerifySignatureRequest): boolean {
    try {
      return this.payInstance.verifySign({
        timestamp: request.timestamp,
        nonce: request.nonce,
        body: request.body,
        signature: request.signature,
        serial: request.serial,
      });
    } catch (error) {
      // Log error but return false instead of throwing
      console.error('WeChat Pay signature verification failed:', error);
      return false;
    }
  }

  /**
   * Decrypt encrypted data from WeChat Pay notification
   * @param request - Decryption parameters
   * @returns Decrypted string data
   * @throws Error if decryption fails
   */
  decryptNotificationData(request: DecryptDataRequest): string {
    try {
      const result = this.payInstance.decipher_gcm(
        request.ciphertext,
        request.associated_data,
        request.nonce,
        request.apiv3Key
      );

      if (typeof result !== 'string') {
        throw new Error('Decryption result is not a string');
      }

      return result;
    } catch (error) {
      throw new Error(`Failed to decrypt notification data: ${(error as Error).message}`);
    }
  }

  /**
   * Generate RSA signature for WeChat Pay
   * @param request - Data to sign
   * @returns Signature string
   * @throws Error if signing fails
   */
  generateSignature(request: SignRequest): string {
    try {
      const signature = this.payInstance.sign(request.message);

      if (typeof signature !== 'string') {
        throw new Error('Signature generation returned non-string result');
      }

      return signature;
    } catch (error) {
      throw new Error(`Failed to generate signature: ${(error as Error).message}`);
    }
  }

  /**
   * Create a refund for a transaction
   * @param request - Refund details
   * @returns Promise with refund status
   * @throws WechatPayError with appropriate error classification
   */
  async createRefund(request: CreateRefundRequest): Promise<CreateRefundResponse> {
    try {
      // The SDK method name is typically plural, like 'refunds'
      const response = await this.payInstance.refunds(request);

      if (!response || !response.status) {
        throw new Error('Invalid response from WeChat Pay refund API: missing status');
      }

      return {
        status: response.status,
        refund_id: response.refund_id,
        out_refund_no: response.out_refund_no || request.out_refund_no,
        transaction_id: response.transaction_id,
        out_trade_no: response.out_trade_no || request.out_trade_no,
      };
    } catch (error) {
      if (isAxiosError(error)) {
        const status = error.response?.status;
        const message = error.response?.data?.message || error.message;

        if (status && status >= 400 && status < 500) {
          throw new WechatPayError('INVALID_REFUND_REQUEST', false, `Invalid refund request: ${message}`, error);
        }
        if (status && status >= 500) {
          throw new WechatPayError('WECHAT_SERVER_ERROR', true, `WeChat Pay server error during refund: ${message}`, error);
        }
      }
      throw new WechatPayError('NETWORK_ERROR', true, `Network error during refund creation: ${(error as Error).message}`, error);
    }
  }
}

// --- FACTORY FUNCTION FOR CLEAN INITIALIZATION ---

export function createWechatPayAdapter(config: WechatPayConfig): WechatPayAdapter {
  return new WechatPayAdapter(config);
}


================================================================================
### FILE: bookworm-backend\src\app-factory.ts
================================================================================

// src/app-factory.ts
// Factory function to create Fastify app with proper database setup for tests

// Override the DATABASE_URL for tests using test containers
export const setupTestDatabase = () => {
  if (process.env.NODE_ENV === 'test' && process.env.TEST_CONTAINERS) {
    const containers = JSON.parse(process.env.TEST_CONTAINERS);
    const workerId = parseInt(process.env.VITEST_WORKER_ID || '1', 10);
    const databaseUrl = containers[workerId] || containers['1'];

    if (databaseUrl) {
      // Override the DATABASE_URL for this process
      process.env.DATABASE_URL = databaseUrl;
      console.log(`âœ… Test database URL set for worker ${workerId}: ${databaseUrl.substring(0, 30)}...`);
    }
  }
};

// Call this function before importing the main app to ensure the correct DATABASE_URL is used
export const createTestApp = async () => {
  setupTestDatabase();
  // Import after setting up the database URL
  const { buildApp } = await import('./index');
  return buildApp();
};


================================================================================
### FILE: bookworm-backend\src\config.ts
================================================================================

// src/config.ts
import { envSchema } from "env-schema";
import { Static, Type } from "@sinclair/typebox";


const schema = Type.Object({
  // Server
  PORT: Type.Number({ default: 8080 }),
  HOST: Type.String({ default: "127.0.0.1" }),
  NODE_ENV: Type.String({
    enum: ["development", "production", "test"],
    default: "development",
  }),
  LOG_LEVEL: Type.String({ default: "info" }),

  // Database
  DATABASE_URL: Type.String(),

  // JWT
  JWT_SECRET: Type.String(),
  JWT_EXPIRES_IN: Type.String({ default: "7d" }),

  // WeChat Mini Program
  WX_APP_ID: Type.String(),
  WX_APP_SECRET: Type.String(),

  // WeChat Pay (optional, can be empty strings in dev)
  WXPAY_MCHID: Type.String({ default: "" }),
  WXPAY_PRIVATE_KEY_PATH: Type.String({ default: "" }),
  WXPAY_CERT_SERIAL_NO: Type.String({ default: "" }),
  WXPAY_API_V3_KEY: Type.String({ default: "" }),
  WXPAY_NOTIFY_URL: Type.String({ default: "" }),

  // Tanshu API
  TANSHU_API_KEY: Type.String({ default: "" }),

  // Business Logic Constants ("Magic Numbers")
  ORDER_PAYMENT_TTL_MINUTES: Type.Number({ default: 15 }),
  ORDER_PICKUP_CODE_LENGTH: Type.Number({ default: 10 }),
  ORDER_PICKUP_CODE_BYTES: Type.Number({ default: 5 }),
  MAX_ITEMS_PER_ORDER: Type.Number({ default: 10 }),
  MAX_RESERVED_ITEMS_PER_USER: Type.Number({ default: 20 }),
  API_RATE_LIMIT_MAX: Type.Number({ default: 5 }),
  API_RATE_LIMIT_WINDOW_MINUTES: Type.Number({ default: 1 }),

  // Database Transaction Retry Configuration
  DB_TRANSACTION_RETRY_COUNT: Type.Number({ default: 3 }),
  DB_TRANSACTION_RETRY_BASE_DELAY_MS: Type.Number({ default: 20 }),
  DB_TRANSACTION_RETRY_JITTER_MS: Type.Number({ default: 40 }),
  PICKUP_CODE_RETRY_COUNT: Type.Number({ default: 5 }),

  // Payment Security
  PAYMENT_TIMESTAMP_TOLERANCE_SECONDS: Type.Number({ default: 300 }),

  // Scheduled Job Configuration
  CRON_ORDER_CLEANUP: Type.String({ default: "*/1 * * * *" }),
  CRON_INVENTORY_METRICS: Type.String({ default: "*/5 * * * *" }),
  CRON_WECHAT_CERT_REFRESH: Type.String({ default: "0 */10 * * *" }),
  CRON_REFUND_PROCESSOR: Type.String({ default: "*/10 * * * *" }),

  // API Rate Limiting
  API_LOGIN_RATE_LIMIT_MAX: Type.Number({ default: 10 }),
  API_FULFILL_RATE_LIMIT_MAX: Type.Number({ default: 30 }),
});

type Schema = Static<typeof schema>;

// The `dotenv: true` option will automatically load the .env file
const config = envSchema<Schema>({
  schema,
  dotenv: true,
});

// Production validation
if (config.NODE_ENV === "production") {
  if (!config.JWT_SECRET || config.JWT_SECRET === "default-secret-for-dev") {
    console.error(
      "FATAL: JWT_SECRET must be set to a strong secret in production.",
    );
    process.exit(1);
  }
  if (!config.DATABASE_URL) {
    console.error("FATAL: DATABASE_URL must be set in production.");
    process.exit(1);
  }
  // Add other critical production checks here
}

export default config;


================================================================================
### FILE: bookworm-backend\src\constants.ts
================================================================================

export const ORDER_STATUS = {
  PENDING_PAYMENT: 'PENDING_PAYMENT',
  PENDING_PICKUP: 'PENDING_PICKUP',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED'
} as const;

export const INVENTORY_STATUS = {
  IN_STOCK: 'in_stock',
  RESERVED: 'reserved',
  SOLD: 'sold'
} as const;

export const ERROR_CODES = {
  UNAUTHORIZED: 'UNAUTHORIZED',
  FORBIDDEN: 'FORBIDDEN',
  VALIDATION_ERROR: 'VALIDATION_ERROR',
  RATE_LIMIT_EXCEEDED: 'RATE_LIMIT_EXCEEDED',
  RECORD_NOT_FOUND: 'RECORD_NOT_FOUND',
  DUPLICATE_RECORD: 'DUPLICATE_RECORD',
  BAD_REQUEST: 'BAD_REQUEST',
  INTERNAL_ERROR: 'INTERNAL_ERROR',
  TX_RETRY_EXCEEDED: 'TX_RETRY_EXCEEDED',
  EMPTY_ITEMS: 'EMPTY_ITEMS',
  ORDER_SIZE_EXCEEDED: 'ORDER_SIZE_EXCEEDED',
  MAX_RESERVED_ITEMS_EXCEEDED: 'MAX_RESERVED_ITEMS_EXCEEDED',
  INSUFFICIENT_INVENTORY_PRECHECK: 'INSUFFICIENT_INVENTORY_PRECHECK',
  PICKUP_CODE_GEN_FAILED: 'PICKUP_CODE_GEN_FAILED',
  INVENTORY_RACE_CONDITION: 'INVENTORY_RACE_CONDITION',
  CONCURRENT_PENDING_ORDER: 'CONCURRENT_PENDING_ORDER'
} as const;

export const ERROR_MESSAGES = {
  AUTHENTICATION_REQUIRED: 'Authentication required',
  ACCESS_DENIED: 'Access denied',
  VALIDATION_FAILED: 'Request validation failed',
  RECORD_NOT_FOUND: 'Record not found',
  DUPLICATE_RECORD: 'A record with this data already exists',
  INTERNAL_ERROR: 'Internal server error',
  SYSTEM_BUSY: 'ç³»ç»Ÿç¹å¿™ï¼Œè¯·ç¨åé‡è¯•',
  NO_BOOKS_SELECTED: 'æ²¡æœ‰é€‰æ‹©ä»»ä½•ä¹¦ç±',
  BOOKS_UNAVAILABLE: 'éƒ¨åˆ†ä¹¦ç±å·²ä¸å¯ç”¨ï¼Œè¯·åˆ·æ–°åé‡è¯•',
  PICKUP_CODE_GENERATION_FAILED: 'æ— æ³•ç”Ÿæˆå”¯ä¸€è®¢å•å–è´§ç ',
  INVENTORY_RACE: 'æ‰‹æ…¢äº†ï¼Œéƒ¨åˆ†ä¹¦ç±å·²è¢«æŠ¢è´­ï¼Œè¯·é‡æ–°ä¸‹å•',
  CONCURRENT_ORDER: 'æ‚¨æœ‰ä¸€ä¸ªæ­£åœ¨ä»˜æ¬¾çš„è®¢å•ï¼Œè¯·å…ˆå®Œæˆä»˜æ¬¾æˆ–ç­‰å¾…è®¢å•è¿‡æœŸ'
} as const;

export const HTTP_STATUS = {
  UNAUTHORIZED: 401,
  FORBIDDEN: 403
} as const;

export const WECHAT_CONSTANTS = {
  JSCODE2SESSION_URL: 'https://api.weixin.qq.com/sns/jscode2session',
  GRANT_TYPE: 'authorization_code',
  SUCCESS_CODE: 'SUCCESS',
  FAIL_CODE: 'FAIL',
  SUCCESS_MESSAGE: 'æˆåŠŸ',
  RETRY_MESSAGE: 'è¯·ç¨åé‡è¯•',
  SIGN_TYPE: 'RSA'
} as const;

export const API_CONSTANTS = {
  TANSHU_BASE_URL: 'https://api.tanshuapi.com/api/isbn/v2/index'
} as const;

export const DEFAULT_VALUES = {
  EDITION: 'default',
  UNKNOWN_TITLE: 'æœªçŸ¥ä¹¦å',
  UNKNOWN_AUTHOR: 'æœªçŸ¥ä½œè€…',
  UNKNOWN_PUBLISHER: 'æœªçŸ¥å‡ºç‰ˆç¤¾',
  NO_SUMMARY: 'æš‚æ— ç®€ä»‹',
  ORDER_NUMBER_PREFIX: 'BOOKWORM_'
} as const;

export const BUSINESS_LIMITS = {
  MAX_REFUND_ATTEMPTS: 5,
  REFUND_BATCH_SIZE: 50,
  TRANSACTION_TIMEOUT_MS: 15000,
  AMOUNT_TO_CENTS_MULTIPLIER: 100,
  MAX_AMOUNT_CENTS: 100000000,
  CLOCK_SKEW_TOLERANCE_SECONDS: 60,
  PAYMENT_QUERY_RETRY_ATTEMPTS: 3,
  PAYMENT_QUERY_RETRY_DELAY_MS: 200,
  ADVISORY_LOCK_TIMEOUT_MS: 5 * 60 * 1000,
  DEFAULT_RETRY_ATTEMPTS: 3,
  DEFAULT_RETRY_DELAY_MS: 100
} as const;

export const ENVIRONMENT_CHECKS = {
  NON_TEST_ENVIRONMENTS: ['production', 'development']
} as const;


================================================================================
### FILE: bookworm-backend\src\db.ts
================================================================================

// bookworm-backend/src/db.ts
import { PrismaClient } from '@prisma/client';

// Add prisma to the NodeJS global type
declare global {
  // eslint-disable-next-line no-var
  var prisma: PrismaClient | undefined;
}

const prisma = global.prisma || new PrismaClient({
  log: process.env.NODE_ENV === 'development' ? ['query', 'info', 'warn', 'error'] : ['warn', 'error'],
});

if (process.env.NODE_ENV !== 'production') {
  global.prisma = prisma;
}

// --- Graceful Shutdown Logic ---

async function gracefulShutdown(signal: string) {
  console.log(`[GRACEFUL SHUTDOWN] Received ${signal}. Shutting down gracefully...`);
  try {
    await prisma.$disconnect();
    console.log('[GRACEFUL SHUTDOWN] Prisma client disconnected successfully.');
  } catch (error) {
    console.error('[GRACEFUL SHUTDOWN] Error during Prisma disconnection:', error);
  }
  console.log('[GRACEFUL SHUTDOWN] Process exiting...');
  process.exit(0);
}

// `beforeExit` is a good fallback for when the event loop empties,
// but it's not called on explicit termination signals.
process.on('beforeExit', async () => {
  console.log('beforeExit event triggered. Disconnecting Prisma client...');
  await prisma.$disconnect();
});

// Listen for the signals that are actually used to terminate processes.
// SIGINT is for Ctrl+C.
// SIGTERM is the standard signal for graceful termination (e.g., from Docker/Kubernetes).
process.on('SIGINT', () => gracefulShutdown('SIGINT'));
process.on('SIGTERM', () => gracefulShutdown('SIGTERM'));

export default prisma;


================================================================================
### FILE: bookworm-backend\src\errors.ts
================================================================================

// src/errors.ts

export class ApiError extends Error {
  public statusCode: number;
  public code: string;

  constructor(statusCode: number, message: string, code: string) {
    super(message);
    this.name = "ApiError";
    this.statusCode = statusCode;
    this.code = code;

    Error.captureStackTrace(this, this.constructor);
  }
}

export class WechatPayError extends Error {
  constructor(
    public code: string, // e.g., 'ORDER_NOT_FOUND', 'SERVER_ERROR', 'INVALID_REQUEST'
    public isRetryable: boolean,
    message: string,
    public originalError?: unknown // Optional: store the original error for logging
  ) {
    super(message);
    this.name = 'WechatPayError';
  }
}

export class PaymentQueryError extends Error {
  constructor(
    public code: string,
    public originalError?: unknown
  ) {
    super(`Payment query failed: ${code}`);
    this.name = 'PaymentQueryError';
  }
}


================================================================================
### FILE: bookworm-backend\src\index.ts
================================================================================

// src/index.ts
import Fastify, { FastifyRequest, FastifyReply } from "fastify";
import { createWechatPayAdapter, WechatPayAdapter } from "./adapters/wechatPayAdapter";
import { Prisma } from "@prisma/client";
import { ApiError } from "./errors";
import config from "./config";
import { verifyDatabaseConstraints } from "./utils/dbVerifier";
import prisma from "./db";
import { ERROR_CODES, ERROR_MESSAGES, HTTP_STATUS } from "./constants";
import * as fs from "fs";
import {
  isFastifyHttpError,
  isFastifyValidationError,
  getErrorMessage
} from "./utils/typeGuards";

// Plugins and Routes
import { registerPlugins } from "./plugins";
import { startCronJobs } from "./jobs";
import authRoutes from "./routes/auth";
import healthRoutes from "./routes/health";
import booksRoutes from "./routes/books";
import inventoryRoutes from "./routes/inventory";
import contentRoutes from "./routes/content";
import ordersRoutes from "./routes/orders";
import paymentRoutes from "./routes/payment";

// --- Type Augmentation for Fastify ---
declare module "fastify" {
  interface FastifyRequest {
    user?: { userId: number; openid: string; role?: string };
    rawBody?: string | Buffer;
  }
  export interface FastifyInstance {
    authenticate: (
      request: FastifyRequest,
      reply: FastifyReply,
    ) => Promise<void>;
    requireRole: (
      role: "USER" | "STAFF",
    ) => (request: FastifyRequest, reply: FastifyReply) => Promise<void>;
  }
}

const fastify = Fastify({
  logger: {
    level: config.LOG_LEVEL,
    redact: ["headers.authorization", "req.headers.authorization"],
  },
  ajv: {
    customOptions: {
      coerceTypes: true,
      useDefaults: true,
    },
  },
});

// --- WeChat Pay Setup ---
let wechatPayAdapter: WechatPayAdapter | null = null;
try {
  if (
    config.WXPAY_MCHID &&
    config.WXPAY_PRIVATE_KEY_PATH &&
    fs.existsSync(config.WXPAY_PRIVATE_KEY_PATH) &&
    config.WXPAY_CERT_SERIAL_NO &&
    config.WXPAY_API_V3_KEY
  ) {
    wechatPayAdapter = createWechatPayAdapter({
      appid: config.WX_APP_ID,
      mchid: config.WXPAY_MCHID,
      privateKey: fs.readFileSync(config.WXPAY_PRIVATE_KEY_PATH),
      serial_no: config.WXPAY_CERT_SERIAL_NO,
      key: config.WXPAY_API_V3_KEY,
    });
    fastify.log.info("WeChat Pay SDK initialized successfully");
  } else {
    throw new Error(
      "WeChat Pay configuration is incomplete or certificate files are missing.",
    );
  }
} catch (error) {
  console.warn(
    `!!! WARNING: Failed to initialize WeChat Pay SDK. Payment features will be disabled. Reason: ${getErrorMessage(error)}`,
  );
}

// --- Global Error Handler ---
fastify.setErrorHandler(
  async (error: unknown, request: FastifyRequest, reply: FastifyReply) => {
    request.log.error(
      { err: error, req: request },
      "An error occurred during the request",
    );

    // Layer 1: Authentication/Authorization errors (401/403)
    if (isFastifyHttpError(error) && (error.statusCode === 401 || error.statusCode === 403)) {
      return reply.code(error.statusCode).send({
        code:
          error.code ||
          (error.statusCode === 401 ? ERROR_CODES.UNAUTHORIZED : ERROR_CODES.FORBIDDEN),
        message:
          error.message ||
          (error.statusCode === 401
            ? ERROR_MESSAGES.AUTHENTICATION_REQUIRED
            : ERROR_MESSAGES.ACCESS_DENIED),
      });
    }

    // Layer 2: Request validation errors (400)
    if (isFastifyValidationError(error)) {
      return reply.code(400).send({
        code: ERROR_CODES.VALIDATION_ERROR,
        message: ERROR_MESSAGES.VALIDATION_FAILED,
        details: error.validation,
      });
    }

    // Layer 3: Rate limiting errors (429)
    if (isFastifyHttpError(error) && error.statusCode === 429) {
      return reply.code(429).send({
        code: ERROR_CODES.RATE_LIMIT_EXCEEDED,
        message: error.message || "Too many requests, please try again later",
      });
    }

    // Layer 4: Our business logic errors (ApiError)
    if (error instanceof ApiError) {
      return reply.code(error.statusCode).send({
        code: error.code,
        message: error.message,
      });
    }

    // Layer 5: Prisma database errors
    if (error instanceof Prisma.PrismaClientKnownRequestError) {
      if (error.code === "P2025") {
        return reply.code(404).send({
          code: ERROR_CODES.RECORD_NOT_FOUND,
          message: ERROR_MESSAGES.RECORD_NOT_FOUND,
        });
      }
      if (error.code === "P2002") {
        return reply.code(409).send({
          code: ERROR_CODES.DUPLICATE_RECORD,
          message: ERROR_MESSAGES.DUPLICATE_RECORD,
        });
      }
    }

    // Layer 6: Generic schema validation errors (from Fastify)
    if (isFastifyHttpError(error) && error.statusCode === 400) {
      return reply.code(400).send({
        code: ERROR_CODES.BAD_REQUEST,
        message: error.message || "Invalid request format",
      });
    }

    // Layer 7: Catch-all for unknown errors (500)
    request.log.fatal({ err: error }, "Unhandled error in application");
    reply.code(500).send({
      code: ERROR_CODES.INTERNAL_ERROR,
      message: ERROR_MESSAGES.INTERNAL_ERROR,
    });
  },
);

// Production configuration validation
const validateProductionConfig = () => {
  if (process.env.NODE_ENV !== "production") {
    return; // Only validate in production
  }

  const criticalMissingConfigs: string[] = [];

  // JWT Secret validation
  if (config.JWT_SECRET === "default-secret-for-dev" || !config.JWT_SECRET) {
    criticalMissingConfigs.push("JWT_SECRET");
  }

  // WeChat App validation
  if (config.WX_APP_ID === "YOUR_APP_ID" || !config.WX_APP_ID) {
    criticalMissingConfigs.push("WX_APP_ID");
  }
  if (config.WX_APP_SECRET === "YOUR_APP_SECRET" || !config.WX_APP_SECRET) {
    criticalMissingConfigs.push("WX_APP_SECRET");
  }

  // Database URL validation
  if (!process.env.DATABASE_URL) {
    criticalMissingConfigs.push("DATABASE_URL");
  }

  if (criticalMissingConfigs.length > 0) {
    console.error("");
    console.error(
      "ğŸš¨ FATAL ERROR: Critical configuration missing in production environment!",
    );
    console.error("âŒ Missing required environment variables:");
    criticalMissingConfigs.forEach((config) => {
      console.error(`   - ${config}`);
    });
    console.error("");
    console.error(
      "ğŸ“‹ Please set these environment variables and restart the application.",
    );
    console.error(
      "ğŸ›‘ Shutting down to prevent production deployment with insecure configuration.",
    );
    console.error("");
    process.exit(1);
  }

  console.log("âœ… Production configuration validation passed");
};

const setupApplication = async () => {
  // Register all plugins
  await registerPlugins(fastify);

  // Register all routes
  await fastify.register(healthRoutes);
  await fastify.register(authRoutes);
  await fastify.register(booksRoutes);
  await fastify.register(inventoryRoutes);
  await fastify.register(contentRoutes);
  await fastify.register(ordersRoutes);
  await fastify.register(paymentRoutes, { wechatPayAdapter });
};

// Export function to build app for testing
export const buildApp = async () => {
  await setupApplication();
  return fastify;
};

const start = async () => {
  try {
    validateProductionConfig();
    await verifyDatabaseConstraints(prisma);

    await setupApplication();

    await fastify.listen({ port: config.PORT, host: config.HOST });

    // Start cron jobs after server is running
    startCronJobs(fastify);
  } catch (err) {
    fastify.log.error(err);
    process.exit(1);
  }
};

// Only start the server if this file is executed directly (not imported)
if (require.main === module) {
  start();
}


================================================================================
### FILE: bookworm-backend\src\jobs.ts
================================================================================

// src/jobs.ts
import { FastifyInstance } from "fastify";
import * as cron from "node-cron";
import { withAdvisoryLock } from "./utils/dbLock";
import { cancelExpiredOrders } from "./services/orderService";
import { metrics } from "./plugins/metrics";
import { processRefundQueue } from "./jobs/refundProcessor";
import config from "./config";
import prisma from "./db";

export function startCronJobs(fastify: FastifyInstance): void {
  // --- START OF FIX: æ·»åŠ è®¢å•æ¸…ç†å®šæ—¶ä»»åŠ¡ ---

  // æ³¨æ„ï¼š'*/1 * * * *' (æ¯åˆ†é’Ÿæ‰§è¡Œ) é€‚ç”¨äºå¼€å‘å’Œæµ‹è¯•ã€‚
  // åœ¨ç”Ÿäº§ç¯å¢ƒä¸­ï¼Œåº”é€šè¿‡ config.ts é…ç½®ä¸ºæ›´åˆç†çš„é¢‘ç‡ï¼Œä¾‹å¦‚ '*/5 * * * *' (æ¯5åˆ†é’Ÿ)ã€‚
  cron.schedule(config.CRON_ORDER_CLEANUP, async () => {
    await withAdvisoryLock(prisma, "job:cancel_expired_orders", async () => {
      fastify.log.info("Running scheduled job: CancelExpiredOrders");
      try {
        // åœ¨ä¸€ä¸ª try...catch å—ä¸­å®‰å…¨åœ°è°ƒç”¨å®ƒ
        const result = await prisma.$transaction(async (tx) => {
          return cancelExpiredOrders(tx);
        });

        // è®°å½•æœ‰æ„ä¹‰çš„æ—¥å¿—
        if (result.cancelledCount > 0) {
          fastify.log.info(
            `CancelExpiredOrders job finished: ${result.cancelledCount} order(s) cancelled`,
          );
        } else {
          fastify.log.info(
            "CancelExpiredOrders job finished: No expired orders found",
          );
        }
      } catch (error) {
        // æ•è·å¹¶è®°å½•ä»»ä½•æ½œåœ¨çš„é”™è¯¯ï¼Œé˜²æ­¢æå®ä¸»è¿›ç¨‹
        console.error(
          'CRITICAL: The "CancelExpiredOrders" job failed:',
          error,
        );
      }
    });
  });

  // --- END OF FIX ---

  // Schedule a job to update inventory gauge metrics every 5 minutes.
  cron.schedule(config.CRON_INVENTORY_METRICS, async () => {
    await withAdvisoryLock(
      prisma,
      "job:update_inventory_metrics",
      async () => {
        fastify.log.info("Running scheduled job to update inventory metrics");
        try {
          const inventoryCounts = await prisma.inventoryItem.groupBy({
            by: ["status"],
            _count: {
              id: true,
            },
          });
          inventoryCounts.forEach((item) => {
            metrics.inventoryStatus.labels(item.status).set(item._count.id);
          });
        } catch (error) {
          console.error(
            'CRITICAL: The "updateInventoryMetrics" job failed:',
            error,
          );
        }
      },
    );
  });

  // Schedule refund processing job every 10 minutes
  cron.schedule(config.CRON_REFUND_PROCESSOR, async () => {
    await withAdvisoryLock(
      prisma,
      "job:process_refunds",
      async () => {
        fastify.log.info("Running scheduled job to process pending refunds");
        try {
          await processRefundQueue();
        } catch (error) {
          console.error(
            'CRITICAL: The "processRefunds" job failed:',
            error,
          );
        }
      },
    );
  });
}


================================================================================
### FILE: bookworm-backend\src\jobs\cancelExpiredOrders.ts
================================================================================

import { Prisma } from "@prisma/client";
import { cancelExpiredOrders } from "../services/orderService";
import prisma from "../db";

const LOCK_NAMESPACE_JOBS = 100;
const LOCK_JOB_CANCEL_EXPIRED = 1;

async function main() {
  console.log("Starting cancelExpiredOrders job with advisory lock...");

  try {
    const result = await prisma.$transaction(async (tx) => {
      const [lockResult] = await tx.$queryRaw<[{ pg_try_advisory_xact_lock: boolean }]>(
        Prisma.sql`SELECT pg_try_advisory_xact_lock(${LOCK_NAMESPACE_JOBS}, ${LOCK_JOB_CANCEL_EXPIRED})`,
      );

      if (!lockResult.pg_try_advisory_xact_lock) {
        console.log("Another instance is already running the job. Skipping.");
        return null;
      }

      console.log("Lock acquired. Running cancelExpiredOrders job...");
      return await cancelExpiredOrders(tx);
    });

    if (result && result.cancelledCount > 0) {
      console.log(`Job completed successfully. Cancelled ${result.cancelledCount} expired orders.`);
    } else if (result) {
      console.log("Job completed successfully. No expired orders found.");
    }

  } catch (error) {
    console.error("Job failed:", error);
    process.exit(1);
  } finally {
    await prisma.$disconnect();
    process.exit(0);
  }
}

main();


================================================================================
### FILE: bookworm-backend\src\jobs\refundProcessor.ts
================================================================================

// src/jobs/refundProcessor.ts
import db from '../db';
import config from '../config';
import { processPendingRefunds } from '../services/refundService';
import { createWechatPayAdapter } from '../adapters/wechatPayAdapter';
import * as fs from 'fs';
import * as path from 'path';

/**
 * Background job to process pending refunds
 * This job runs periodically to handle refunds for cancelled orders
 */
export async function processRefundQueue(): Promise<void> {
  try {
    console.log('Starting refund processing job...');

    // Skip if WeChat Pay is not configured
    if (!config.WXPAY_MCHID || !config.WXPAY_PRIVATE_KEY_PATH) {
      console.log('WeChat Pay not configured, skipping refund processing');
      return;
    }

    // Initialize WeChat Pay adapter
    let privateKeyBuffer: Buffer;
    try {
      const keyPath = path.resolve(config.WXPAY_PRIVATE_KEY_PATH);
      privateKeyBuffer = fs.readFileSync(keyPath);
    } catch (error) {
      console.error('Failed to read WeChat Pay private key file:', error);
      return;
    }

    const wechatPayAdapter = createWechatPayAdapter({
      appid: config.WX_APP_ID,
      mchid: config.WXPAY_MCHID,
      privateKey: privateKeyBuffer,
      serial_no: config.WXPAY_CERT_SERIAL_NO,
      key: config.WXPAY_API_V3_KEY,
    });

    // Process refunds
    const result = await processPendingRefunds(db, wechatPayAdapter);

    console.log(`Refund processing completed: ` +
      `Processed ${result.processedCount} records, ` +
      `${result.successCount} successful, ` +
      `${result.failureCount} failed`);

    if (result.failureCount > 0) {
      console.warn(`${result.failureCount} refunds failed. Reasons:`, result.failures);
    }

  } catch (error) {
    console.error('Refund processing job failed:', error);
    // Don't re-throw to prevent job scheduler from crashing
  }
}


================================================================================
### FILE: bookworm-backend\src\plugins.ts
================================================================================

// src/plugins.ts
import { FastifyInstance } from "fastify";
import * as path from "path";
import fastifyStatic from "@fastify/static";
import authPlugin from "./plugins/auth";
import metricsPlugin from "./plugins/metrics";
import fastifyRawBody from "fastify-raw-body";
import rateLimit from "@fastify/rate-limit";

export async function registerPlugins(fastify: FastifyInstance): Promise<void> {
  // Register plugins first - MUST be awaited in correct order
  await fastify.register(fastifyStatic, {
    root: path.join(__dirname, "..", "public"),
    prefix: "/admin/",
  });
  await fastify.register(authPlugin);
  await fastify.register(metricsPlugin);
  await fastify.register(fastifyRawBody, {
    field: "rawBody",
    global: false, // åªåœ¨éœ€è¦çš„è·¯ç”±ä¸Šå¯ç”¨
    encoding: "utf8",
    runFirst: true,
  });
  await fastify.register(rateLimit, {
    global: false, // æˆ‘ä»¬æŒ‰è·¯ç”±å•ç‹¬é…ç½®
  });
}


================================================================================
### FILE: bookworm-backend\src\plugins\auth.ts
================================================================================

import fp from 'fastify-plugin';
import { createVerifier } from 'fast-jwt';
import config from '../config';
import { FastifyRequest, FastifyReply } from 'fastify';

export default fp(async (fastify) => {
  const verifier = createVerifier({ key: config.JWT_SECRET });

  fastify.decorate('authenticate', async (req: FastifyRequest, reply: FastifyReply) => {
    try {
      if (!req.headers.authorization) {
        return reply.code(401).send({ code: 'UNAUTHORIZED', message: 'Missing authorization header' });
      }

      const token = req.headers.authorization.replace('Bearer ', '');
      const payload = await verifier(token);
      req.user = {
        userId: payload.userId,
        openid: payload.openid,
        role: payload.role // ä»JWT payloadç›´æ¥è·å–role
      };
    } catch (err: unknown) {
      fastify.log.warn({ err }, 'Authentication failed');
      return reply.code(401).send({ code: 'UNAUTHORIZED', message: 'Invalid token' });
    }
  });

  fastify.decorate('requireRole', (role: 'USER' | 'STAFF') => {
    return async (req: FastifyRequest, reply: FastifyReply) => {
      if (!req.user) return reply.code(401).send({ code: 'UNAUTHORIZED', message: 'Unauthorized' });

      // ä»JWT payloadä¸­ç›´æ¥éªŒè¯è§’è‰²ï¼Œæ— éœ€æŸ¥è¯¢æ•°æ®åº“
      if (!req.user.role || req.user.role !== role) {
        return reply.code(403).send({ code: 'FORBIDDEN', message: 'Forbidden' });
      }

      // Debug logging for tests
      if (process.env.NODE_ENV === 'test') {
        fastify.log.info({
          userId: req.user.userId,
          userRole: req.user.role,
          requiredRole: role,
          source: 'jwt_payload'
        }, 'Role check debug');
      }
    };
  });
}, {
  name: 'auth-plugin',
  fastify: '4.x'
});


================================================================================
### FILE: bookworm-backend\src\plugins\metrics.ts
================================================================================

// src/plugins/metrics.ts
import { FastifyInstance } from "fastify";
import fp from "fastify-plugin";
import client from "prom-client";

// å¯ç”¨é»˜è®¤çš„ Node.js æŒ‡æ ‡ (CPU, memory, etc.)
// åªåœ¨éæµ‹è¯•ç¯å¢ƒä¸­æ”¶é›†é»˜è®¤æŒ‡æ ‡ï¼Œé¿å…é‡å¤æ³¨å†Œé”™è¯¯
if (process.env.NODE_ENV !== 'test') {
  client.collectDefaultMetrics();
}

// --- å®šä¹‰æˆ‘ä»¬çš„æ ¸å¿ƒä¸šåŠ¡æŒ‡æ ‡ ---

// Singleton mock objects for testing - reuse instead of creating new objects
const mockIncrementer = { inc: () => {} };
const mockSetter = { set: () => {} };

// Only create metrics in non-test environments to avoid conflicts
export const metrics = process.env.NODE_ENV !== 'test' ? {
  ordersCreated: new client.Counter({
    name: "bookworm_orders_created_total",
    help: "Total number of orders created",
  }),
  ordersCompleted: new client.Counter({
    name: "bookworm_orders_completed_total",
    help: "Total number of orders successfully fulfilled (picked up)",
  }),
  ordersCancelled: new client.Counter({
    name: "bookworm_orders_cancelled_total",
    help: "Total number of orders cancelled due to expiration",
  }),
  paymentsProcessed: new client.Counter({
    name: "bookworm_payments_processed_total",
    help: "Total number of payment notifications processed",
    labelNames: ["status"], // 'success', 'refund_required', 'failure'
  }),
  dbTransactionRetries: new client.Counter({
    name: "bookworm_db_transaction_retries_total",
    help: "Total number of database transaction retries due to serialization conflicts",
  }),
  inventoryStatus: new client.Gauge({
    name: "bookworm_inventory_items_count",
    help: "Current number of inventory items by status",
    labelNames: ["status"], // 'in_stock', 'reserved', 'sold', etc.
  }),
  usersLoggedInTotal: new client.Gauge({
    name: "bookworm_users_logged_in_total",
    help: "Total number of unique users who have logged in",
  }),
  orderFulfillmentDurationSeconds: new client.Histogram({
    name: "bookworm_order_fulfillment_duration_seconds",
    help: "Histogram of the time taken from payment to fulfillment for an order",
    buckets: [60, 300, 900, 1800, 3600, 7200, 86400], // 1min, 5min, 15min, 30min, 1hr, 2hr, 1day
  }),
} : {
  // Mock metrics for testing - reuse singleton objects
  ordersCreated: { labels: () => mockIncrementer, inc: () => {} },
  ordersCompleted: { labels: () => mockIncrementer, inc: () => {} },
  ordersCancelled: { labels: () => mockIncrementer, inc: () => {} },
  paymentsProcessed: { labels: () => mockIncrementer, inc: () => {} },
  dbTransactionRetries: { labels: () => mockIncrementer, inc: () => {} },
  inventoryStatus: { labels: () => mockSetter },
  usersLoggedInTotal: { set: () => {}, inc: () => {} },
  orderFulfillmentDurationSeconds: { observe: () => {} },
};

async function metricsPlugin(fastify: FastifyInstance) {
  fastify.get("/metrics", async (request, reply) => {
    reply.header("Content-Type", client.register.contentType);
    reply.send(await client.register.metrics());
  });
  console.log("Metrics endpoint registered at /metrics");
}

export default fp(metricsPlugin);


================================================================================
### FILE: bookworm-backend\src\routes\auth.ts
================================================================================

// src/routes/auth.ts
import { FastifyPluginAsync } from "fastify";
import { Type, Static } from "@sinclair/typebox";
import { generateJwtToken, persistWeChatUser, requestWxSession } from "../services/authService";
import config from "../config";
import prisma from "../db";

const LoginBodySchema = Type.Object({
  code: Type.String({ minLength: 1 }),
});

const authRoutes: FastifyPluginAsync = async function (fastify) {
  fastify.post<{ Body: Static<typeof LoginBodySchema> }>(
    "/api/auth/login",
    {
      config: {
        rateLimit: {
          max: config.API_LOGIN_RATE_LIMIT_MAX,
          timeWindow: "1 minute",
        },
      },
      schema: {
        body: LoginBodySchema,
      },
    },
    async (request, reply) => {
      const { code } = request.body;
      const session = await requestWxSession(code);
      const user = await prisma.$transaction((tx) => persistWeChatUser(tx, session));
      const token = generateJwtToken(user);
      reply.send({ token, userId: user.id });
    },
  );
};

export default authRoutes;


================================================================================
### FILE: bookworm-backend\src\routes\books.ts
================================================================================

// src/routes/books.ts
import { FastifyPluginAsync } from "fastify";
import { Type, Static } from "@sinclair/typebox";
import { getBookMetadata } from "../services/bookMetadataService";
import { ApiError } from "../errors";

const BookMetaQuerySchema = Type.Object({
  isbn: Type.String({ minLength: 10, maxLength: 13 }),
});

const booksRoutes: FastifyPluginAsync = async function (fastify) {
  // Books metadata
  fastify.get<{ Querystring: Static<typeof BookMetaQuerySchema> }>(
    "/api/books/meta",
    {
      schema: {
        querystring: BookMetaQuerySchema,
      },
    },
    async (request, reply) => {
      const { isbn } = request.query;

      const metadata = await getBookMetadata(isbn);
      if (!metadata) {
        throw new ApiError(
          404,
          "Book metadata not found.",
          "BOOK_METADATA_NOT_FOUND",
        );
      }

      reply.send(metadata);
    }
  );
};

export default booksRoutes;


================================================================================
### FILE: bookworm-backend\src\routes\content.ts
================================================================================

// src/routes/content.ts
import { FastifyPluginAsync } from "fastify";
import { Type, Static } from "@sinclair/typebox";
import { getContentBySlug } from "../services/contentService";
import prisma from "../db";

const ContentParamsSchema = Type.Object({
  slug: Type.String({ minLength: 1 }),
});

const contentRoutes: FastifyPluginAsync = async function (fastify) {
  // Content Management
  fastify.get<{ Params: Static<typeof ContentParamsSchema> }>(
    "/api/content/:slug",
    {
      schema: {
        params: ContentParamsSchema,
      },
    },
    async (request, reply) => {
      const { slug } = request.params;
      const content = await getContentBySlug(prisma, slug);
      reply.send(content);
    }
  );
};

export default contentRoutes;


================================================================================
### FILE: bookworm-backend\src\routes\health.ts
================================================================================

// src/routes/health.ts
import { FastifyPluginAsync } from "fastify";
import prisma from "../db";

const healthRoutes: FastifyPluginAsync = async function (fastify) {
  // Health Check Endpoint
  fastify.get("/api/health", async (request, reply) => {
    const checks: { [key: string]: string } = {};
    let allHealthy = true;

    // Database connectivity check
    try {
      await prisma.$queryRaw`SELECT 1`;
      checks.database = "ok";
    } catch (error) {
      request.log.error(error, "Database health check failed");
      checks.database = "failed";
      allHealthy = false;
    }

    if (allHealthy) {
      reply.send({
        status: "ok",
        timestamp: new Date().toISOString(),
        checks,
      });
    } else {
      reply.code(503).send({
        status: "error",
        timestamp: new Date().toISOString(),
        checks,
      });
    }
  });
};

export default healthRoutes;


================================================================================
### FILE: bookworm-backend\src\routes\inventory.ts
================================================================================

// src/routes/inventory.ts
import { FastifyPluginAsync } from "fastify";
import { Type, Static } from "@sinclair/typebox";
import {
  getAvailableBooks,
  getBookById,
  persistInventoryItem,
} from "../services/inventoryService";
import { getBookMetadata } from "../services/bookMetadataService";
import { ApiError } from "../errors";
import config from "../config";
import prisma from "../db";

const ListAvailableQuery = Type.Object({
  search: Type.Optional(Type.String({ minLength: 1, maxLength: 50 })),
  page: Type.Optional(Type.Number({ minimum: 1, maximum: 100, default: 1 })),
  limit: Type.Optional(Type.Number({ minimum: 1, maximum: 100, default: 20 })),
});

const GetItemParamsSchema = Type.Object({
  id: Type.Number(),
});

const AddBookBody = Type.Object({
  isbn13: Type.String({ minLength: 10, maxLength: 13 }),
  title: Type.String({ minLength: 1 }),
  author: Type.Optional(Type.String()),
  edition: Type.Optional(Type.String()),
  condition: Type.Union([Type.Literal("NEW"), Type.Literal("GOOD"), Type.Literal("ACCEPTABLE")]),
  cost: Type.Number({ minimum: 0 }),
  selling_price: Type.Number({ minimum: 0 }),
});

const inventoryRoutes: FastifyPluginAsync = async function (fastify) {
  fastify.get<{ Querystring: Static<typeof ListAvailableQuery> }>(
    "/api/inventory/available",
    { schema: { querystring: ListAvailableQuery } },
    async (request, reply) => {
      const { search, page, limit } = request.query;
      const books = await getAvailableBooks(prisma, { searchTerm: search, page, limit });
      reply.send(books);
    }
  );

  fastify.get<{ Params: Static<typeof GetItemParamsSchema> }>(
    "/api/inventory/item/:id",
    {
      schema: {
        params: GetItemParamsSchema,
      },
    },
    async (request, reply) => {
      const id = request.params.id;
      const book = await getBookById(prisma, id);
      if (!book) {
        throw new ApiError(404, "Book not found.", "BOOK_NOT_FOUND");
      }
      reply.send(book);
    },
  );

  fastify.post<{ Body: Static<typeof AddBookBody> }>(
    "/api/inventory/add",
    { preHandler: [fastify.authenticate, fastify.requireRole("STAFF")], schema: { body: AddBookBody } },
    async (request, reply) => {
      let metadata = null;
      try {
        metadata = await getBookMetadata(request.body.isbn13);
      } catch (error) {
        request.log.warn({ err: error }, "è·å–å›¾ä¹¦å…ƒæ•°æ®å¤±è´¥ï¼Œä½¿ç”¨ç”¨æˆ·è¾“å…¥è¡¥å…¨");
      }

      const newItem = await prisma.$transaction((tx) =>
        persistInventoryItem(tx, request.body, metadata),
      );
      reply.code(201).send(newItem);
    },
  );
};

export default inventoryRoutes;


================================================================================
### FILE: bookworm-backend\src\routes\orders.ts
================================================================================

// src/routes/orders.ts
import { FastifyPluginAsync } from "fastify";
import { Type, Static } from "@sinclair/typebox";
import {
  createOrder,
  getOrdersByUserId,
  getOrderById,
  fulfillOrder,
  getPendingPickupOrders,
  updateOrderStatus,
} from "../services/orderService";
import { ApiError } from "../errors";
import config from "../config";
import prisma from "../db";

const CreateOrderBodySchema = Type.Object({
  inventoryItemIds: Type.Array(Type.Number(), { minItems: 1 }),
});

const FulfillOrderBodySchema = Type.Object({
  pickupCode: Type.String({ minLength: 1 }),
});

const UpdateOrderStatusBodySchema = Type.Object({
  status: Type.Union([Type.Literal("COMPLETED"), Type.Literal("CANCELLED")]),
});

const OrderIdParamsSchema = Type.Object({
  id: Type.Number(),
});

const UserIdParamsSchema = Type.Object({
  userId: Type.Number(),
});

const OrderListQuerySchema = Type.Object({
  cursor: Type.Optional(Type.String()),
  limit: Type.Optional(Type.Integer({ minimum: 1, maximum: 50 })),
});

const ordersRoutes: FastifyPluginAsync = async function (fastify) {
  fastify.post<{ Body: Static<typeof CreateOrderBodySchema> }>(
    "/api/orders/create",
    {
      preHandler: [fastify.authenticate],
      config: {
        rateLimit: {
          max: config.API_RATE_LIMIT_MAX,
          timeWindow: `${config.API_RATE_LIMIT_WINDOW_MINUTES} minute`,
          keyGenerator: (req) => req.user?.userId.toString() || req.ip,
        },
      },
      schema: {
        body: CreateOrderBodySchema,
      },
    },
    async (request, reply) => {
      const { inventoryItemIds } = request.body;
      const order = await createOrder(prisma, {
        userId: request.user!.userId,
        inventoryItemIds,
      });
      reply.code(201).send(order);
    },
  );

  fastify.get<{ Params: Static<typeof OrderIdParamsSchema> }>(
    "/api/orders/:id",
    {
      preHandler: [fastify.authenticate],
      schema: {
        params: OrderIdParamsSchema,
      },
    },
    async (request, reply) => {
      const orderId = request.params.id;

      const order = await getOrderById(prisma, orderId, request.user!.userId);
      reply.send(order);
    },
  );

  fastify.get<{
    Params: Static<typeof UserIdParamsSchema>;
    Querystring: Static<typeof OrderListQuerySchema>;
  }>(
    "/api/orders/user/:userId",
    {
      preHandler: [fastify.authenticate],
      schema: {
        params: UserIdParamsSchema,
        querystring: OrderListQuerySchema,
      },
    },
    async (request, reply) => {
      if (request.params.userId !== request.user!.userId) {
        throw new ApiError(403, "Forbidden", "USER_ACCESS_DENIED");
      }
      const { cursor, limit } = request.query;

      const orders = await getOrdersByUserId(prisma, request.user!.userId, {
        cursor: cursor ?? undefined,
        limit: limit ?? undefined,
      });
      reply.send({
        data: orders.data,
        meta: {
          nextCursor: orders.nextCursor,
        },
      });
    },
  );

  fastify.post<{ Body: Static<typeof FulfillOrderBodySchema> }>(
    "/api/orders/fulfill",
    {
      preHandler: [fastify.authenticate, fastify.requireRole("STAFF")],
      config: {
        rateLimit: {
          max: config.API_FULFILL_RATE_LIMIT_MAX,
          timeWindow: "1 minute",
          keyGenerator: (req) => req.user?.userId.toString() || req.ip,
        },
      },
      schema: {
        body: FulfillOrderBodySchema,
      },
    },
    async (request, reply) => {
      const { pickupCode } = request.body;
      const order = await fulfillOrder(prisma, pickupCode.toUpperCase());
      reply.send(order);
    },
  );

  fastify.get(
    "/api/orders/pending-pickup",
    { preHandler: [fastify.authenticate, fastify.requireRole("STAFF")] },
    async (request, reply) => {
      const orders = await getPendingPickupOrders(prisma);
      reply.send(orders);
    },
  );

  // Update order status (STAFF only)
  fastify.patch<{
    Params: Static<typeof OrderIdParamsSchema>;
    Body: Static<typeof UpdateOrderStatusBodySchema>;
  }>(
    "/api/orders/:id/status",
    {
      preHandler: [fastify.authenticate, fastify.requireRole("STAFF")],
      config: {
        rateLimit: {
          max: config.API_RATE_LIMIT_MAX,
          timeWindow: `${config.API_RATE_LIMIT_WINDOW_MINUTES} minute`,
        },
      },
      schema: {
        params: OrderIdParamsSchema,
        body: UpdateOrderStatusBodySchema,
      },
    },
    async (request, reply) => {
      const orderId = request.params.id;
      const { status } = request.body;

      const updatedOrder = await updateOrderStatus(prisma, orderId, status, {
        userId: request.user!.userId,
        role: request.user!.role!,
      });
      reply.send(updatedOrder);
    },
  );
};

export default ordersRoutes;


================================================================================
### FILE: bookworm-backend\src\routes\payment.ts
================================================================================

// bookworm-backend/src/routes/payment.ts
import { FastifyPluginAsync, FastifyRequest } from "fastify";
import { Type, Static } from "@sinclair/typebox";
import { WechatPayAdapter } from "../adapters/wechatPayAdapter";
import {
  buildClientPaymentSignature,
  buildWechatPaymentRequest,
  preparePaymentIntent,
  processPaymentNotification,
} from "../services/orderService";
import { ApiError, PaymentQueryError } from "../errors";
import config from "../config";
import prisma from "../db";
import { WECHAT_CONSTANTS } from "../constants";

interface PaymentRoutesOptions {
  wechatPayAdapter: WechatPayAdapter | null;
}

const OrderIdParamsSchema = Type.Object({
  orderId: Type.Number(),
});

const PaymentNotifySchema = Type.Object({
  headers: Type.Object({
    'wechatpay-timestamp': Type.String({ minLength: 1 }),
    'wechatpay-nonce': Type.String({ minLength: 1 }),
    'wechatpay-signature': Type.String({ minLength: 1 }),
    'wechatpay-serial': Type.String({ minLength: 1 }),
  }),
  body: Type.Object({
    resource: Type.Object({
      ciphertext: Type.String(),
      associated_data: Type.String(),
      nonce: Type.String(),
    }),
  }),
});


const paymentRoutes: FastifyPluginAsync<PaymentRoutesOptions> = async function (fastify, opts) {
  const { wechatPayAdapter } = opts;

  // ... (the /api/orders/:orderId/pay route remains the same, no need to change it)
  fastify.post<{ Params: Static<typeof OrderIdParamsSchema> }>(
    "/api/orders/:orderId/pay",
    {
      preHandler: [fastify.authenticate],
      schema: {
        params: OrderIdParamsSchema,
      },
    },
    async (request, reply) => {
      if (!wechatPayAdapter) throw new ApiError(503, "Payment service is not configured.", "PAYMENT_SERVICE_UNAVAILABLE");
      const { orderId } = request.params;
      const intent = await preparePaymentIntent(prisma, orderId, request.user!.userId);
      const { prepay_id } = await wechatPayAdapter.createPaymentOrder(
        buildWechatPaymentRequest(intent),
      );
      const paymentParams = buildClientPaymentSignature(intent, prepay_id, wechatPayAdapter);
      reply.send(paymentParams);
    },
  );

  // Payment callback - COMPLETELY REWRITTEN
  fastify.post<{ Headers: Static<typeof PaymentNotifySchema>['headers']; Body: Static<typeof PaymentNotifySchema>['body'] }>(
    "/api/payment/notify",
    {
      config: { rawBody: true },
      schema: {
        headers: PaymentNotifySchema.properties.headers,
        body: PaymentNotifySchema.properties.body,
      },
    },
    async (request, reply) => {
    if (!wechatPayAdapter) {
      request.log.error("WeChat Pay adapter is not configured. Cannot process notification.");
      // Return 503 to signal a temporary failure, prompting WeChat to retry.
      return reply.code(503).send({ code: "FAIL", message: "æœåŠ¡æš‚æ—¶ä¸å¯ç”¨" });
    }

    try {
      // 1. Extract validated headers (TypeBox has already validated them)
      const {
        'wechatpay-timestamp': timestamp,
        'wechatpay-nonce': nonce,
        'wechatpay-signature': signature,
        'wechatpay-serial': serial,
      } = request.headers;

      const rawBody = request.rawBody;
      if (!rawBody) {
        throw new ApiError(400, "Missing raw body for payment notification", "MISSING_BODY");
      }

      // 2. Decrypt notification and pass to service layer
      // TypeBox has already validated that body contains a resource object
      const resource = request.body.resource;
      let notificationData;
      try {
        const decryptedDataStr = wechatPayAdapter.decryptNotificationData({
          ciphertext: resource.ciphertext,
          associated_data: resource.associated_data,
          nonce: resource.nonce,
          apiv3Key: config.WXPAY_API_V3_KEY,
        });
        notificationData = JSON.parse(decryptedDataStr);
      } catch (decryptError) {
        request.log.warn({ err: decryptError, resource }, "Payment notification decryption failed. This is a permanent error for this request.");
        // Return 200 OK to acknowledge receipt and prevent WeChat from retrying a malformed request.
        return reply.code(200).send({ code: WECHAT_CONSTANTS.SUCCESS_CODE, message: WECHAT_CONSTANTS.SUCCESS_MESSAGE });
      }

      // 3. Hand off to the robust service layer function with security context
      await processPaymentNotification(prisma, wechatPayAdapter, {
        ...notificationData,
        timestamp,
        nonce,
        signature,
        serial,
        body: rawBody.toString(),
      });

      // 4. Signal success to WeChat
      reply.code(200).send({ code: WECHAT_CONSTANTS.SUCCESS_CODE, message: WECHAT_CONSTANTS.SUCCESS_MESSAGE });

    } catch (error) {
      request.log.error({ err: error }, "Payment notification processing failed.");

      // Specific handling for transient errors where we want WeChat to retry
      if (error instanceof ApiError && error.code === 'PAY_TRANSIENT_STATE') {
        return reply.code(503).send({ code: WECHAT_CONSTANTS.FAIL_CODE, message: WECHAT_CONSTANTS.RETRY_MESSAGE });
      }
      if (error instanceof PaymentQueryError && error.code === 'WECHAT_QUERY_FAILED_TRANSIENT') {
        return reply.code(503).send({ code: WECHAT_CONSTANTS.FAIL_CODE, message: WECHAT_CONSTANTS.RETRY_MESSAGE });
      }

      // For all other errors (e.g., bad signature, permanent API errors), we tell WeChat we're "done" to prevent endless retries.
      reply.code(200).send({ code: WECHAT_CONSTANTS.SUCCESS_CODE, message: WECHAT_CONSTANTS.SUCCESS_MESSAGE });
    }
  });
};

export default paymentRoutes;


================================================================================
### FILE: bookworm-backend\src\services\authService.ts
================================================================================

// src/services/authService.ts
import axios from "axios";
import { createSigner } from "fast-jwt";
import { PrismaClient, Prisma } from "@prisma/client";
import config from "../config";
import { metrics } from "../plugins/metrics";
import { WECHAT_CONSTANTS } from "../constants";

type DbCtx = PrismaClient | Prisma.TransactionClient;

interface WxSession {
  openid: string;
  unionid?: string;
}

// Helper functions for user management - each with single responsibility

async function findUserByUnionId(dbCtx: DbCtx, unionid: string) {
  return await dbCtx.user.findUnique({ where: { unionid } });
}

async function findUserByOpenId(dbCtx: DbCtx, openid: string) {
  return await dbCtx.user.findUnique({ where: { openid } });
}

async function updateUserOpenId(dbCtx: DbCtx, userId: number, openid: string) {
  return await dbCtx.user.update({
    where: { id: userId },
    data: { openid },
  });
}

async function updateUserUnionId(dbCtx: DbCtx, userId: number, unionid: string) {
  return await dbCtx.user.update({
    where: { id: userId },
    data: { unionid },
  });
}

async function createUser(dbCtx: DbCtx, openid: string, unionid?: string) {
  const user = await dbCtx.user.create({
    data: { openid, unionid },
  });

  metrics.usersLoggedInTotal.inc();

  return user;
}

async function ensureUserWithUnionId(dbCtx: DbCtx, openid: string, unionid: string) {
  // Try to find by unionid first (most reliable identifier)
  const userByUnionId = await findUserByUnionId(dbCtx, unionid);
  if (userByUnionId) {
    // Update openid if it changed
    if (userByUnionId.openid !== openid) {
      return await updateUserOpenId(dbCtx, userByUnionId.id, openid);
    }
    return userByUnionId;
  }

  // No user with this unionid, try to find by openid
  const userByOpenId = await findUserByOpenId(dbCtx, openid);
  if (userByOpenId) {
    // Update existing user with unionid
    return await updateUserUnionId(dbCtx, userByOpenId.id, unionid);
  }

  // No existing user, create new one
  return await createUser(dbCtx, openid, unionid);
}

async function ensureUserWithOpenIdOnly(dbCtx: DbCtx, openid: string) {
  const existingUser = await findUserByOpenId(dbCtx, openid);
  if (existingUser) {
    return existingUser;
  }

  // No existing user, create new one
  return await createUser(dbCtx, openid);
}

export function generateJwtToken(user: { id: number; openid: string; role: string }) {
  const signer = createSigner({
    key: config.JWT_SECRET,
    expiresIn: config.JWT_EXPIRES_IN,
  });

  return signer({
    userId: user.id,
    openid: user.openid,
    role: user.role // å°†è§’è‰²åŒ…å«åœ¨JWTä¸­ï¼Œé¿å…æ¯æ¬¡è¯·æ±‚æŸ¥æ•°æ®åº“
  });
}

export async function requestWxSession(code: string): Promise<WxSession> {
  const url = `${WECHAT_CONSTANTS.JSCODE2SESSION_URL}?appid=${config.WX_APP_ID}&secret=${config.WX_APP_SECRET}&js_code=${code}&grant_type=${WECHAT_CONSTANTS.GRANT_TYPE}`;
  const { data } = await axios.get(url);

  if (data.errcode) {
    throw new Error(`WeChat API Error: ${data.errmsg}`);
  }

  return data as WxSession;
}

export async function persistWeChatUser(dbCtx: DbCtx, { openid, unionid }: WxSession) {
  return unionid
    ? ensureUserWithUnionId(dbCtx, openid, unionid)
    : ensureUserWithOpenIdOnly(dbCtx, openid);
}

export async function wxLogin(prisma: PrismaClient, code: string) {
  const session = await requestWxSession(code);

  const user = await prisma.$transaction(async (tx) => {
    return persistWeChatUser(tx, session);
  });

  const token = await generateJwtToken(user);

  return { token, user };
}


================================================================================
### FILE: bookworm-backend\src\services\bookMetadataService.ts
================================================================================

// bookworm-backend/src/services/bookMetadataService.ts
import axios from "axios";

import config from "../config";
import { ApiError } from "../errors";
import { API_CONSTANTS, DEFAULT_VALUES } from "../constants";

interface TanshuBookData {
  title: string;
  img: string;
  author: string;
  isbn: string;
  publisher: string;
  pubdate: string;
  price: string;
  summary: string;
  // ... other fields from Tanshu API
}

interface TanshuApiResponse {
  code: number;
  msg: string;
  data: TanshuBookData;
}

interface BookMetadata {
  isbn13: string;
  title: string;
  author: string;
  publisher: string;
  summary: string;
  original_price: number;
  cover_image_url: string;
}

/**
 * Fetches book metadata from Tanshu API using ISBN.
 * @param isbn The ISBN-13 of the book.
 * @returns Parsed metadata or null if not found or service unavailable.
 * @throws ApiError with code METADATA_SERVICE_UNAVAILABLE on network errors.
 */
export async function getBookMetadata(
  isbn: string,
): Promise<BookMetadata | null> {
  if (!config.TANSHU_API_KEY) {
    console.warn(
      "!!! WARNING: TANSHU_API_KEY is not configured in .env. Book metadata feature is disabled.",
    );
    return null;
  }

  const url = `${API_CONSTANTS.TANSHU_BASE_URL}?key=${config.TANSHU_API_KEY}&isbn=${isbn}`;

  try {
    const response = await axios.get<TanshuApiResponse>(url, {
      validateStatus: () => true, // æ¥å—æ‰€æœ‰çŠ¶æ€ç ï¼Œè‡ªå·±å¤„ç†
    });

    if (response.status !== 200 || response.data.code !== 1) {
      console.error(
        `Tanshu API Error for ISBN ${isbn}: Status ${response.status}, code: ${response.data.code}, msg: ${response.data.msg}`,
      );
      return null;
    }

    const data = response.data.data;

    let priceValue = 0;
    if (data.price) {
      try {
        const priceMatch = data.price.match(/(\d+\.?\d*)/);
        if (priceMatch) {
          priceValue = parseFloat(priceMatch[1]);
        }
      } catch (error) {
        console.warn(`Could not parse price for ${data.title}: ${data.price}`, error);
      }
    }

    return {
      isbn13: data.isbn,
      title: data.title || DEFAULT_VALUES.UNKNOWN_TITLE,
      author: data.author || DEFAULT_VALUES.UNKNOWN_AUTHOR,
      publisher: data.publisher || DEFAULT_VALUES.UNKNOWN_PUBLISHER,
      summary: data.summary || DEFAULT_VALUES.NO_SUMMARY,
      original_price: priceValue,
      cover_image_url: data.img || "",
    };
  } catch (error) {
    const errorMessage = (error as Error).message;
    console.error(
      `Network error calling Tanshu API for ISBN ${isbn}:`,
      errorMessage,
    );
    throw new ApiError(
      503,
      `Metadata service unavailable: ${errorMessage}`,
      "METADATA_SERVICE_UNAVAILABLE"
    );
  }
}


================================================================================
### FILE: bookworm-backend\src\services\contentService.ts
================================================================================

// src/services/contentService.ts
import { PrismaClient } from "@prisma/client";
import { Prisma } from "@prisma/client";

export async function getContentBySlug(dbCtx: PrismaClient | Prisma.TransactionClient, slug: string) {
  return await dbCtx.content.findUniqueOrThrow({
    where: { slug },
  });
}


================================================================================
### FILE: bookworm-backend\src\services\inventoryService.ts
================================================================================

// src/services/inventoryService.ts (fully replaced)
import { Prisma, PrismaClient, book_condition } from "@prisma/client";
import { getBookMetadata } from "./bookMetadataService";
import { DEFAULT_VALUES, INVENTORY_STATUS } from "../constants";

type DbCtx = PrismaClient | Prisma.TransactionClient;
type BookMetadata = Awaited<ReturnType<typeof getBookMetadata>>;

interface AddBookInput {
  isbn13: string;
  title: string;
  author?: string;
  edition?: string;
  condition: book_condition;
  cost: number;
  selling_price: number;
}

export async function persistInventoryItem(dbCtx: DbCtx, input: AddBookInput, metadata: BookMetadata | null) {
  const bookMaster = await dbCtx.bookMaster.upsert({
    where: { isbn13: input.isbn13 },
    update: {
      ...(metadata && {
        title: metadata.title,
        author: metadata.author,
        publisher: metadata.publisher,
        original_price: metadata.original_price,
      }),
    },
    create: {
      isbn13: input.isbn13,
      title: metadata?.title || input.title,
      author: metadata?.author || input.author,
      publisher: metadata?.publisher,
      original_price: metadata?.original_price,
    },
  });

  const bookSku = await dbCtx.bookSku.upsert({
    where: {
      master_id_edition: {
        master_id: bookMaster.id,
        edition: input.edition || DEFAULT_VALUES.EDITION,
      },
    },
    update: {
      ...(metadata && {
        cover_image_url: metadata.cover_image_url,
      }),
    },
    create: {
      master_id: bookMaster.id,
      edition: input.edition || DEFAULT_VALUES.EDITION,
      cover_image_url: metadata?.cover_image_url,
    },
  });

  return dbCtx.inventoryItem.create({
    data: {
      sku_id: bookSku.id,
      condition: input.condition,
      cost: input.cost,
      selling_price: input.selling_price,
      status: INVENTORY_STATUS.IN_STOCK,
    },
  });
}

export async function addBookToInventory(prisma: PrismaClient, input: AddBookInput, metadata?: BookMetadata | null) {
  let resolvedMetadata: BookMetadata | null = null;
  if (metadata !== undefined) {
    resolvedMetadata = metadata;
  } else {
    resolvedMetadata = await getBookMetadata(input.isbn13).catch(() => null);
  }

  return prisma.$transaction((tx) => persistInventoryItem(tx, input, resolvedMetadata));
}

// FIXED: getAvailableBooks using Prisma.sql template tags for safe parameterization
export async function getAvailableBooks(
  prisma: PrismaClient,
  options: { searchTerm?: string; page?: number; limit?: number } = {},
) {
  const { searchTerm, page = 1, limit = 20 } = options;
  const skip = (page - 1) * limit;

  // --- Base query parts, safe from injection ---
  const selectClause = Prisma.sql`
    SELECT
      i.id, i.condition, i.selling_price, i.status,
      json_build_object(
        'id', s.id,
        'edition', s.edition,
        'cover_image_url', s.cover_image_url,
        'bookmaster', json_build_object(
          'id', m.id,
          'isbn13', m.isbn13,
          'title', m.title,
          'author', m.author,
          'publisher', m.publisher,
          'original_price', m.original_price
        )
      ) as booksku
    FROM "inventoryitem" i
    JOIN "booksku" s ON i.sku_id = s.id
    JOIN "bookmaster" m ON s.master_id = m.id
  `;
  const fromAndJoinClause = Prisma.sql`
    FROM "inventoryitem" i
    JOIN "booksku" s ON i.sku_id = s.id
    JOIN "bookmaster" m ON s.master_id = m.id
  `;

  // --- Dynamic WHERE and ORDER BY clauses ---
  const whereConditions: Prisma.Sql[] = [Prisma.sql`i.status = 'in_stock'`];
  let orderByClause = Prisma.sql`ORDER BY i.created_at DESC`;

  if (searchTerm && searchTerm.trim()) {
    const trimmedSearchTerm = searchTerm.trim();
    // Prisma.sql automatically handles parameterization
    whereConditions.push(Prisma.sql`(m.title ILIKE ${'%' + trimmedSearchTerm + '%'} OR m.author ILIKE ${'%' + trimmedSearchTerm + '%'})`);
    orderByClause = Prisma.sql`ORDER BY i.created_at DESC`;
  }

  const whereClause = Prisma.join(whereConditions, ' AND ');

  // --- Build and execute the queries ---
  const countQuery = Prisma.sql`SELECT COUNT(i.id) as "count" ${fromAndJoinClause} WHERE ${whereClause}`;
  const dataQuery = Prisma.sql`${selectClause} WHERE ${whereClause} ${orderByClause} LIMIT ${limit} OFFSET ${skip}`;

  const [totalResult, items] = await Promise.all([
    prisma.$queryRaw<{ count: bigint }[]>(countQuery),
    prisma.$queryRaw<any[]>(dataQuery),
  ]);

  const totalItems = (totalResult && totalResult.length > 0) ? Number(totalResult[0].count) : 0;

  return {
    data: items || [],
    meta: {
      totalItems,
      totalPages: Math.ceil(totalItems / limit),
      currentPage: page,
      itemsPerPage: limit,
    },
  };
}

// NEW: Function to get a single book by its inventory item ID
export async function getBookById(prisma: PrismaClient | Prisma.TransactionClient, id: number) {
  return prisma.inventoryItem.findUnique({
    where: { id },
    select: {
      id: true,
      condition: true,
      selling_price: true,
      status: true,
      bookSku: {
        select: {
          id: true,
          edition: true,
          cover_image_url: true,
          bookMaster: {
            select: {
              id: true,
              isbn13: true,
              title: true,
              author: true,
              publisher: true,
              original_price: true,
            },
          },
        },
      },
    },
  });
}


================================================================================
### FILE: bookworm-backend\src\services\orderService.ts
================================================================================

// src/services/orderService.ts (fully replaced)
import { Prisma, PrismaClient } from "@prisma/client";

import { WechatPayAdapter } from "../adapters/wechatPayAdapter";

import * as crypto from "crypto";
import config from "../config";
import { ApiError, WechatPayError, PaymentQueryError } from "../errors";
import { metrics } from "../plugins/metrics";
import { retryAsync } from "../utils/retry";
import {
  isPrismaSerializationError,
  isPrismaKnownError,
  isPickupCodeConstraintError
} from "../utils/typeGuards";
import {
  ORDER_STATUS,
  INVENTORY_STATUS,
  ERROR_CODES,
  ERROR_MESSAGES,
  DEFAULT_VALUES,
  BUSINESS_LIMITS,
  WECHAT_CONSTANTS
} from "../constants";

// é€šç”¨çš„äº‹åŠ¡é‡è¯•è¾…åŠ©å‡½æ•°
async function withTxRetry<T>(fn: () => Promise<T>): Promise<T> {
  for (let i = 0; i < config.DB_TRANSACTION_RETRY_COUNT; i++) {
    try {
      return await fn();
    } catch (e: unknown) {
      // æ£€æŸ¥æ˜¯å¦ä¸º Prisma çš„åºåˆ—åŒ–å¤±è´¥
      if (isPrismaSerializationError(e)) {
        if (i < config.DB_TRANSACTION_RETRY_COUNT - 1) {
          // Only increment on actual retries, not the final failure
          metrics.dbTransactionRetries.inc();
        }
        // æŒ‡æ•°é€€é¿+æŠ–åŠ¨ç­‰å¾…
        await new Promise((r) =>
          setTimeout(
            r,
            config.DB_TRANSACTION_RETRY_BASE_DELAY_MS * Math.pow(2, i) +
              Math.random() * config.DB_TRANSACTION_RETRY_JITTER_MS,
          ),
        );
        continue;
      }
      // éå¯é‡è¯•é”™è¯¯ï¼Œç«‹å³æŠ›å‡º
      throw e;
    }
  }
  // é‡è¯•åä»å¤±è´¥
  throw new ApiError(409, "ç³»ç»Ÿç¹å¿™ï¼Œè¯·ç¨åé‡è¯•", "TX_RETRY_EXCEEDED");
}

// Helper functions for createOrderImpl - each with single responsibility

async function validateOrderInput(input: { userId: number; inventoryItemIds: number[] }) {
  const itemIds = Array.from(new Set(input.inventoryItemIds));
  if (itemIds.length === 0) {
    throw new ApiError(400, "æ²¡æœ‰é€‰æ‹©ä»»ä½•ä¹¦ç±", "EMPTY_ITEMS");
  }
  if (itemIds.length > config.MAX_ITEMS_PER_ORDER) {
    throw new ApiError(400, `å•ç¬”è®¢å•æœ€å¤š ${config.MAX_ITEMS_PER_ORDER} ä»¶`, "ORDER_SIZE_EXCEEDED");
  }
  return itemIds;
}

async function acquireOrderLocks(tx: Prisma.TransactionClient, userId: number, itemIds: number[]) {
  // Step 1: User-level lock first (consistent ordering to prevent deadlocks)
  await tx.$executeRawUnsafe(
    'SELECT pg_advisory_xact_lock($1::int4, $2::int4)',
    1,
    userId,
  );

  // Step 2: Acquire item-level advisory locks to prevent concurrent reservation
  // This prevents race conditions when multiple users try to purchase the same book
  // Lock items in sorted order to prevent deadlocks
  const sortedItemIds = [...itemIds].sort((a, b) => a - b);
  for (const itemId of sortedItemIds) {
    await tx.$executeRawUnsafe(
      'SELECT pg_advisory_xact_lock($1::int4, $2::int4)',
      2,
      itemId,
    );
  }
}

async function validateInventoryAndReservations(tx: Prisma.TransactionClient, userId: number, itemIds: number[]) {
  // Check for total reserved items (now safe from race conditions)
  const existingReservedItems = await tx.order.findMany({
    where: { user_id: userId, status: "PENDING_PAYMENT" },
    include: { _count: { select: { orderItem: true } } },
  });
  const totalReservedCount = existingReservedItems.reduce(
    (sum, order) => sum + order._count.orderItem, 0,
  );
  if (totalReservedCount + itemIds.length > config.MAX_RESERVED_ITEMS_PER_USER) {
    throw new ApiError(403, `æ‚¨é¢„ç•™çš„å•†å“æ€»æ•°å·²è¾¾ä¸Šé™(${config.MAX_RESERVED_ITEMS_PER_USER}ä»¶)ï¼Œè¯·å…ˆå®Œæˆæˆ–å–æ¶ˆéƒ¨åˆ†è®¢å•`, "MAX_RESERVED_ITEMS_EXCEEDED");
  }

  // Verify items are still available (with locks held)
  const itemsToReserve = await tx.inventoryItem.findMany({
    where: { id: { in: itemIds }, status: INVENTORY_STATUS.IN_STOCK },
  });

  if (itemsToReserve.length !== itemIds.length) {
    throw new ApiError(409, "éƒ¨åˆ†ä¹¦ç±å·²ä¸å¯ç”¨ï¼Œè¯·åˆ·æ–°åé‡è¯•", "INSUFFICIENT_INVENTORY_PRECHECK");
  }

  const totalAmount = itemsToReserve.reduce(
    (sum, item) => sum.add(item.selling_price), new Prisma.Decimal(0),
  );

  return { itemsToReserve, totalAmount };
}

async function generateUniquePickupCode() {
  return crypto
    .randomBytes(config.ORDER_PICKUP_CODE_BYTES)
    .toString("hex")
    .toUpperCase()
    .substring(0, config.ORDER_PICKUP_CODE_LENGTH);
}

async function createOrderRecord(tx: Prisma.TransactionClient, userId: number, totalAmount: Prisma.Decimal) {
  // Create order with pickup_code retry logic
  for (let attempt = 0; attempt < config.PICKUP_CODE_RETRY_COUNT; attempt++) {
    const pickup_code = await generateUniquePickupCode();

    try {
      return await tx.order.create({
        data: {
          user_id: userId,
          status: "PENDING_PAYMENT",
          total_amount: totalAmount,
          pickup_code,
          paymentExpiresAt: new Date(
            Date.now() + config.ORDER_PAYMENT_TTL_MINUTES * 60 * 1000,
          ),
        },
      });
    } catch (e: unknown) {
      if (isPickupCodeConstraintError(e)) {
        continue;
      }
      throw e;
    }
  }

  throw new ApiError(500, "æ— æ³•ç”Ÿæˆå”¯ä¸€è®¢å•å–è´§ç ", "PICKUP_CODE_GEN_FAILED");
}

async function reserveInventoryItems(
  tx: Prisma.TransactionClient,
  orderId: number,
  itemIds: number[],
) {
  const updateResult = await tx.inventoryItem.updateMany({
    where: { id: { in: itemIds }, status: INVENTORY_STATUS.IN_STOCK },
    data: { status: INVENTORY_STATUS.RESERVED },
  });

  if (updateResult.count !== itemIds.length) {
    throw new ApiError(409, "éƒ¨åˆ†ä¹¦ç±å·²ç»è¢«å…¶ä»–è®¢å•é”å®šï¼Œè¯·åˆ·æ–°åé‡è¯•", "INVENTORY_RACE_CONDITION");
  }

  await tx.inventoryReservation.createMany({
    data: itemIds.map((itemId) => ({
      inventory_item_id: itemId,
      order_id: orderId,
    })),
    skipDuplicates: true,
  });
}

async function createOrderItems(
  tx: Prisma.TransactionClient,
  orderId: number,
  items: Array<{ id: number; selling_price: Prisma.Decimal }>,
) {
  await tx.orderItem.createMany({
    data: items.map((item) => ({
      order_id: orderId,
      inventory_item_id: item.id,
      price: item.selling_price,
    })),
  });
}

async function createOrderImpl(tx: Prisma.TransactionClient, input: {
  userId: number;
  inventoryItemIds: number[];
}) {
  // Step 1: Validate input and normalize item IDs
  const itemIds = await validateOrderInput(input);

  // Step 2: Acquire all necessary locks
  await acquireOrderLocks(tx, input.userId, itemIds);

  // Step 3: Validate inventory availability and user reservations
  const { itemsToReserve, totalAmount } = await validateInventoryAndReservations(tx, input.userId, itemIds);

  // Step 4: Create order record with unique pickup code
  const order = await createOrderRecord(tx, input.userId, totalAmount);

  // Step 5: Reserve inventory and create order items
  await reserveInventoryItems(tx, order.id, itemIds);
  await createOrderItems(tx, order.id, itemsToReserve);

  // Step 6: Update metrics and return
  metrics.ordersCreated.inc();
  return order;
}

export async function createOrder(dbCtx: PrismaClient | Prisma.TransactionClient, input: {
  userId: number;
  inventoryItemIds: number[];
}) {
  try {
    // Check if dbCtx is PrismaClient by checking for $connect method (TransactionClient doesn't have this)
    if ('$connect' in dbCtx) {
      // dbCtx is PrismaClient, create a new transaction with retry logic
      return await withTxRetry(async () => {
        return await (dbCtx as PrismaClient).$transaction(async (tx) => {
          return createOrderImpl(tx, input);
        }, {
          timeout: 15000
        });
      });
    } else {
      // dbCtx is already a TransactionClient, use it directly
      return await createOrderImpl(dbCtx as Prisma.TransactionClient, input);
    }
  } catch (e: unknown) {
    if (e instanceof Prisma.PrismaClientKnownRequestError) {
      if (e.code === "P2002") {
        throw new ApiError(409, "æ‚¨æœ‰ä¸€ä¸ªæ­£åœ¨ä»˜æ¬¾çš„è®¢å•ï¼Œè¯·å…ˆå®Œæˆä»˜æ¬¾æˆ–ç­‰å¾…è®¢å•è¿‡æœŸ", "CONCURRENT_PENDING_ORDER");
      }
      if (e.code === "P2010" && typeof e.meta?.message === "string" && e.meta.message.includes("MAX_RESERVED_ITEMS_PER_USER")) {
        throw new ApiError(403, `æ‚¨é¢„ç•™çš„å•†å“æ€»æ•°å·²è¾¾ä¸Šé™(${config.MAX_RESERVED_ITEMS_PER_USER}ä»¶)ï¼Œè¯·å…ˆå®Œæˆæˆ–å–æ¶ˆéƒ¨åˆ†è®¢å•`, "MAX_RESERVED_ITEMS_EXCEEDED");
      }
      if (typeof e.message === "string" && e.message.includes("MAX_RESERVED_ITEMS_PER_USER")) {
        throw new ApiError(403, `æ‚¨é¢„ç•™çš„å•†å“æ€»æ•°å·²è¾¾ä¸Šé™(${config.MAX_RESERVED_ITEMS_PER_USER}ä»¶)ï¼Œè¯·å…ˆå®Œæˆæˆ–å–æ¶ˆéƒ¨åˆ†è®¢å•`, "MAX_RESERVED_ITEMS_EXCEEDED");
      }
    }
    throw e;
  }
}

export async function getOrdersByUserId(
  dbCtx: PrismaClient | Prisma.TransactionClient,
  userId: number,
  options: { limit?: number; cursor?: string } = {},
) {
  const { limit = 10, cursor } = options;
  const rawLimit = typeof limit === "number" ? limit : Number(limit);
  const parsedLimit = Number.isFinite(rawLimit) ? Math.floor(rawLimit) : 10;
  const normalizedLimit = Math.max(1, Math.min(parsedLimit, 50));

  let cursorDate: Date | null = null;
  let cursorId: number | null = null;

  if (cursor) {
    const [cursorDatePart, cursorIdPart] = cursor.split("_");
    if (cursorDatePart && cursorIdPart) {
      const parsedDate = new Date(cursorDatePart);
      const parsedId = Number(cursorIdPart);

      if (!Number.isNaN(parsedDate.getTime()) && Number.isInteger(parsedId) && parsedId > 0) {
        cursorDate = parsedDate;
        cursorId = parsedId;
      }
    }
  }

  const where: Prisma.OrderWhereInput = {
    user_id: userId,
  };

  if (cursorDate && cursorId !== null) {
    where.OR = [
      { createdAt: { lt: cursorDate } },
      {
        createdAt: cursorDate,
        id: { lt: cursorId },
      },
    ];
  }

  const orders = await dbCtx.order.findMany({
    where,
    select: {
      id: true,
      user_id: true,
      status: true,
      total_amount: true,
      pickup_code: true,
      paymentExpiresAt: true,
      paid_at: true,
      cancelled_at: true,
      createdAt: true,
      orderItem: {
        select: {
          id: true,
          order_id: true,
          inventory_item_id: true,
          inventoryItem: {
            select: {
              id: true,
              condition: true,
              selling_price: true,
              bookSku: {
                select: {
                  id: true,
                  edition: true,
                  cover_image_url: true,
                  bookMaster: {
                    select: {
                      id: true,
                      isbn13: true,
                      title: true,
                      author: true,
                      publisher: true,
                      original_price: true,
                    },
                  },
                },
              },
            },
          },
        },
      },
    },
    orderBy: [
      { createdAt: "desc" },
      { id: "desc" },
    ],
    take: normalizedLimit + 1,
  });

  const hasMore = orders.length > normalizedLimit;
  const pageData = hasMore ? orders.slice(0, normalizedLimit) : orders;
  const nextCursor = hasMore && pageData.length > 0
    ? `${pageData[pageData.length - 1].createdAt.toISOString()}_${pageData[pageData.length - 1].id}`
    : null;

  return {
    data: pageData,
    nextCursor,
  };
}

// NEW: Function to fulfill an order
async function fulfillOrderImpl(dbCtx: Prisma.TransactionClient, pickupCode: string) {
  // ATOMIC CONDITIONAL UPDATE: Only proceed if order exists and is in PENDING_PICKUP state
  const updatedOrder = await dbCtx.order.updateMany({
    where: {
      pickup_code: pickupCode,
      status: "PENDING_PICKUP"
    },
    data: {
      status: "COMPLETED",
      completed_at: new Date(),
    },
  });

  // Check if the atomic update was successful
  if (updatedOrder.count !== 1) {
    // Either order doesn't exist or is not in PENDING_PICKUP state
    const order = await dbCtx.order.findUnique({
      where: { pickup_code: pickupCode },
      select: { id: true, status: true },
    });

    if (!order) {
      throw new ApiError(
        404,
        `å–è´§ç  "${pickupCode}" æ— æ•ˆ`,
        "INVALID_PICKUP_CODE",
      );
    } else {
      throw new ApiError(
        409,
        `æ­¤è®¢å•çŠ¶æ€ä¸º "${order.status}"ï¼Œæ— æ³•æ ¸é”€ã€‚è®¢å•å¿…é¡»å·²æ”¯ä»˜æ‰èƒ½æ ¸é”€ã€‚`,
        "ORDER_STATE_INVALID",
      );
    }
  }

  // Get order items for inventory update
  const orderItems = await dbCtx.orderItem.findMany({
    where: {
      Order: { pickup_code: pickupCode }
    },
    select: { inventory_item_id: true },
  });

  const inventoryItemIds = orderItems.map(item => item.inventory_item_id);

  // Update inventory items to sold status and clear reservation pointer
  await dbCtx.inventoryItem.updateMany({
    where: { id: { in: inventoryItemIds } },
    data: {
      status: INVENTORY_STATUS.SOLD,
    },
  });

  // Only increment metrics after successful atomic update
  metrics.ordersCompleted.inc();

  // Return the updated order data
  const completedOrder = await dbCtx.order.findUnique({
    where: { pickup_code: pickupCode },
    include: { orderItem: true },
  });

  // Track fulfillment duration if both timestamps exist
  if (completedOrder && completedOrder.paid_at && completedOrder.completed_at) {
    const fulfillmentDurationSeconds =
      (completedOrder.completed_at.getTime() - completedOrder.paid_at.getTime()) / 1000;
    metrics.orderFulfillmentDurationSeconds.observe(fulfillmentDurationSeconds);
  }

  return completedOrder!;
}

export async function fulfillOrder(dbCtx: PrismaClient | Prisma.TransactionClient, pickupCode: string) {
  if ("$connect" in dbCtx) {
    return (dbCtx as PrismaClient).$transaction((tx) => fulfillOrderImpl(tx, pickupCode));
  }

  return fulfillOrderImpl(dbCtx as Prisma.TransactionClient, pickupCode);
}

export interface PaymentIntentContext {
  outTradeNo: string;
  amountTotal: number;
  description: string;
  timeExpireIso: string;
  openid: string;
}

export async function preparePaymentIntent(
  prisma: PrismaClient,
  orderId: number,
  userId: number,
): Promise<PaymentIntentContext> {
  return prisma.$transaction(async (tx) => {
    const order = await tx.order.findUniqueOrThrow({ where: { id: orderId } });
    if (order.user_id !== userId) {
      throw new ApiError(403, "æ— æƒæ”¯ä»˜æ­¤è®¢å•", "FORBIDDEN");
    }
    if (order.status !== "PENDING_PAYMENT") {
      throw new ApiError(409, "è®¢å•çŠ¶æ€ä¸æ­£ç¡®", "ORDER_STATE_INVALID");
    }

    const user = await tx.user.findUniqueOrThrow({
      where: { id: userId },
      select: { openid: true },
    });

    const orderItems = await tx.orderItem.findMany({
      where: { order_id: orderId },
      select: {
        price: true,
        inventoryItem: {
          select: {
            bookSku: {
              select: {
                bookMaster: {
                  select: {
                    title: true,
                  },
                },
              },
            },
          },
        },
      },
    });

    const calculatedTotal = orderItems.reduce(
      (sum, item) => sum.add(item.price),
      new Prisma.Decimal(0),
    );

    if (calculatedTotal.comparedTo(order.total_amount) !== 0) {
      console.error(`CRITICAL: Amount mismatch for order ${orderId}. Stored: ${order.total_amount}, Calculated: ${calculatedTotal}`);
      throw new ApiError(400, "è®¢å•é‡‘é¢å¼‚å¸¸ï¼Œè¯·è”ç³»å®¢æœ", "AMOUNT_MISMATCH");
    }

    const amountTotal = Math.round(parseFloat(order.total_amount.toString()) * 100);
    if (amountTotal <= 0 || amountTotal > 100000000) {
      throw new ApiError(400, "è®¢å•é‡‘é¢å¼‚å¸¸", "INVALID_AMOUNT");
    }

    const outTradeNo = `BOOKWORM_${order.id}`;

    await tx.paymentRecord.upsert({
      where: { out_trade_no: outTradeNo },
      create: {
        out_trade_no: outTradeNo,
        order_id: order.id,
        status: "PENDING",
        amount_total: amountTotal,
        appid: config.WX_APP_ID,
        mchid: config.WXPAY_MCHID,
      },
      update: {
        amount_total: amountTotal,
      },
    });

    const titles = orderItems.map((i) => i.inventoryItem.bookSku.bookMaster.title);
    const description =
      titles.slice(0, 3).join("ã€") +
      (titles.length > 3 ? `ç­‰${titles.length}æœ¬ä¹¦ç±` : "");

    return {
      outTradeNo,
      amountTotal,
      description,
      timeExpireIso: new Date(order.paymentExpiresAt).toISOString(),
      openid: user.openid,
    };
  });
}

export function buildWechatPaymentRequest(intent: PaymentIntentContext) {
  return {
    appid: config.WX_APP_ID,
    mchid: config.WXPAY_MCHID,
    description: intent.description,
    out_trade_no: intent.outTradeNo,
    notify_url: config.WXPAY_NOTIFY_URL,
    time_expire: intent.timeExpireIso,
    amount: { total: intent.amountTotal, currency: "CNY" as const },
    payer: { openid: intent.openid },
  };
}

export function buildClientPaymentSignature(
  intent: PaymentIntentContext,
  prepayId: string,
  wechatPayAdapter: WechatPayAdapter,
) {
  const timeStamp = Math.floor(Date.now() / 1000).toString();
  const nonceStr = crypto.randomBytes(16).toString("hex");
  const pkg = `prepay_id=${prepayId}`;
  const toSign = `${config.WX_APP_ID}\n${timeStamp}\n${nonceStr}\n${pkg}\n`;

  const paySign = wechatPayAdapter.generateSignature({ message: toSign });

  return { timeStamp, nonceStr, package: pkg, signType: "RSA" as const, paySign };
}

export async function generatePaymentParams(
  prisma: PrismaClient,
  wechatPayAdapter: WechatPayAdapter,
  orderId: number,
  userId: number,
) {
  const intent = await preparePaymentIntent(prisma, orderId, userId);
  const { prepay_id } = await wechatPayAdapter.createPaymentOrder(
    buildWechatPaymentRequest(intent),
  );

  return buildClientPaymentSignature(intent, prepay_id, wechatPayAdapter);
}

// Payment notification data with security validation requirements
interface PaymentNotificationData {
  timestamp: string;    // WeChat timestamp for replay protection
  nonce: string;        // Random string for replay protection
  signature: string;    // WeChat signature for authenticity
  serial: string;       // Certificate serial number
  body: string;         // Original notification body
  out_trade_no: string; // Business order number
}

export async function processPaymentNotification(
  dbCtx: PrismaClient | Prisma.TransactionClient,
  wechatPayAdapter: WechatPayAdapter,
  notificationData: PaymentNotificationData,
) {
  const { out_trade_no, timestamp, nonce, signature, serial, body } = notificationData;

  // === Phase 0: Security Validation (Zero Trust) ===

  // 1. Timestamp validation to prevent replay attacks
  const notificationTimestamp = parseInt(timestamp, 10);
  const currentTimestamp = Math.floor(Date.now() / 1000);

  // æ‹’ç»æœªæ¥æ—¶é—´æˆ³ï¼Œä½†å…è®¸åˆç†çš„æ—¶é’Ÿåå·®
  const CLOCK_SKEW_TOLERANCE = 60; // å…è®¸60ç§’æ—¶é’Ÿåå·®
  if (notificationTimestamp > currentTimestamp + CLOCK_SKEW_TOLERANCE) {
    console.warn(`Payment notification with future timestamp rejected for ${out_trade_no}. Notification: ${notificationTimestamp}, Current: ${currentTimestamp}, Tolerance: ${CLOCK_SKEW_TOLERANCE}s`);
    throw new ApiError(400, "Invalid future timestamp", "TIMESTAMP_INVALID");
  }

  // æ£€æŸ¥è¿‡æœŸï¼ˆåªå…è®¸åˆç†çš„è¿‡å»æ—¶é—´ï¼‰
  if (currentTimestamp - notificationTimestamp > config.PAYMENT_TIMESTAMP_TOLERANCE_SECONDS) {
    console.warn(`Payment notification timestamp validation failed for ${out_trade_no}. Age: ${currentTimestamp - notificationTimestamp}s`);
    throw new ApiError(400, "Payment notification expired", "TIMESTAMP_EXPIRED");
  }

  // 2. Signature validation to ensure authenticity
  const isSignatureValid = wechatPayAdapter.verifySignature({
    timestamp,
    nonce,
    body,
    signature,
    serial,
  });

  if (!isSignatureValid) {
    console.error(`Payment notification signature validation failed for ${out_trade_no}`);
    throw new ApiError(400, "Invalid payment notification signature", "SIGNATURE_INVALID");
  }

  // === Phase 1: Pre-checks and Network I/O (Outside Transaction) ===

  // 1. Idempotency Check: See if we've already processed this.
  const initialPaymentRecord = await dbCtx.paymentRecord.findUnique({
    where: { out_trade_no },
  });

  if (!initialPaymentRecord) {
    console.warn(`Payment notification for unknown out_trade_no ${out_trade_no} received. Ignoring.`);
    return;
  }

  if (initialPaymentRecord.status !== 'PENDING') {
    console.log(`Payment notification for ${out_trade_no} already processed (status: ${initialPaymentRecord.status}). Skipping.`);
    return;
  }

  const executeInTransaction = async (fn: (tx: Prisma.TransactionClient) => Promise<void>) => {
    if ("$transaction" in dbCtx) {
      return await (dbCtx as PrismaClient).$transaction(fn);
    }

    return await fn(dbCtx as Prisma.TransactionClient);
  };

  const markPaymentAsFailed = async (
    updateData: Prisma.PaymentRecordUpdateManyMutationInput = {},
    logMessage?: string,
  ) => {
    const failed = await dbCtx.paymentRecord.updateMany({
      where: {
        out_trade_no,
        status: "PENDING",
      },
      data: {
        status: "FAILED",
        notified_at: new Date(),
        ...updateData,
      },
    });

    if (failed.count > 0) {
      if (logMessage) {
        console.warn(logMessage);
      }
      metrics.paymentsProcessed.labels({ status: "failed" }).inc();
    } else if (logMessage) {
      console.warn(
        `${logMessage} (skipped because payment record was already processed for ${out_trade_no}).`,
      );
    }
  };

  // 2. Active Query (Zero Trust Principle): Get the truth from WeChat's servers.
  let queriedTxData;
  try {
    queriedTxData = await retryAsync(
      () => wechatPayAdapter.queryPaymentStatus({ out_trade_no, mchid: config.WXPAY_MCHID }),
      3, // attempts
      200 // initial delay ms
    );
  } catch (queryError) {
    console.error(`Failed to query transaction ${out_trade_no} from WeChat Pay API after retries.`, queryError);

    // Business layer error handling - no HTTP status codes
    if (queryError instanceof WechatPayError && !queryError.isRetryable) {
      await markPaymentAsFailed({}, `Permanent error for ${out_trade_no}: ${queryError.message}. Marked as FAILED.`);
      return; // Stop processing.
    }

    // For all other errors (retryable WechatPayError or unknown errors), throw business exception
    throw new PaymentQueryError("WECHAT_QUERY_FAILED_TRANSIENT", queryError);
  }

  // 3. Validate the Truth
  const { trade_state, amount, payer, mchid, appid, transaction_id } = queriedTxData;

  if (trade_state !== 'SUCCESS') {
    const finalFailureStates = new Set(['CLOSED', 'REVOKED', 'PAYERROR']);
    if (finalFailureStates.has(trade_state)) {
      await markPaymentAsFailed(
        {
          transaction_id,
          payer_openid: payer?.openid,
        },
        `Payment for ${out_trade_no} is in a final failure state (${trade_state}). Marked as FAILED.`,
      );
    } else {
      // For transient states like USERPAYING, we want WeChat to retry later.
      console.log(`Payment for ${out_trade_no} is in transient state (${trade_state}). Requesting retry.`);
      throw new ApiError(503, `Payment in transient state: ${trade_state}`, "PAY_TRANSIENT_STATE");
    }
    return;
  }

  if (mchid !== config.WXPAY_MCHID || appid !== config.WX_APP_ID || amount.total !== initialPaymentRecord.amount_total) {
    console.error(`CRITICAL: Payment data mismatch for ${out_trade_no}. Marking as FAILED.`, {
        expected: { mchid: config.WXPAY_MCHID, appid: config.WX_APP_ID, total: initialPaymentRecord.amount_total },
        received: { mchid, appid, total: amount.total }
    });
    await markPaymentAsFailed({
      transaction_id,
      payer_openid: payer?.openid,
    });
    return;
  }

  // === Phase 2: Atomic State Update (Inside Transaction) ===
  await executeInTransaction(async (tx) => {
    // Re-fetch payment record to ensure it's still PENDING before we start.
    // This is an additional safeguard.
    const paymentRecord = await tx.paymentRecord.findUnique({
      where: { out_trade_no },
    });

    // Another process might have handled it. If so, we're done.
    if (!paymentRecord || paymentRecord.status !== 'PENDING') {
      console.log(`Payment ${out_trade_no} was processed by a concurrent request. Skipping.`);
      return;
    }

    // THE CRITICAL FIX: ATOMIC CONDITIONAL UPDATE
    // Attempt to transition the order from PENDING_PAYMENT to PENDING_PICKUP.
    // This will only succeed if the status is still PENDING_PAYMENT.
    const updatedOrder = await tx.order.updateMany({
      where: {
        id: paymentRecord.order_id,
        status: 'PENDING_PAYMENT',
      },
      data: {
        status: 'PENDING_PICKUP',
        paid_at: new Date(),
      },
    });

    // Check if the atomic update was successful.
    if (updatedOrder.count === 1) {
      // SUCCESS: We won the race. The order is now PENDING_PICKUP.
      // Finalize the payment record.
      await tx.paymentRecord.update({
        where: { out_trade_no },
        data: {
          status: 'SUCCESS',
          transaction_id,
          payer_openid: payer?.openid,
          notified_at: new Date(),
        },
      });
      console.log(`Order ${paymentRecord.order_id} successfully updated to PENDING_PICKUP.`);
      metrics.paymentsProcessed.labels({ status: "success" }).inc();
    } else {
      // FAILURE: We lost the race. The order was likely cancelled before payment was confirmed.
      // Mark the payment for refund.
      await tx.paymentRecord.update({
        where: { out_trade_no },
        data: {
          status: 'REFUND_REQUIRED',
          transaction_id,
          payer_openid: payer?.openid,
          notified_at: new Date(),
        },
      });
      console.error(`CRITICAL: Payment succeeded for an order (${paymentRecord.order_id}) that was not PENDING_PAYMENT (likely cancelled). Marked for refund.`);
      metrics.paymentsProcessed.labels({ status: "refund_required" }).inc();
    }
  });
}

export async function getPendingPickupOrders(dbCtx: PrismaClient | Prisma.TransactionClient) {
  // Linuså¼æ–¹æ¡ˆï¼šåˆ†ç¦»æŸ¥è¯¢ï¼Œæ‰‹åŠ¨èšåˆï¼Œæ¶ˆé™¤N+1

  // 1. è·å–æ‰€æœ‰å¾…å–è´§è®¢å•åŠå…¶orderItemï¼ˆä¸€å±‚includeï¼‰
  const ordersWithItems = await dbCtx.order.findMany({
    where: { status: "PENDING_PICKUP" },
    include: {
      orderItem: true, // åªincludeä¸€å±‚ï¼Œé¿å…æ·±å±‚åµŒå¥—
    },
    orderBy: { paid_at: "asc" },
  });

  // 2. æå–æ‰€æœ‰inventory_item_id
  const inventoryItemIds = ordersWithItems.flatMap((o) =>
    o.orderItem.map((item) => item.inventory_item_id),
  );

  // å¦‚æœæ²¡æœ‰è®¢å•ï¼Œç›´æ¥è¿”å›ç©ºæ•°ç»„
  if (inventoryItemIds.length === 0) {
    return [];
  }

  // 3. ä¸€æ¬¡æ€§æŸ¥è¯¢æ‰€æœ‰ç›¸å…³çš„inventoryæ•°æ®
  const inventoryItems = await dbCtx.inventoryItem.findMany({
    where: {
      id: { in: inventoryItemIds },
    },
    select: {
      id: true,
      condition: true,
      selling_price: true,
      status: true,
      bookSku: {
        select: {
          id: true,
          edition: true,
          cover_image_url: true,
          bookMaster: {
            select: {
              id: true,
              isbn13: true,
              title: true,
              author: true,
              publisher: true,
              original_price: true,
            },
          },
        },
      },
    },
  });

  // 4. åˆ›å»ºinventoryæ•°æ®çš„å¿«é€ŸæŸ¥æ‰¾Map
  const inventoryMap = new Map(inventoryItems.map((item) => [item.id, item]));

  // 5. æ‰‹åŠ¨èšåˆæ•°æ®ï¼šå°†å®Œæ•´çš„inventoryä¿¡æ¯é™„åŠ åˆ°æ¯ä¸ªorderItemä¸Š
  const enrichedOrders = ordersWithItems.map((order) => ({
    ...order,
    orderItem: order.orderItem.map((item) => ({
      ...item,
      inventoryItem: inventoryMap.get(item.inventory_item_id)!,
    })),
  }));

  return enrichedOrders;
}

export async function cancelExpiredOrders(dbCtx: Prisma.TransactionClient | PrismaClient) {
  // This single CTE query performs both actions atomically.
  // 1. `cancelled_orders` CTE finds and updates expired orders, returning their IDs.
  // 2. `released_items` CTE uses the IDs from the first CTE to find and release the associated inventory items.
  // 3. The final SELECT aggregates the counts from both CTEs.
  const query = Prisma.sql`
    WITH cancelled_orders AS (
      UPDATE "Order"
      SET status = 'CANCELLED', cancelled_at = NOW()
      WHERE id IN (
        SELECT id FROM "Order"
        WHERE status = 'PENDING_PAYMENT' AND "paymentExpiresAt" < NOW()
        ORDER BY "paymentExpiresAt" ASC
        LIMIT 1000
        FOR UPDATE SKIP LOCKED
      )
      RETURNING id
    ),
    released_items AS (
      UPDATE "inventoryitem" i
      SET status = 'in_stock', updated_at = NOW()
      FROM inventory_reservation ir
      WHERE ir.inventory_item_id = i.id
        AND ir.order_id IN (SELECT id FROM cancelled_orders)
      RETURNING i.id
    ),
    deleted_reservations AS (
      DELETE FROM inventory_reservation ir
      USING cancelled_orders co
      WHERE ir.order_id = co.id
      RETURNING ir.inventory_item_id
    )
    SELECT
      (SELECT COUNT(*) FROM cancelled_orders) as "cancelledCount",
      (SELECT COUNT(*) FROM released_items) as "releasedCount";
  `;

  const result = await (dbCtx as PrismaClient).$queryRaw<
    { cancelledCount: bigint; releasedCount: bigint }[]
  >(query);

  const cancelledCount = Number(result[0]?.cancelledCount || 0);
  const releasedCount = Number(result[0]?.releasedCount || 0);

  if (cancelledCount > 0) {
    console.log(
      `Atomically cancelled ${cancelledCount} orders and released ${releasedCount} items back to stock.`
    );
    metrics.ordersCancelled.inc(cancelledCount);
  }

  // The function signature remains the same, returning only the cancelled order count.
  return { cancelledCount };
}

export async function getOrderById(
  dbCtx: PrismaClient | Prisma.TransactionClient,
  orderId: number,
  userId: number,
) {
  // Get user role for authorization
  const userWithRole = await dbCtx.user.findUnique({
    where: { id: userId },
    select: { role: true },
  });
  if (!userWithRole) {
    throw new ApiError(403, "User not found", "USER_NOT_FOUND");
  }

  const selectFields = {
    id: true,
    user_id: true,
    status: true,
    total_amount: true,
    pickup_code: true,
    paymentExpiresAt: true,
    paid_at: true,
    cancelled_at: true,
    createdAt: true,
    orderItem: {
      select: {
        id: true,
        order_id: true,
        inventory_item_id: true,
        inventoryItem: {
          select: {
            id: true,
            condition: true,
            selling_price: true,
            bookSku: {
              select: {
                id: true,
                edition: true,
                cover_image_url: true,
                bookMaster: {
                  select: {
                    id: true,
                    isbn13: true,
                    title: true,
                    author: true,
                    publisher: true,
                    original_price: true,
                  },
                },
              },
            },
          },
        },
      },
    },
  };

  let order;

  if (userWithRole.role === "STAFF") {
    // STAFF can access any order
    order = await dbCtx.order.findUnique({
      where: { id: orderId },
      select: selectFields,
    });
  } else {
    // USER can only access their own orders - use findFirst with compound conditions
    order = await dbCtx.order.findFirst({
      where: {
        id: orderId,
        user_id: userId,
      },
      select: selectFields,
    });
  }

  if (!order) {
    throw new ApiError(404, "Order not found", "ORDER_NOT_FOUND");
  }

  return order;
}

async function updateOrderStatusImpl(
  dbCtx: Prisma.TransactionClient,
  orderId: number,
  newStatus: "COMPLETED" | "CANCELLED",
  user: { userId: number; role: string },
) {
  // Only STAFF can update order status
  if (user.role !== "STAFF") {
    throw new ApiError(
      403,
      "åªæœ‰å·¥ä½œäººå‘˜å¯ä»¥æ›´æ–°è®¢å•çŠ¶æ€",
      "INSUFFICIENT_PERMISSIONS",
    );
  }

  // Get current order with items
  const currentOrder = await dbCtx.order.findUnique({
    where: { id: orderId },
    include: {
      orderItem: {
        include: {
          inventoryItem: true,
        },
      },
    },
  });

  if (!currentOrder) {
    throw new ApiError(404, "è®¢å•ä¸å­˜åœ¨", "ORDER_NOT_FOUND");
  }

  // Check if status transition is valid
  const validTransitions: Record<string, string[]> = {
    PENDING_PAYMENT: ["CANCELLED"],
    PENDING_PICKUP: ["COMPLETED", "CANCELLED"],
    COMPLETED: [],
    CANCELLED: [],
  };

  const allowedTransitions = validTransitions[currentOrder.status];
  if (!allowedTransitions?.includes(newStatus)) {
    throw new ApiError(
      400,
      `æ— æ³•å°†è®¢å•ä» ${currentOrder.status} æ›´æ–°ä¸º ${newStatus}`,
      "INVALID_STATUS_TRANSITION",
    );
  }

  // Update order status
  const updatedOrder = await dbCtx.order.update({
    where: { id: orderId },
    data: {
      status: newStatus,
      ...(newStatus === "COMPLETED" && { completed_at: new Date() }),
      ...(newStatus === "CANCELLED" && { cancelled_at: new Date() }),
    },
  });

  // Update inventory items based on new status
  if (newStatus === "COMPLETED") {
    // Mark all items as sold and clear reservation pointer
    await dbCtx.inventoryItem.updateMany({
      where: {
        id: {
          in: currentOrder.orderItem.map((item) => item.inventory_item_id),
        },
      },
      data: {
        status: INVENTORY_STATUS.SOLD,
      },
    });
    metrics.ordersCompleted.inc();
  } else if (newStatus === "CANCELLED") {
    // Release inventory back to stock
    await dbCtx.inventoryItem.updateMany({
      where: {
        id: {
          in: currentOrder.orderItem.map((item) => item.inventory_item_id),
        },
      },
      data: {
        status: INVENTORY_STATUS.IN_STOCK,
      },
    });

    // If cancelling a paid order, mark payment for refund
    if (currentOrder.status === "PENDING_PICKUP") {
      await dbCtx.paymentRecord.updateMany({
        where: { order_id: orderId, status: 'SUCCESS' },
        data: { status: 'REFUND_REQUIRED' }
      });
    }

    metrics.ordersCancelled.inc();
  }

  return updatedOrder;
}

export async function updateOrderStatus(
  dbCtx: PrismaClient | Prisma.TransactionClient,
  orderId: number,
  newStatus: "COMPLETED" | "CANCELLED",
  user: { userId: number; role: string },
) {
  if ("$connect" in dbCtx) {
    return (dbCtx as PrismaClient).$transaction((tx) => updateOrderStatusImpl(tx, orderId, newStatus, user));
  }

  return updateOrderStatusImpl(dbCtx as Prisma.TransactionClient, orderId, newStatus, user);
}


================================================================================
### FILE: bookworm-backend\src\services\refundService.ts
================================================================================

import { PrismaClient, Prisma } from "@prisma/client";
import { WechatPayAdapter } from "../adapters/wechatPayAdapter";
import * as crypto from "crypto";
import { BUSINESS_LIMITS } from "../constants";

export async function processPendingRefunds(
  dbCtx: PrismaClient, // This job should use the global client
  wechatPayAdapter: WechatPayAdapter
) {
  const thirtyMinutesAgo = new Date(Date.now() - 30 * 60 * 1000);

  const recordsToProcess = await dbCtx.paymentRecord.findMany({
    where: {
      refund_attempts: { lt: BUSINESS_LIMITS.MAX_REFUND_ATTEMPTS },
      OR: [
        { status: 'REFUND_REQUIRED' },
        {
          status: 'REFUND_PROCESSING',
          updatedAt: { lt: thirtyMinutesAgo },
        },
      ],
    },
    take: BUSINESS_LIMITS.REFUND_BATCH_SIZE,
  });

  if (recordsToProcess.length === 0) {
    return { processedCount: 0, successCount: 0, failureCount: 0 };
  }

  let successCount = 0;
  let failureCount = 0;
  const failures: { id: number; outTradeNo: string; reason: string }[] = [];

  type LockedPaymentRecord = {
    id: number;
    out_trade_no: string;
    amount_total: number;
    refund_attempts: number;
  };

  const lockedRecords: LockedPaymentRecord[] = [];

  for (const record of recordsToProcess) {
    const locked = await dbCtx.paymentRecord.updateMany({
      where: {
        id: record.id,
        status: record.status,
        updatedAt: record.updatedAt,
      },
      data: {
        status: "REFUND_PROCESSING",
        refund_attempts: { increment: 1 },
      },
    });

    if (locked.count === 0) {
      console.log(`Refund record ${record.id} changed state before locking. Skipping.`);
      continue;
    }

    const refreshedRecord = await dbCtx.paymentRecord.findUnique({
      where: { id: record.id },
      select: {
        id: true,
        out_trade_no: true,
        amount_total: true,
        refund_attempts: true,
      },
    });

    if (!refreshedRecord) {
      console.warn(`Refund record ${record.id} missing after lock acquisition. Skipping.`);
      continue;
    }

    lockedRecords.push({
      id: refreshedRecord.id,
      out_trade_no: refreshedRecord.out_trade_no,
      amount_total: refreshedRecord.amount_total,
      refund_attempts: refreshedRecord.refund_attempts,
    });
  }

  for (const lockedRecord of lockedRecords) {
    try {
      const refundIdHash = crypto
        .createHash('md5')
        .update(`${lockedRecord.out_trade_no}_${lockedRecord.id}`)
        .digest('hex')
        .slice(0, 8);
      const out_refund_no = `RF_${lockedRecord.out_trade_no}_${refundIdHash}`;

      await wechatPayAdapter.createRefund({
        out_trade_no: lockedRecord.out_trade_no,
        out_refund_no,
        amount: {
          refund: lockedRecord.amount_total,
          total: lockedRecord.amount_total,
          currency: 'CNY',
        },
        reason: 'è®¢å•å–æ¶ˆåæ”¯ä»˜æˆåŠŸ',
      });

      await dbCtx.paymentRecord.update({
        where: { id: lockedRecord.id },
        data: {
          status: 'REFUNDED',
          refunded_at: new Date(),
          refund_id: out_refund_no,
        },
      });
      successCount++;
    } catch (error) {
      const outTradeNo = lockedRecord.out_trade_no;
      console.error(`Failed to process refund for out_trade_no: ${outTradeNo}`, error);
      failureCount++;
      const failureReason = error instanceof Error ? error.message : 'Unknown refund failure';
      failures.push({ id: lockedRecord.id, outTradeNo, reason: failureReason });

      const attempts = lockedRecord.refund_attempts;
      const reachedLimit = attempts >= BUSINESS_LIMITS.MAX_REFUND_ATTEMPTS;
      try {
        await dbCtx.paymentRecord.update({
          where: { id: lockedRecord.id },
          data: {
            status: reachedLimit ? 'FAILED' : 'REFUND_REQUIRED',
          },
        });
        if (reachedLimit) {
          console.error(
            `Refund permanently failed after ${BUSINESS_LIMITS.MAX_REFUND_ATTEMPTS} attempts for out_trade_no: ${outTradeNo}`,
          );
        }
      } catch (updateError) {
        console.error(
          `Failed to update status after refund failure for out_trade_no: ${outTradeNo}`,
          updateError,
        );
        throw updateError;
      }
    }
  }

  return {
    processedCount: recordsToProcess.length,
    successCount,
    failureCount,
    failures,
  };
}

export async function markPaymentForRefund(
  dbCtx: PrismaClient | Prisma.TransactionClient,
  outTradeNo: string,
): Promise<void> {
  const updated = await dbCtx.paymentRecord.updateMany({
    where: {
      out_trade_no: outTradeNo,
      status: 'SUCCESS', // Only refund payments that are currently marked as SUCCESS
    },
    data: {
      status: 'REFUND_REQUIRED',
    },
  });

  if (updated.count === 0) {
    console.warn(`No successful payment record found for out_trade_no: ${outTradeNo} - it may have already been refunded or is not in SUCCESS state`);
    // Don't throw error - this is expected behavior for idempotent refund requests
  }
}


================================================================================
### FILE: bookworm-backend\src\tests\database-integration-setup.ts
================================================================================

// src/tests/database-integration-setup.ts
// Setup for tests that need real database connections (like order expiration tests)
import "dotenv/config";
import { beforeAll, afterAll, beforeEach, afterEach } from "vitest";
import { PrismaClient } from "@prisma/client";
import { FastifyInstance } from "fastify";
import { buildApp } from "../index";
import * as dotenv from "dotenv";

// Load test environment variables
dotenv.config({ path: ".env.test" });

let prisma: PrismaClient;

beforeAll(async () => {
  console.log("Setting up database integration test environment...");

  // Use SQLite in-memory database for testing if PostgreSQL test DB is not available
  const testDatabaseUrl =
    process.env.DATABASE_URL ||
    "file:./test.db?connection_limit=1&pool_timeout=20";

  // Create a fresh Prisma client for testing
  prisma = new PrismaClient({
    datasources: {
      db: {
        url: testDatabaseUrl,
      },
    },
  });

  // Connect to test database
  await prisma.$connect();
  console.log(
    `Connected to test database: ${testDatabaseUrl.includes("file:") ? "SQLite in-memory" : "PostgreSQL"}`,
  );

  // Run database migrations for SQLite if needed
  if (testDatabaseUrl.includes("file:")) {
    console.log(
      "Using SQLite for testing - schema will be auto-created by Prisma",
    );
  }

  // Basic connectivity test
  try {
    await prisma.$executeRaw`SELECT 1`;
  } catch (error) {
    console.error("Database connection failed:", error);
    throw new Error("Test database is not accessible");
  }
});

afterAll(async () => {
  console.log("Cleaning up database integration test environment...");

  if (prisma) {
    await prisma.$disconnect();
  }
});

// Export helper functions for use in individual tests
export async function setupTestEnv() {
  // Clean all test data at the start of each test
  await cleanupTestData();
}

export async function cleanupTestEnv() {
  // Clean all test data at the end of each test
  await cleanupTestData();
}

async function cleanupTestData() {
  if (!prisma) return;

  try {
    // Use TRUNCATE to efficiently delete all data from tables and reset sequences,
    // respecting foreign key dependencies via CASCADE.
    await prisma.$executeRawUnsafe(`
      TRUNCATE TABLE
        "User",
        "bookMaster",
        "bookSku",
        "inventoryItem",
        "Order",
        "orderitem",
        "Content",
        "PaymentRecord"
      RESTART IDENTITY CASCADE;
    `);
  } catch (error) {
    console.warn("Cleanup error (may be expected):", error);
  }
}

export async function createTestUser(
  role: "USER" | "STAFF" = "USER",
): Promise<{ userId: number; token: string }> {
  const { createSigner } = await import("fast-jwt");
  const config = await import("../config").then((m) => m.default);

  const openid = `test-${role.toLowerCase()}-${Date.now()}-${Math.random()}`;

  const user = await prisma.user.create({
    data: {
      openid,
      nickname: `Test ${role} User`,
      role,
    },
  });

  // Create JWT token
  const signer = createSigner({
    key: config.JWT_SECRET,
    expiresIn: "1h",
  });

  const userPayload = {
    userId: user.id,
    openid,
    role: user.role // åŒ…å«roleå­—æ®µä»¥æ”¯æŒæ–°çš„JWTéªŒè¯é€»è¾‘
  };
  const token = await signer(userPayload);

  return { userId: user.id, token };
}

export async function createTestInventoryItems(
  count: number,
): Promise<number[]> {
  // Create a test book master with unique ISBN using timestamp + random
  const uniqueIsbn =
    `978${Date.now()}${Math.floor(Math.random() * 1000)}`.slice(0, 13);
  const bookMaster = await prisma.bookMaster.create({
    data: {
      isbn13: uniqueIsbn,
      title: "Test Book",
      author: "Test Author",
      publisher: "Test Publisher",
      original_price: 100.0,
    },
  });

  // Create a test book SKU
  const bookSku = await prisma.bookSku.create({
    data: {
      master_id: bookMaster.id,
      edition: "1st Edition",
      cover_image_url: "https://example.com/cover.jpg",
    },
  });

  // Create multiple inventory items
  const inventoryItems = [];
  for (let i = 0; i < count; i++) {
    const item = await prisma.inventoryItem.create({
      data: {
        sku_id: bookSku.id,
        condition: "GOOD",
        cost: 60.0,
        selling_price: 80.0,
        status: "in_stock",
      },
    });
    inventoryItems.push(item.id);
  }

  return inventoryItems;
}

export function setupIsolatedTestEnvironment() {
  let app: FastifyInstance;

  // This will run before all tests in a file that uses this setup.
  beforeAll(async () => {
    // 1. Build a fresh, new Fastify app instance.
    app = await buildApp();
    await app.ready(); // Ensure all plugins are loaded
  });

  // This will run after all tests in the file.
  afterAll(async () => {
    // 2. Close the app instance to release resources.
    await app.close();
  });

  // This will run after each individual test.
  afterEach(async () => {
    // 3. Clean the database to ensure the next test starts with a clean slate.
    await cleanupTestEnv(); // Assuming cleanupTestEnv is your robust cleanup function
  });

  // Return the app instance so tests can use it.
  return {
    getApp: () => app,
  };
}


================================================================================
### FILE: bookworm-backend\src\tests\globalSetup.ts
================================================================================

import { PostgreSqlContainer, type StartedPostgreSqlContainer } from '@testcontainers/postgresql';
import { exec } from 'node:child_process';
import { promisify } from 'node:util';
import path from 'path';
import { PrismaClient } from '@prisma/client';

const execAsync = promisify(exec);

const prismaBinary = path.join(__dirname, '..', '..', 'node_modules', '.bin', 'prisma');

// This object will hold a mapping from worker ID to its dedicated container instance.
const containers: Record<number, StartedPostgreSqlContainer> = {};
const prismaClients: Record<number, PrismaClient> = {};

declare global {
  // eslint-disable-next-line no-var
  var __BOOKWORM_TRUNCATE__: ((workerId?: number) => Promise<void>) | undefined;
}

export async function setup(config: any) {
  const workers = config.workers || 1; // Get the number of parallel workers, default to 1

  for (let i = 1; i <= workers; i++) {
    console.log(`[Worker ${i}] Starting a dedicated PostgreSQL container...`);
    const container = await new PostgreSqlContainer('postgres:15').start();
    containers[i] = container;

    const databaseUrl = container.getConnectionUri();

    console.log(`[Worker ${i}] Container started. Applying migrations...`);
    await execAsync(`${prismaBinary} migrate deploy`, {
      env: { ...process.env, DATABASE_URL: databaseUrl },
    });
    console.log(`[Worker ${i}] Migrations applied.`);

    // Store a Prisma Client instance for this worker
    prismaClients[i] = new PrismaClient({
      datasources: {
        db: {
          url: databaseUrl,
        },
      },
    });

    await truncateAllTables(prismaClients[i]);
  }

  // Pass the container details to the test environment
  process.env.TEST_CONTAINERS = JSON.stringify(
    Object.fromEntries(
      Object.entries(containers).map(([workerId, container]) => [
        workerId,
        container.getConnectionUri(),
      ])
    )
  );

  globalThis.__BOOKWORM_TRUNCATE__ = async (workerId?: number) => {
    const resolvedWorkerId = workerId ?? parseInt(process.env.VITEST_WORKER_ID || '1', 10);
    const client = prismaClients[resolvedWorkerId] ?? getPrismaClientForWorker();
    await truncateAllTables(client);
  };
}

export async function teardown() {
  console.log('Tearing down all test containers...');
  await Promise.all(Object.values(containers).map(container => container.stop()));
  console.log('All containers stopped.');
}

// Helper to get the Prisma Client for the current worker
export function getPrismaClientForWorker(): PrismaClient {
  const workerId = parseInt(process.env.VITEST_WORKER_ID || '1', 10);

  // Try to get the stored client first
  let client = prismaClients[workerId];

  // If not found, try to create a new client using the container URL from environment
  if (!client) {
    const testContainers = process.env.TEST_CONTAINERS;
    if (testContainers) {
      const containers = JSON.parse(testContainers);
      const databaseUrl = containers[workerId] || containers['1']; // Fallback to worker 1 if current worker not found

      if (databaseUrl) {
        console.log(`Creating new Prisma client for worker ${workerId} with URL: ${databaseUrl.substring(0, 30)}...`);
        client = new PrismaClient({
          datasources: {
            db: {
              url: databaseUrl,
            },
          },
        });

        // Store it for future use
        prismaClients[workerId] = client;
      }
    }
  }

  if (!client) {
    throw new Error(`No Prisma client available for worker ${workerId}. Available workers: ${Object.keys(prismaClients).join(', ')}, TEST_CONTAINERS: ${process.env.TEST_CONTAINERS}`);
  }
  return client;
}

async function truncateAllTables(prisma: PrismaClient) {
  await prisma.$executeRawUnsafe(`
    TRUNCATE TABLE
      "PaymentRecord",
      "orderitem",
      "inventory_reservation",
      "inventoryitem",
      "pending_payment_order",
      "Order",
      "booksku",
      "bookmaster",
      "Content",
      "User"
    RESTART IDENTITY CASCADE;
  `);
}

// Helper functions that use the worker's Prisma client
export async function createTestUser(
  role: "USER" | "STAFF" = "USER",
): Promise<{ userId: number; token: string }> {
  const prisma = getPrismaClientForWorker();
  const { createSigner } = await import("fast-jwt");
  const config = await import("../config").then((m) => m.default);

  const openid = `test-${role.toLowerCase()}-${Date.now()}-${Math.random()}`;

  const user = await prisma.user.create({
    data: {
      openid,
      nickname: `Test ${role} User`,
      role,
    },
  });

  // Create JWT token
  const signer = createSigner({
    key: config.JWT_SECRET,
    expiresIn: "1h",
  });

  const userPayload = {
    userId: user.id,
    openid,
    role: user.role // åŒ…å«roleå­—æ®µä»¥æ”¯æŒæ–°çš„JWTéªŒè¯é€»è¾‘
  };
  const token = await signer(userPayload);

  return { userId: user.id, token };
}

let testBookCounter = 0;

export async function createTestInventoryItems(
  count: number,
): Promise<number[]> {
  const prisma = getPrismaClientForWorker();

  // Generate a truly unique ISBN using multiple entropy sources
  const workerId = parseInt(process.env.VITEST_WORKER_ID || '1', 10);
  const timestamp = Date.now();
  const randomNum = Math.floor(Math.random() * 100000);
  testBookCounter++;

  // Use upsert to handle potential conflicts gracefully
  const uniqueIsbn = `978${workerId}${testBookCounter}${randomNum}`.slice(0, 13).padEnd(13, '0');

  const bookMaster = await prisma.bookMaster.upsert({
    where: { isbn13: uniqueIsbn },
    update: {},
    create: {
      isbn13: uniqueIsbn,
      title: `Test Book ${timestamp}-${testBookCounter}`,
      author: "Test Author",
      publisher: "Test Publisher",
      original_price: 100.0,
    },
  });

  // Create a test book SKU
  const bookSku = await prisma.bookSku.create({
    data: {
      master_id: bookMaster.id,
      edition: "1st Edition",
      cover_image_url: "https://example.com/cover.jpg",
    },
  });

  // Create multiple inventory items
  const inventoryItems = [];
  for (let i = 0; i < count; i++) {
    const item = await prisma.inventoryItem.create({
      data: {
        sku_id: bookSku.id,
        condition: "GOOD",
        cost: 60.0,
        selling_price: 80.0,
        status: "in_stock",
      },
    });
    inventoryItems.push(item.id);
  }

  return inventoryItems;
}


================================================================================
### FILE: bookworm-backend\src\tests\integrationSetup.ts
================================================================================

import { beforeEach, afterEach } from "vitest";

declare global {
  // eslint-disable-next-line no-var
  var __BOOKWORM_TRUNCATE__: ((workerId?: number) => Promise<void>) | undefined;
}

async function resetDatabase() {
  if (typeof globalThis.__BOOKWORM_TRUNCATE__ === "function") {
    await globalThis.__BOOKWORM_TRUNCATE__();
  }
}

beforeEach(async () => {
  await resetDatabase();
});

afterEach(async () => {
  await resetDatabase();
});


================================================================================
### FILE: bookworm-backend\src\tests\setup.ts
================================================================================

// src/tests/setup.ts
import { vi } from "vitest";
import { PrismaClient } from "@prisma/client";

// Create a mock Prisma client
const prismaMock = {
  bookMaster: {
    upsert: vi.fn(),
    findUnique: vi.fn(),
    findMany: vi.fn(),
  },
  bookSku: {
    upsert: vi.fn(),
    findUnique: vi.fn(),
    findMany: vi.fn(),
  },
  inventoryItem: {
    create: vi.fn(),
    findMany: vi.fn(),
    findUnique: vi.fn(),
    update: vi.fn(),
    updateMany: vi.fn(),
    count: vi.fn(),
  },
  user: {
    upsert: vi.fn(),
    findUnique: vi.fn(),
    findUniqueOrThrow: vi.fn(),
  },
  order: {
    create: vi.fn(),
    findMany: vi.fn(),
    findUnique: vi.fn(),
    findUniqueOrThrow: vi.fn(),
    update: vi.fn(),
  },
  orderItem: {
    create: vi.fn(),
    createMany: vi.fn(),
    findMany: vi.fn(),
  },
  paymentRecord: {
    create: vi.fn(),
    upsert: vi.fn(),
    deleteMany: vi.fn(),
    findMany: vi.fn(),
  },
  $transaction: vi.fn(),
  $queryRawUnsafe: vi.fn(),
} as unknown as PrismaClient;

vi.mock("../db", () => ({
  __esModule: true,
  default: prismaMock,
}));

beforeEach(() => {
  vi.clearAllMocks();
  (prismaMock.$transaction as unknown as any).mockImplementation(async (fn: any) => fn(prismaMock));
});

export { prismaMock };


================================================================================
### FILE: bookworm-backend\src\tests\test-helpers\errorHelpers.ts
================================================================================

// src/tests/test-helpers/errorHelpers.ts
// Helper functions to create properly typed test errors without 'as any'

import { Prisma } from "@prisma/client";

/**
 * Create a Prisma unique constraint error for testing
 */
export function createPrismaUniqueConstraintError(
  target: string | string[] = [],
  message = "Unique constraint failed"
): Prisma.PrismaClientKnownRequestError {
  const error = new Prisma.PrismaClientKnownRequestError(
    message,
    {
      code: "P2002",
      clientVersion: "test",
      meta: { target: Array.isArray(target) ? target : [target] }
    }
  );
  return error;
}

/**
 * Create a Prisma serialization error for testing
 */
export function createPrismaSerializationError(
  message = "could not serialize access due to concurrent update"
): Prisma.PrismaClientKnownRequestError {
  const error = new Prisma.PrismaClientKnownRequestError(
    message,
    {
      code: "P2034",
      clientVersion: "test",
    }
  );
  return error;
}

/**
 * Create a pickup code constraint error for testing
 */
export function createPickupCodeConstraintError(): Prisma.PrismaClientKnownRequestError {
  return createPrismaUniqueConstraintError("pickup_code", "Unique constraint failed");
}


================================================================================
### FILE: bookworm-backend\src\tests\test-helpers\orderService.helper.ts
================================================================================

// src/tests/test-helpers/orderService.helper.ts
import { mockDeep } from "vitest-mock-extended";
import { PrismaClient, Prisma } from "@prisma/client";
import { vi } from "vitest";

/**
 * Sets up default mocks for successful createOrder operations
 * This eliminates repetitive mock setup across test cases
 */
export function setupDefaultCreateOrderMocks(
  prismaMock: ReturnType<typeof mockDeep<PrismaClient>>,
) {
  // Mockå‰ç½®æ£€æŸ¥é€šè¿‡
  prismaMock.order.count.mockResolvedValue(0);

  // Add $connect method to make it recognizable as PrismaClient
  (prismaMock as any).$connect = vi.fn().mockResolvedValue(undefined);

  // Mockäº‹åŠ¡æˆåŠŸè·¯å¾„çš„é»˜è®¤è¡Œä¸º
  prismaMock.$transaction.mockImplementation(async (callback) => {
    // Mockç°æœ‰é¢„ç•™å•†å“æ£€æŸ¥çš„ä¸¤æ¬¡æŸ¥è¯¢
    // ç¬¬ä¸€æ¬¡ï¼šæ£€æŸ¥é‡å¤é¡¹ç›®ï¼ˆè¿”å›ç©ºï¼Œæ— å†²çªï¼‰
    prismaMock.order.findMany.mockResolvedValueOnce([]);
    // ç¬¬äºŒæ¬¡ï¼šæ£€æŸ¥æ€»æ•°é™åˆ¶ï¼ˆè¿”å›ç©ºï¼Œæ— å·²é¢„ç•™å•†å“ï¼‰
    prismaMock.order.findMany.mockResolvedValueOnce([]);

    // Mockåº“å­˜æ›´æ–°æˆåŠŸ
    prismaMock.inventoryItem.updateMany.mockResolvedValue({ count: 1 });

    // Mockè®¢å•é¡¹åˆ›å»ºæˆåŠŸ
    prismaMock.orderItem.createMany.mockResolvedValue({ count: 1 });

    return callback(prismaMock);
  });
}

/**
 * Creates mock inventory items with consistent structure
 */
export function createMockInventoryItems(
  items: Array<{ id: number; price: string; status?: string }>,
) {
  return items.map((item) => ({
    id: item.id,
    selling_price: new Prisma.Decimal(item.price),
    status: item.status || "in_stock",
  })) as any;
}

/**
 * Creates a mock order with consistent structure
 */
export function createMockOrder(overrides: {
  id?: number;
  user_id: number;
  total_amount: string;
  pickup_code?: string;
  status?: string;
}) {
  return {
    id: overrides.id || 1,
    user_id: overrides.user_id,
    total_amount: new Prisma.Decimal(overrides.total_amount),
    pickup_code: overrides.pickup_code || "ABCD1234",
    status: overrides.status || "PENDING_PAYMENT",
  } as any;
}


================================================================================
### FILE: bookworm-backend\src\tests\test-helpers\testServices.ts
================================================================================

import { PrismaClient, book_condition, Prisma } from "@prisma/client";

interface AddBookInput {
  isbn13: string;
  title: string;
  author?: string;
  edition?: string;
  condition: book_condition;
  cost: number;
  selling_price: number;
}

// Test version of addBookToInventory that accepts a Prisma client
export async function addBookToInventoryTest(prisma: PrismaClient, input: AddBookInput) {
  return prisma.$transaction(async (tx) => {
    // Step 1: Find or create the master book record (based on ISBN).
    const bookMaster = await tx.bookMaster.upsert({
      where: { isbn13: input.isbn13 },
      update: {
        title: input.title,
        author: input.author || null,
      },
      create: {
        isbn13: input.isbn13,
        title: input.title,
        author: input.author || null,
        publisher: null,
        
      },
    });

    // Step 2: Find or create the SKU (edition/format combination)
    const bookSku = await tx.bookSku.upsert({
      where: {
        master_id_edition: {
          master_id: bookMaster.id,
          edition: input.edition || "æœªçŸ¥ç‰ˆæœ¬",
        },
      },
      update: {},
      create: {
        master_id: bookMaster.id,
        edition: input.edition || "æœªçŸ¥ç‰ˆæœ¬",
      },
    });

    // Step 3: Create the inventory item
    const inventoryItem = await tx.inventoryItem.create({
      data: {
        sku_id: bookSku.id,
        condition: input.condition,
        cost: input.cost,
        selling_price: input.selling_price,
        status: "in_stock",
      },
      include: {
        bookSku: {
          include: {
            bookMaster: true,
          },
        },
      },
    });

    return inventoryItem;
  });
}

// Test version of createOrder that accepts a Prisma client
export async function createOrderTest(
  prisma: PrismaClient,
  userId: number,
  itemIds: number[]
) {
  return prisma.$transaction(
    async (tx) => {
      // Find and reserve inventory items
      const itemsToReserve = await tx.inventoryItem.findMany({
        where: {
          id: { in: itemIds },
          status: "in_stock",
        },
      });

      if (itemsToReserve.length !== itemIds.length) {
        throw new Error("éƒ¨åˆ†ä¹¦ç±å·²ä¸å¯ç”¨ï¼Œè¯·åˆ·æ–°åé‡è¯•");
      }

      // Calculate total amount
      const totalAmount = itemsToReserve.reduce((sum, item) => sum + Number(item.selling_price), 0);

      // Create the order first
      const order = await tx.Order.create({
        data: {
          user_id: userId,
          status: "PENDING_PAYMENT",
          total_amount: totalAmount,
          pickup_code: Math.random().toString(36).substring(2, 16).toUpperCase(),
          paymentExpiresAt: new Date(Date.now() + 15 * 60 * 1000), // 15 minutes from now
          orderItem: {
            create: itemIds.map((itemId) => {
              const item = itemsToReserve.find(i => i.id === itemId)!;
              return {
                inventory_item_id: itemId,
                price: item.selling_price,
              };
            }),
          },
        },
        include: {
          orderItem: {
            include: {
              inventoryItem: {
                include: {
                  bookSku: {
                    include: {
                      bookMaster: true,
                    },
                  },
                },
              },
            },
          },
        },
      });

      // Now reserve the items with the order ID (satisfies the constraint)
      await tx.inventoryItem.updateMany({
        where: {
          id: { in: itemIds },
          status: "in_stock",
        },
        data: {
          status: "reserved",
          reserved_by_order_id: order.id,
        },
      });

      return order;
    },
    {
      isolationLevel: Prisma.TransactionIsolationLevel.Serializable,
    }
  );
}

// Test version of fulfillOrder that accepts a Prisma client
export async function fulfillOrderTest(
  prisma: PrismaClient,
  pickupCode: string
) {
  return prisma.$transaction(
    async (tx) => {
      // Find the order by pickup code
      const order = await tx.Order.findFirst({
        where: {
          pickup_code: pickupCode,
          status: "PENDING_PICKUP",
        },
        include: {
          orderItem: {
            include: {
              inventoryItem: true,
            },
          },
        },
      });

      if (!order) {
        throw new Error("è®¢å•ä¸å­˜åœ¨æˆ–çŠ¶æ€é”™è¯¯");
      }

      // Mark inventory as sold and clear reservation
      const itemIds = order.orderItem.map((item) => item.inventory_item_id);
      await tx.inventoryItem.updateMany({
        where: { id: { in: itemIds } },
        data: {
          status: "sold",
          reserved_by_order_id: null,
        },
      });

      // Complete the order
      const completedOrder = await tx.Order.update({
        where: { id: order.id },
        data: {
          status: "COMPLETED",
          completed_at: new Date(),
        },
        include: {
          orderItem: {
            include: {
              inventoryItem: {
                include: {
                  bookSku: {
                    include: {
                      bookMaster: true,
                    },
                  },
                },
              },
            },
          },
        },
      });

      return completedOrder;
    },
    {
      isolationLevel: Prisma.TransactionIsolationLevel.Serializable,
    }
  );
}


================================================================================
### FILE: bookworm-backend\src\types\wechatpay.d.ts
================================================================================

// src/types/wechatpay.d.ts

// Since the 'wechatpay-node-v3' library doesn't export proper types,
// we define our own interface for the parts of the API we actually use.
// This is infinitely better than using 'any'.
export interface IWechatPayV3 {
  transactions_jsapi(params: any): Promise<any>;
  transactions_out_trade_no(params: { out_trade_no: string; mchid: string }): Promise<any>;
  verifySign(params: any): boolean;
  decipher_gcm(ciphertext: string, associated_data: string, nonce: string, apiv3Key: string): string;
  sign(message: string): string;
  // Add other methods here if you use them
}


================================================================================
### FILE: bookworm-backend\src\utils\dbLock.ts
================================================================================

// src/utils/dbLock.ts

import { Prisma, PrismaClient } from "@prisma/client";
import crypto from "crypto";

import { BUSINESS_LIMITS } from "../constants";

/**
 * Executes a task while holding a PostgreSQL advisory lock.
 * Ensures that only one instance of the application can run the task at the same time.
 *
 * IMPORTANT: Advisory locks are session-scoped. This function uses a transaction
 * to guarantee that all raw queries run on the same database connection.
 *
 * @param prisma The PrismaClient instance.
 * @param lockName A unique name for the lock, e.g., 'job:cancel_expired_orders'.
 * @param task The async function to execute if the lock is acquired.
 * @returns The result of the task if the lock was acquired, otherwise null.
 */
function deriveLockKeys(lockName: string): [number, number] {
  const digest = crypto.createHash("sha256").update(lockName).digest();
  const key1 = digest.readInt32BE(0);
  const key2 = digest.readInt32BE(4);
  return [key1, key2];
}

export async function withAdvisoryLock<T>(
  prisma: PrismaClient,
  lockName: string,
  task: () => Promise<T>,
): Promise<T | null> {
  return prisma.$transaction(
    async (tx) => {
      const [key1, key2] = deriveLockKeys(lockName);
      const result = await tx.$queryRaw<{ pg_try_advisory_lock: boolean }[]>(
        Prisma.sql`SELECT pg_try_advisory_lock(${key1}, ${key2})`,
      );

      const lockAcquired = result[0]?.pg_try_advisory_lock;

      if (!lockAcquired) {
        console.log(
          `[AdvisoryLock] Could not acquire lock for "${lockName}". Another instance is likely running.`,
        );
        return null;
      }

      console.log(
        `[AdvisoryLock] Lock acquired for "${lockName}". Running task.`,
      );
      try {
        return await task();
      } finally {
        await tx.$queryRaw(Prisma.sql`SELECT pg_advisory_unlock(${key1}, ${key2})`);
        console.log(`[AdvisoryLock] Lock released for "${lockName}".`);
      }
    },
    {
      timeout: BUSINESS_LIMITS.ADVISORY_LOCK_TIMEOUT_MS,
    },
  );
}


================================================================================
### FILE: bookworm-backend\src\utils\dbVerifier.ts
================================================================================

import { PrismaClient } from "@prisma/client";

interface CriticalConstraint {
  name: string;
  query: (db: PrismaClient) => Promise<boolean>;
  errorMessage: string;
}

// Define all critical constraints that cannot be expressed in schema.prisma
const CRITICAL_CONSTRAINTS: CriticalConstraint[] = [
  {
    name: "Pending payment guard table",
    query: async (db: PrismaClient) => {
      const result = await db.$queryRaw<[{ exists: boolean }]>`
        SELECT EXISTS (
          SELECT 1
          FROM information_schema.tables
          WHERE table_name = 'pending_payment_order'
        );
      `;
      return result[0]?.exists === true;
    },
    errorMessage: "Pending payment guard table missing. Run database migrations before starting the service.",
  },
  {
    name: "Unique constraint uniq_order_pending_per_user",
    query: async (db: PrismaClient) => {
      const result = await db.$queryRaw<[{ exists: boolean }]>`
        SELECT EXISTS (
          SELECT 1
          FROM pg_constraint
          WHERE conname = 'uniq_order_pending_per_user'
        );
      `;
      return result[0]?.exists === true;
    },
    errorMessage: "Unique constraint 'uniq_order_pending_per_user' is missing. Duplicate pending orders would slip through.",
  },
  {
    name: "Trigger order_sync_pending_payment_insert",
    query: async (db: PrismaClient) => {
      const result = await db.$queryRaw<[{ exists: boolean }]>`
        SELECT EXISTS (
          SELECT 1 FROM pg_trigger
          WHERE tgname = 'order_sync_pending_payment_insert'
            AND tgrelid = '"Order"'::regclass
        );
      `;
      return result[0]?.exists === true;
    },
    errorMessage: "Trigger 'order_sync_pending_payment_insert' missing. Pending guard table will drift.",
  },
  {
    name: "Trigger inventory_reservation_enforce_cap",
    query: async (db: PrismaClient) => {
      const result = await db.$queryRaw<[{ exists: boolean }]>`
        SELECT EXISTS (
          SELECT 1 FROM pg_trigger
          WHERE tgname = 'inventory_reservation_enforce_cap'
            AND tgrelid = 'inventory_reservation'::regclass
        );
      `;
      return result[0]?.exists === true;
    },
    errorMessage: "Trigger 'inventory_reservation_enforce_cap' missing. User reservation cap is unenforced.",
  },
  {
    name: "Constraint trigger inventoryitem_validate_reservation",
    query: async (db: PrismaClient) => {
      const result = await db.$queryRaw<[{ exists: boolean }]>`
        SELECT EXISTS (
          SELECT 1 FROM pg_trigger
          WHERE tgname = 'inventoryitem_validate_reservation'
            AND tgrelid = 'inventoryitem'::regclass
        );
      `;
      return result[0]?.exists === true;
    },
    errorMessage: "Constraint trigger 'inventoryitem_validate_reservation' missing. Inventory state consistency is not guarded.",
  },
];

/**
 * Verifies that all critical, manually-defined database constraints exist.
 * If a constraint is missing, it logs a fatal error and exits the process.
 * @param db The PrismaClient instance.
 */
export async function verifyDatabaseConstraints(db: PrismaClient): Promise<void> {
  console.log("Verifying critical database constraints...");
  let allOk = true;

  for (const constraint of CRITICAL_CONSTRAINTS) {
    const exists = await constraint.query(db);
    if (exists) {
      console.log(`  âœ… [OK] ${constraint.name}`);
    } else {
      console.error(`  âŒ [FATAL] ${constraint.name}: ${constraint.errorMessage}`);
      allOk = false;
    }
  }

  if (!allOk) {
    console.error("\nDatabase constraint verification failed. The application cannot start in an inconsistent state.");
    process.exit(1);
  }

  console.log("All critical database constraints verified successfully.");
}


================================================================================
### FILE: bookworm-backend\src\utils\retry.ts
================================================================================

import { BUSINESS_LIMITS } from "../constants";

/**
 * A simple utility to retry an async function with exponential backoff.
 * @param fn The async function to retry.
 * @param attempts The maximum number of attempts.
 * @param delay The initial delay in ms.
 * @returns The result of the async function if it succeeds.
 * @throws The error of the last attempt if all attempts fail.
 */
export async function retryAsync<T>(
  fn: () => Promise<T>,
  attempts: number = BUSINESS_LIMITS.DEFAULT_RETRY_ATTEMPTS,
  delay: number = BUSINESS_LIMITS.DEFAULT_RETRY_DELAY_MS,
): Promise<T> {
  for (let i = 0; i < attempts; i++) {
    try {
      return await fn();
    } catch (error) {
      if (i === attempts - 1) {
        // This was the last attempt, re-throw the error.
        throw error;
      }
      // Wait for an exponentially increasing amount of time.
      const backoffDelay = delay * Math.pow(2, i);
      console.log(
        `Attempt ${i + 1}/${attempts} failed. Retrying in ${backoffDelay}ms...`,
      );
      await new Promise((res) => setTimeout(res, backoffDelay));
    }
  }
  // This line should theoretically be unreachable.
  throw new Error("Retry logic failed unexpectedly.");
}


================================================================================
### FILE: bookworm-backend\src\utils\typeGuards.ts
================================================================================

// src/utils/typeGuards.ts
// Type guards for safe error handling without 'as any'

import { Prisma } from "@prisma/client";
import { ApiError } from "../errors";

/**
 * Type guard for Fastify HTTP errors with statusCode
 */
export interface FastifyHttpError {
  statusCode: number;
  code?: string;
  message?: string;
  validation?: any[];
}

export function isFastifyHttpError(error: unknown): error is FastifyHttpError {
  return (
    typeof error === 'object' &&
    error !== null &&
    typeof (error as any).statusCode === 'number'
  );
}

/**
 * Type guard for Fastify validation errors
 */
export interface FastifyValidationError extends FastifyHttpError {
  statusCode: 400;
  validation: any[];
}

export function isFastifyValidationError(error: unknown): error is FastifyValidationError {
  return (
    isFastifyHttpError(error) &&
    error.statusCode === 400 &&
    Array.isArray((error as any).validation)
  );
}

/**
 * Type guard for Prisma known request errors
 */
export function isPrismaKnownError(error: unknown): error is Prisma.PrismaClientKnownRequestError {
  return error instanceof Prisma.PrismaClientKnownRequestError;
}

/**
 * Type guard for Prisma serialization errors
 */
export function isPrismaSerializationError(error: unknown): boolean {
  return (
    isPrismaKnownError(error) &&
    (error.code === "P2034" || error.message?.includes("could not serialize"))
  );
}

/**
 * Type guard for Prisma unique constraint errors
 */
export function isPrismaUniqueConstraintError(error: unknown): error is Prisma.PrismaClientKnownRequestError & { code: "P2002" } {
  return isPrismaKnownError(error) && error.code === "P2002";
}

/**
 * Check if a Prisma unique constraint error is specifically for pickup_code
 */
export function isPickupCodeConstraintError(error: unknown): boolean {
  if (!isPrismaUniqueConstraintError(error)) return false;

  const meta = error.meta as { target?: string[] } | undefined;
  return meta?.target?.includes("pickup_code") === true;
}

/**
 * Type guard for API errors
 */
export function isApiError(error: unknown): error is ApiError {
  return error instanceof ApiError;
}

/**
 * Type guard for standard Error objects
 */
export function isError(error: unknown): error is Error {
  return error instanceof Error;
}

/**
 * Type guard for Axios errors
 */
export interface AxiosError {
  isAxiosError: true;
  response?: {
    status: number;
    data?: any;
  };
  message: string;
}

export function isAxiosError(error: unknown): error is AxiosError {
  return (
    typeof error === 'object' &&
    error !== null &&
    (error as any).isAxiosError === true &&
    typeof (error as any).message === 'string'
  );
}

/**
 * Safe error message extraction
 */
export function getErrorMessage(error: unknown): string {
  if (isError(error)) {
    return error.message;
  }
  if (typeof error === 'string') {
    return error;
  }
  if (typeof error === 'object' && error !== null && 'message' in error) {
    return String((error as any).message);
  }
  return 'Unknown error';
}


================================================================================
### FILE: bookworm-backend\tsconfig.json
================================================================================

{
  "compilerOptions": {
    "target": "es2020",
    "module": "commonjs",
    "rootDir": "./",
    "outDir": "./dist",
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true,
    "strict": true,

    // Production-ready options
    "sourceMap": false, // Do not generate source maps for production
    "skipLibCheck": true,
    "resolveJsonModule": true,
    "types": ["node", "vitest/globals"]
  },
  "ts-node": {
    "esm": false
  },
  "include": ["src/**/*.ts", "prisma/seed.ts", "src/jobs/cancelExpiredOrders.ts"],
  "exclude": ["node_modules", "**/*.spec.ts", "src/tests/**/*"],
  "typeRoots": ["node_modules/@types", "src/types"]
}


================================================================================
### FILE: docker-compose.monitoring.yml
================================================================================

# docker-compose.monitoring.yml
version: '3.8'

services:
  prometheus:
    image: prom/prometheus:v2.47.2
    container_name: bookworm_prometheus
    volumes:
      - ./bookworm-backend/prometheus.yml:/etc/prometheus/prometheus.yml
    ports:
      - "9090:9090"
    command:
      - '--config.file=/etc/prometheus/prometheus.yml'
    restart: unless-stopped

  grafana:
    image: grafana/grafana-oss:10.2.2
    container_name: bookworm_grafana
    ports:
      - "4000:3000" # å°†Grafanaçš„3000ç«¯å£æ˜ å°„åˆ°å®¿ä¸»æœºçš„4000ï¼Œé¿å…å’Œåº”ç”¨å†²çª
    restart: unless-stopped


================================================================================
### FILE: fix_transactions.py
================================================================================

#!/usr/bin/env python3
"""
Script to remove $transaction wrappers from service functions
since they now receive transaction clients directly from route handlers.
"""

import re

def fix_orderservice():
    with open('bookworm-backend/src/services/orderService.ts', 'r', encoding='utf-8') as f:
        content = f.read()

    # Remove transaction wrappers but preserve the function content
    # Pattern: return dbCtx.$transaction(async (tx) => {
    content = re.sub(r'return dbCtx\.\$transaction\(async \(tx\) => \{', '', content)

    # Pattern: dbCtx.$transaction(async (tx) => {
    content = re.sub(r'dbCtx\.\$transaction\(async \(tx\) => \{', '', content)

    # Remove orphaned closing brackets and parentheses at function ends
    # This is tricky, so we'll need to be careful

    with open('bookworm-backend/src/services/orderService.ts', 'w', encoding='utf-8') as f:
        f.write(content)

if __name__ == '__main__':
    fix_orderservice()
    print("Fixed orderService.ts transaction wrappers")


================================================================================
### FILE: miniprogram\app.js
================================================================================

// miniprogram/app.js
const auth = require('./utils/auth');
const tokenUtil = require('./utils/token');

App({
  onLaunch() {
    auth.login()
      .then(res => {
        console.log('Login successful', res);
        tokenUtil.setToken(res.token);
        tokenUtil.setUserId(res.userId);
        this.checkTermsAgreement();
      })
      .catch(err => {
        console.error('Login failed on launch', err);
      });
  },

  checkTermsAgreement() {
    const hasAgreed = wx.getStorageSync('hasAgreedToTerms');
    if (!hasAgreed) {
      wx.showModal({
        title: 'æœåŠ¡åè®®ä¸éšç§æ”¿ç­–',
        content: 'æ¬¢è¿ä½¿ç”¨ï¼ä¸ºäº†ä¿éšœæ‚¨çš„æƒç›Šï¼Œè¯·åœ¨ä½¿ç”¨å‰ä»”ç»†é˜…è¯»å¹¶åŒæ„æˆ‘ä»¬çš„ã€Šç”¨æˆ·æœåŠ¡åè®®ã€‹ä¸ã€Šéšç§æ”¿ç­–ã€‹ã€‚æ‚¨å¯ä»¥åœ¨"æˆ‘çš„-è®¾ç½®"ä¸­éšæ—¶æŸ¥çœ‹ã€‚',
        confirmText: 'åŒæ„',
        cancelText: 'æ‹’ç»',
        success: (res) => {
          if (res.confirm) {
            wx.setStorageSync('hasAgreedToTerms', true);
          } else if (res.cancel) {
            // ç”¨æˆ·æ‹’ç»ï¼Œå¯ä»¥å¼•å¯¼é€€å‡ºæˆ–æç¤ºæ— æ³•ä½¿ç”¨
            wx.showToast({
              title: 'æ‚¨éœ€è¦åŒæ„åè®®æ‰èƒ½ä½¿ç”¨æœ¬æœåŠ¡',
              icon: 'none',
              duration: 3000
            });
            // ç®€å•å¤„ç†ï¼Œå¯ä»¥è®©ç”¨æˆ·æ— æ³•è¿›è¡Œæ ¸å¿ƒæ“ä½œ
          }
        }
      });
    }
  },

  // å¢åŠ ä¸€ä¸ªå…¨å±€æ–¹æ³•ï¼Œæ–¹ä¾¿å…¶ä»–é¡µé¢è°ƒç”¨
  showTerms() {
    wx.showModal({
      title: 'æœåŠ¡åè®®ä¸éšç§æ”¿ç­–',
      content: 'è¿™é‡Œæ˜¯å®Œæ•´çš„ã€Šç”¨æˆ·æœåŠ¡åè®®ã€‹ä¸ã€Šéšç§æ”¿ç­–ã€‹å†…å®¹...ï¼ˆæ­¤å¤„åº”ä»æœåŠ¡å™¨è·å–æˆ–æœ¬åœ°é¢„ç½®é•¿æ–‡æœ¬ï¼‰',
      showCancel: false,
      confirmText: 'æˆ‘å·²çŸ¥æ™“',
    });
  }
});


================================================================================
### FILE: miniprogram\app.json
================================================================================

{
  "lazyCodeLoading": "requiredComponents",
  "pages": [
    "pages/market/index",
    "pages/orders/index",
    "pages/profile/index",
    "pages/book-detail/index",
    "pages/order-confirm/index",
    "pages/order-detail/index",
    "pages/webview/index",
    "pages/customer-service/index"
  ],
  "window": {
    "backgroundTextStyle": "light",
    "navigationBarBackgroundColor": "#2c5f2d",
    "navigationBarTitleText": "æ ¡å›­ä¹¦",
    "navigationBarTextStyle": "white"
  },
  "tabBar": {
    "color": "#6b6b6b",
    "selectedColor": "#2c5f2d",
    "backgroundColor": "#ffffff",
    "borderStyle": "white",
    "list": [
      {
        "pagePath": "pages/market/index",
        "text": "å¸‚åœº",
        "iconPath": "images/tabs/marketplace.png",
        "selectedIconPath": "images/tabs/marketplace-active.png"
      },
      {
        "pagePath": "pages/orders/index",
        "text": "è®¢å•",
        "iconPath": "images/tabs/orders.png",
        "selectedIconPath": "images/tabs/orders-active.png"
      },
      {
        "pagePath": "pages/profile/index",
        "text": "æˆ‘çš„",
        "iconPath": "images/tabs/profile.png",
        "selectedIconPath": "images/tabs/profile-active.png"
      }
    ]
  },
  "style": "v2",
  "sitemapLocation": "sitemap.json"
}


================================================================================
### FILE: miniprogram\components\skeleton\skeleton.js
================================================================================

// components/skeleton/skeleton.js
Component({
  properties: {
    type: {
      type: String,
      value: 'grid' // 'grid', 'detail', 'list'
    },
    count: {
      type: Number,
      value: 4
    }
  }
});


================================================================================
### FILE: miniprogram\components\skeleton\skeleton.json
================================================================================

{
  "component": true,
  "componentPlaceholder": {
    "skeleton": "view"
  }
}


================================================================================
### FILE: miniprogram\config.js
================================================================================

// miniprogram/config.js
const config = {
  // å½“å‰ç½‘ç»œé…ç½® - WLAN IP: 172.20.10.4
  // å¦‚æœä½¿ç”¨æ¨¡æ‹Ÿå™¨å¼€å‘ï¼Œå¯æ”¹ä¸º 'http://localhost:3000/api'
  // å¦‚æœä½¿ç”¨çœŸæœºè°ƒè¯•ï¼Œä½¿ç”¨å½“å‰çš„å†…ç½‘IP
  apiBaseUrl: 'http://172.20.10.4:3000/api'
};

module.exports = config;


================================================================================
### FILE: miniprogram\pages\book-detail\index.js
================================================================================

// pages/book-detail/index.js
const { request } = require('../../utils/api');
const ui = require('../../utils/ui');
const { safeCreateOrderAndPay } = require('../../utils/payment');
const { extractErrorMessage } = require('../../utils/error');

Page({
  data: {
    bookDetail: null,
    isLoading: true,
    error: null,
    isSubmitting: false,
  },

  onLoad(options) {
    this.hasShownOnce = false;
    if (options.id) {
      this.currentId = options.id;
      this.fetchBookDetails(options.id);
    } else {
      this.setData({ error: 'æ— æ•ˆçš„ä¹¦ç±ID', isLoading: false });
    }
  },

  onShow() {
    if (!this.currentId) {
      return;
    }
    if (this.hasShownOnce) {
      this.fetchBookDetails(this.currentId, { preserveData: true });
    } else {
      this.hasShownOnce = true;
    }
  },

  async fetchBookDetails(id, { preserveData = false } = {}) {
    if (!preserveData) {
      this.setData({ isLoading: true, error: null });
    } else {
      this.setData({ error: null });
    }
    try {
      const data = await request({
        url: `/inventory/item/${id}`,
        method: 'GET'
      });
      if (!data) {
        this.setData({ error: 'ä¹¦ç±ä¿¡æ¯ä¸å­˜åœ¨' });
      } else {
        this.setData({ bookDetail: data });
      }
    } catch (error) {
      console.error('API request failed', error);
      const errorMsg = extractErrorMessage(error, 'åŠ è½½å¤±è´¥');
      this.setData({ error: errorMsg });
      ui.showError(errorMsg);
    } finally {
      this.setData({ isLoading: false });
    }
  },

  async handleBuyNow() {
    // åœ¨å‡½æ•°å¼€å§‹æ—¶è·å–æœ¬åœ°å¸¸é‡ï¼Œç¡®ä¿æ•°æ®è®¿é—®çš„ç¨³å®šæ€§
    const { bookDetail } = this.data;
    if (this.data.isSubmitting || !bookDetail) return;

    // æ˜¾ç¤ºè´­ä¹°ç¡®è®¤å¯¹è¯æ¡†
    const confirmResult = await new Promise((resolve) => {
      wx.showModal({
        title: 'ç¡®è®¤è´­ä¹°',
        content: `ç¡®å®šè¦è´­ä¹°ã€Š${bookDetail.bookSku.bookMaster.title}ã€‹å—ï¼Ÿ\næ”¯ä»˜é‡‘é¢ï¼šÂ¥${bookDetail.selling_price}`,
        confirmText: 'ç«‹å³æ”¯ä»˜',
        cancelText: 'å†çœ‹çœ‹',
        success: (res) => resolve(res.confirm),
        fail: () => resolve(false)
      });
    });

    if (!confirmResult) {
      return; // ç”¨æˆ·å–æ¶ˆè´­ä¹°
    }

    this.setData({ isSubmitting: true });
    const result = await safeCreateOrderAndPay([bookDetail.id]);

    this.setData({ isSubmitting: false });

    if (result.success) {
      setTimeout(() => {
        wx.switchTab({ url: '/pages/orders/index' });
      }, 1500);
    }
  }
});


================================================================================
### FILE: miniprogram\pages\book-detail\index.json
================================================================================

{
  "navigationBarTitleText": "ä¹¦ç±è¯¦æƒ…",
  "usingComponents": {
    "skeleton": "../../components/skeleton/skeleton"
  }
}


================================================================================
### FILE: miniprogram\pages\customer-service\index.js
================================================================================

Page({
  data: {
    customerServiceWechat: 'bookworm_service'
  },

  onLoad() {
    wx.setNavigationBarTitle({
      title: 'è”ç³»å®¢æœä¸å¸®åŠ©'
    });
  },

  // å¤åˆ¶å¾®ä¿¡å·
  copyWechatId() {
    wx.setClipboardData({
      data: this.data.customerServiceWechat,
      success: () => {
        wx.showToast({
          title: 'å·²å¤åˆ¶',
          icon: 'success',
          duration: 2000
        });
      },
      fail: () => {
        wx.showToast({
          title: 'å¤åˆ¶å¤±è´¥',
          icon: 'none',
          duration: 2000
        });
      }
    });
  }
});


================================================================================
### FILE: miniprogram\pages\customer-service\index.json
================================================================================

{
  "navigationBarTitleText": "å®¢æœä¸å¸®åŠ©"
}


================================================================================
### FILE: miniprogram\pages\market\index.js
================================================================================

// pages/market/index.js
const { request } = require('../../utils/api');
const ui = require('../../utils/ui');
const { extractErrorMessage } = require('../../utils/error');

Page({
  data: {
    state: {
      status: 'loading', // 'loading', 'success', 'error'
      data: [],
      error: null
    },
    searchTerm: '',
    searchPerformed: false, // To show different empty state messages
    pageInfo: null // For pagination metadata
  },

  onLoad() {
    this.hasShownOnce = false;
  },

  onShow() {
    if (this.hasShownOnce) {
      this.fetchAvailableBooks({ preserveData: true });
    } else {
      this.hasShownOnce = true;
      this.fetchAvailableBooks();
    }
  },

  async fetchAvailableBooks({ preserveData = false } = {}) {
    if (!preserveData) {
      this.setData({
        state: {
          status: 'loading',
          data: [],
          error: null,
        },
      });
    } else {
      this.setData({ 'state.error': null });
    }
    let url = `/inventory/available`;
    if (this.data.searchTerm) {
      url += `?search=${encodeURIComponent(this.data.searchTerm)}`;
    }

    try {
      const data = await request({
        url: url,
        method: 'GET'
      });
      this.setData({
        state: {
          status: 'success',
          data: data.data,
          error: null
        },
        pageInfo: data.meta
      });
    } catch (error) {
      console.error('API request failed', error);
      const errorMsg = extractErrorMessage(error, 'åŠ è½½å¤±è´¥');
      this.setData({
        state: {
          status: 'error',
          data: [],
          error: errorMsg
        }
      });
      ui.showError(errorMsg);
    }
  },

  // NEW: Handle input change
  handleInput(e) {
    this.setData({
      searchTerm: e.detail.value
    });
  },

  // NEW: Handle search button tap or keyboard confirm
  handleSearch() {
    this.setData({ searchPerformed: true });
    this.fetchAvailableBooks();
  },

  // Pull down refresh
  async onPullDownRefresh() {
    await this.fetchAvailableBooks({ preserveData: true });
    wx.stopPullDownRefresh();
  }
});


================================================================================
### FILE: miniprogram\pages\market\index.json
================================================================================

{
  "navigationBarTitleText": "ä¹¦å¸‚",
  "enablePullDownRefresh": true,
  "usingComponents": {
    "skeleton": "../../components/skeleton/skeleton"
  }
}


================================================================================
### FILE: miniprogram\pages\order-confirm\index.js
================================================================================

// pages/order-confirm/index.js
const api = require('../../utils/api');
const ui = require('../../utils/ui');
const { safeCreateOrderAndPay } = require('../../utils/payment');
const { extractErrorMessage } = require('../../utils/error');

Page({
  data: {
    book: null,
    isLoading: true,
    error: null,
    isSubmitting: false
  },
  
  onLoad(options) {
    this.hasShownOnce = false;
    if (options.id) {
      this.currentId = options.id;
      this.fetchBookDetails(options.id);
    } else {
      this.setData({ isLoading: false, error: 'æ— æ•ˆçš„å•†å“ID' });
    }
  },

  onShow() {
    if (!this.currentId) {
      return;
    }
    if (this.hasShownOnce) {
      this.fetchBookDetails(this.currentId, { preserveData: true });
    } else {
      this.hasShownOnce = true;
    }
  },

  async fetchBookDetails(id, { preserveData = false } = {}) {
    if (!preserveData) {
      this.setData({ isLoading: true, error: null });
    } else {
      this.setData({ error: null });
    }

    try {
      const data = await api.request({
        url: `/inventory/item/${id}`,
        method: 'GET'
      });
      
      if (data.status === 'in_stock') {
        this.setData({ book: data });
      } else {
        this.setData({ error: 'è¯¥ä¹¦ç±å·²å”®å‡ºæˆ–ä¸å¯ç”¨' });
      }
    } catch (error) {
      const errorMsg = extractErrorMessage(error, 'ç½‘ç»œè¯·æ±‚å¤±è´¥ï¼Œæ— æ³•è·å–ä¹¦ç±ä¿¡æ¯');
      this.setData({ error: errorMsg });
      ui.showError(errorMsg);
    } finally {
      this.setData({ isLoading: false });
    }
  },
  
  async handlePayment() {
    // åœ¨å‡½æ•°å¼€å§‹æ—¶è·å–æœ¬åœ°å¸¸é‡ï¼Œç¡®ä¿æ•°æ®è®¿é—®çš„ç¨³å®šæ€§
    const { book } = this.data;
    if (this.data.isSubmitting || !book) return;

    // æ˜¾ç¤ºæ”¯ä»˜ç¡®è®¤å¯¹è¯æ¡†
    const confirmResult = await new Promise((resolve) => {
      wx.showModal({
        title: 'ç¡®è®¤æ”¯ä»˜',
        content: `ç¡®å®šè¦è´­ä¹°ã€Š${book.bookSku.bookMaster.title}ã€‹å—ï¼Ÿ\næ”¯ä»˜é‡‘é¢ï¼šÂ¥${book.selling_price}`,
        confirmText: 'ç¡®è®¤æ”¯ä»˜',
        cancelText: 'å†æƒ³æƒ³',
        success: (res) => resolve(res.confirm),
        fail: () => resolve(false)
      });
    });

    if (!confirmResult) {
      return; // ç”¨æˆ·å–æ¶ˆæ”¯ä»˜
    }

    this.setData({ isSubmitting: true });
    const result = await safeCreateOrderAndPay([book.id]);
    this.setData({ isSubmitting: false });

    if (result.success) {
      setTimeout(() => {
        wx.switchTab({ url: '/pages/orders/index' });
      }, 1500);
    }
  }
});


================================================================================
### FILE: miniprogram\pages\order-confirm\index.json
================================================================================

{
  "navigationBarTitleText": "ç¡®è®¤è®¢å•"
}


================================================================================
### FILE: miniprogram\pages\order-detail\index.js
================================================================================

// pages/order-detail/index.js
const { request } = require('../../utils/api');
const { extractErrorMessage } = require('../../utils/error');

Page({
  data: {
    order: null,
    isLoading: true,
    error: null
  },

  onLoad(options) {
    this.hasShownOnce = false;
    if (options.id) {
      this.currentId = options.id;
      this.fetchOrderDetail(options.id);
    } else {
      this.setData({ 
        isLoading: false, 
        error: 'æ— æ•ˆçš„è®¢å•ID' 
      });
    }
  },

  onShow() {
    if (!this.currentId) {
      return;
    }
    if (this.hasShownOnce) {
      this.fetchOrderDetail(this.currentId, { preserveData: true });
    } else {
      this.hasShownOnce = true;
    }
  },

  async fetchOrderDetail(orderId, { preserveData = false } = {}) {
    if (!preserveData) {
      this.setData({ isLoading: true, error: null });
    } else {
      this.setData({ error: null });
    }

    try {
      const data = await request({
        url: `/orders/${orderId}`,
        method: 'GET'
      });
      this.setData({ 
        order: data,
        isLoading: false 
      });
    } catch (error) {
      const errorMsg = extractErrorMessage(error, 'è·å–è®¢å•è¯¦æƒ…å¤±è´¥');
      this.setData({ 
        error: errorMsg,
        isLoading: false 
      });
    }
  },

  formatDate(dateString) {
    if (!dateString) return '';
    const date = new Date(dateString);
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const day = String(date.getDate()).padStart(2, '0');
    const hours = String(date.getHours()).padStart(2, '0');
    const minutes = String(date.getMinutes()).padStart(2, '0');
    return `${year}-${month}-${day} ${hours}:${minutes}`;
  },

  getStatusText(status) {
    const statusMap = {
      'PENDING_PAYMENT': 'å¾…æ”¯ä»˜',
      'PENDING_PICKUP': 'å¾…å–è´§', 
      'COMPLETED': 'å·²å®Œæˆ',
      'CANCELLED': 'å·²å–æ¶ˆ'
    };
    return statusMap[status] || status;
  },

  getConditionText(condition) {
    const conditionMap = {
      'NEW': 'å…¨æ–°',
      'GOOD': 'è‰¯å¥½',
      'ACCEPTABLE': 'å¯ç”¨'
    };
    return conditionMap[condition] || condition;
  },

  onRefresh() {
    const pages = getCurrentPages();
    const currentPage = pages[pages.length - 1];
    const orderId = currentPage.options.id;
    if (orderId) {
      this.fetchOrderDetail(orderId, { preserveData: true });
    }
  },

  copyPickupCode(e) {
    const code = e.target.dataset.code || e.currentTarget.dataset.code;
    if (code) {
      wx.setClipboardData({
        data: code,
        success: () => {
          wx.showToast({
            title: 'å–è´§ç å·²å¤åˆ¶',
            icon: 'success'
          });
        }
      });
    }
  }
});


================================================================================
### FILE: miniprogram\pages\order-detail\index.json
================================================================================

{
  "navigationBarTitleText": "è®¢å•è¯¦æƒ…"
}


================================================================================
### FILE: miniprogram\pages\orders\index.js
================================================================================

// pages/orders/index.js
const auth = require('../../utils/auth');
const { request } = require('../../utils/api');
const { ORDER_STATUS } = require('../../utils/constants');
const tokenUtil = require('../../utils/token');
const ui = require('../../utils/ui');
const { extractErrorMessage } = require('../../utils/error');

Page({
  data: {
    state: {
      status: 'loading', // 'loading', 'success', 'error'
      data: [],
      error: null
    },
    statusMap: ORDER_STATUS,
    pageInfo: null // For pagination metadata
  },
  onShow() { this.fetchUserOrders(); },
  navigateToDetail(event) {
    const orderId = event.currentTarget.dataset.orderId;
    if (orderId) {
      wx.navigateTo({
        url: `/pages/order-detail/index?id=${orderId}`
      });
    }
  },
  async fetchUserOrders({ preserveData = false } = {}) {
    const userId = tokenUtil.getUserId();
    if (!userId) { return; }
    if (!preserveData) {
      this.setData({
        state: {
          status: 'loading',
          data: [],
          error: null,
        },
      });
    } else {
      this.setData({ 'state.error': null });
    }

    try {
      const data = await request({
        url: `/orders/user/${userId}`,
        method: 'GET'
      });
      this.setData({
        state: {
          status: 'success',
          data: data.data,
          error: null
        },
        pageInfo: data.meta
      });
    } catch (error) {
      const errorMsg = extractErrorMessage(error, 'åŠ è½½è®¢å•å¤±è´¥ã€‚');
      this.setData({
        state: {
          status: 'error',
          data: [],
          error: errorMsg
        }
      });
      ui.showError(errorMsg);
    }
  },

  // Pull down refresh
  async onPullDownRefresh() {
    await this.fetchUserOrders({ preserveData: true });
    wx.stopPullDownRefresh();
  }
});


================================================================================
### FILE: miniprogram\pages\orders\index.json
================================================================================

{
  "navigationBarTitleText": "æˆ‘çš„è®¢å•",
  "enablePullDownRefresh": true
}


================================================================================
### FILE: miniprogram\pages\profile\index.js
================================================================================

// miniprogram/pages/profile/index.js
const app = getApp(); // è·å–Appå®ä¾‹

Page({
  data: {
    userInfo: { nickName: 'å¾®ä¿¡ç”¨æˆ·' },
    serviceInfo: {
      wechatId: 'your_service_wechat_id',
      time: 'å·¥ä½œæ—¥ 9:00 - 18:00'
    }
  },
  copyWechatId() {
    wx.setClipboardData({
      data: this.data.serviceInfo.wechatId,
      success: () => { wx.showToast({ title: 'å·²å¤åˆ¶' }); }
    });
  },

  showTerms() {
    wx.navigateTo({
      url: '/pages/webview/index?slug=terms-of-service'
    });
  },

  showPrivacy() {
    wx.navigateTo({
      url: '/pages/webview/index?slug=privacy-policy'
    });
  },

  goToCustomerService() {
    wx.navigateTo({
      url: '/pages/customer-service/index'
    });
  },

  onShareAppMessage() {
    return {
      title: 'è¶…å€¼çš„äºŒæ‰‹æ•™æï¼Œå¿«æ¥çœ‹çœ‹å§ï¼',
      path: '/pages/market/index',
    }
  }
});


================================================================================
### FILE: miniprogram\pages\profile\index.json
================================================================================

{
  "navigationBarTitleText": "æˆ‘çš„"
}


================================================================================
### FILE: miniprogram\pages\webview\index.js
================================================================================

const { request } = require('../../utils/api');
const { extractErrorMessage } = require('../../utils/error');

Page({
  data: {
    content: null,
    isLoading: true,
    errorMsg: ''
  },

  onLoad(options) {
    const { slug } = options;
    this.hasShownOnce = false;
    this.currentSlug = slug || '';

    if (!slug) {
      this.setData({
        isLoading: false,
        errorMsg: 'é¡µé¢å‚æ•°ç¼ºå¤±'
      });
      return;
    }

    this.loadContent(slug);
  },

  onShow() {
    if (!this.currentSlug) {
      return;
    }

    if (this.hasShownOnce) {
      this.loadContent(this.currentSlug, { preserveData: true });
    } else {
      this.hasShownOnce = true;
    }
  },

  async loadContent(slug, { preserveData = false } = {}) {
    if (!preserveData) {
      this.setData({ isLoading: true, errorMsg: '' });
    } else {
      this.setData({ errorMsg: '' });
    }

    try {
      const data = await request({
        url: '/content/' + slug,
        method: 'GET'
      });
      const { title, body } = data;
      wx.setNavigationBarTitle({ title });
      this.setData({
        content: { title, body },
        isLoading: false
      });
    } catch (error) {
      console.error('Content load failed', error);
      this.setData({
        isLoading: false,
        errorMsg: extractErrorMessage(error, 'å†…å®¹åŠ è½½å¤±è´¥')
      });
    }
  }
});


================================================================================
### FILE: miniprogram\pages\webview\index.json
================================================================================

{
  "navigationBarTitleText": "è¯¦æƒ…",
  "usingComponents": {
    "skeleton": "../../components/skeleton/skeleton"
  }
}


================================================================================
### FILE: miniprogram\utils\api.js
================================================================================

// miniprogram/utils/api.js - ç»Ÿä¸€çš„APIè¯·æ±‚å·¥å…·
const config = require('../config');
const tokenUtil = require('./token');
const auth = require('./auth');

/**
 * ç»Ÿä¸€çš„APIè¯·æ±‚å‡½æ•°
 * @param {Object} options - è¯·æ±‚å‚æ•°
 * @param {string} options.url - è¯·æ±‚åœ°å€ï¼ˆç›¸å¯¹è·¯å¾„ï¼Œä¼šè‡ªåŠ¨æ‹¼æ¥baseURLï¼‰
 * @param {string} options.method - è¯·æ±‚æ–¹æ³•ï¼ˆGET, POSTç­‰ï¼‰
 * @param {Object} options.data - è¯·æ±‚æ•°æ®
 * @param {Object} options.header - è¯·æ±‚å¤´
 * @returns {Promise} - è¿”å›Promiseå¯¹è±¡
 */
let ongoingLoginPromise = null;

const request = ({ url, method = 'GET', data = {}, retry = true }) => new Promise((resolve, reject) => {
  const token = tokenUtil.getToken();
  wx.request({
    url: `${config.apiBaseUrl}${url}`,
    method,
    data,
    timeout: 10000,
    header: {
      'Content-Type': 'application/json',
      Authorization: token ? `Bearer ${token}` : '',
    },
    success: async (res) => {
      if (res.statusCode >= 200 && res.statusCode < 300) {
        return resolve(res.data);
      }

      if (res.statusCode === 401 && retry) {
        tokenUtil.clearToken();
        try {
          if (!ongoingLoginPromise) {
            ongoingLoginPromise = auth
              .ensureLoggedIn()
              .finally(() => {
                ongoingLoginPromise = null;
              });
          }
          await ongoingLoginPromise;
          const retryResult = await request({ url, method, data, retry: false });
          return resolve(retryResult);
        } catch (loginError) {
          ongoingLoginPromise = null;
          return reject(loginError);
        }
      }

      const errorPayload = res.data && typeof res.data === 'object' ? res.data : { message: `Request failed with status ${res.statusCode}` };
      return reject(errorPayload);
    },
    fail: () => reject({ message: 'ç½‘ç»œè¯·æ±‚å¤±è´¥', errorCode: 'NETWORK_ERROR' }),
  });
});

module.exports = {
  request
};


================================================================================
### FILE: miniprogram\utils\auth.js
================================================================================

const config = require('../config');
const tokenUtil = require('./token');
const ui = require('./ui');

function callWxLogin() {
  return new Promise((resolve, reject) => {
    wx.login({
      success: (res) => {
        if (res.code) resolve(res.code);
        else reject(new Error('wx.login æœªè¿”å› code'));
      },
      fail: reject,
    });
  });
}

function exchangeCodeForToken(code) {
  return new Promise((resolve, reject) => {
    wx.request({
      url: config.apiBaseUrl + '/auth/login',
      method: 'POST',
      data: { code },
      header: {
        'Content-Type': 'application/json',
      },
      success: (res) => {
        if (res.statusCode >= 200 && res.statusCode < 300 && res.data && res.data.token) {
          resolve(res.data);
        } else {
          reject(new Error((res.data && res.data.message) || 'ç™»å½•å¤±è´¥'));
        }
      },
      fail: () => reject(new Error('ç™»å½•è¯·æ±‚å¤±è´¥')),
    });
  });
}

async function login() {
  const code = await callWxLogin();
  const data = await exchangeCodeForToken(code);
  tokenUtil.setToken(data.token);
  if (data.userId) {
    tokenUtil.setUserId(data.userId);
  }
  return data;
}

async function ensureLoggedIn() {
  const token = tokenUtil.getToken();
  if (token) {
    return { token, userId: tokenUtil.getUserId() };
  }
  try {
    return await login();
  } catch (error) {
    ui.showError(error.message || 'ç™»å½•å¤±è´¥');
    throw error;
  }
}

module.exports = {
  login,
  ensureLoggedIn,
};


================================================================================
### FILE: miniprogram\utils\constants.js
================================================================================

// miniprogram/utils/constants.js
const ORDER_STATUS = {
  PENDING_PAYMENT: 'å¾…æ”¯ä»˜',
  PENDING_PICKUP: 'å¾…å–è´§',
  COMPLETED: 'å·²å®Œæˆ',
  CANCELLED: 'å·²å–æ¶ˆ',
};

module.exports = {
  ORDER_STATUS,
};


================================================================================
### FILE: miniprogram\utils\error.js
================================================================================

function extractErrorMessage(error, fallback = 'å‘ç”ŸæœªçŸ¥é”™è¯¯') {
  if (!error) {
    return fallback;
  }
  if (typeof error === 'string') {
    return error;
  }

  const message =
    error.message ||
    (error.data && error.data.message) ||
    error.error ||
    fallback;

  return typeof message === 'string' && message.trim() ? message : fallback;
}

module.exports = {
  extractErrorMessage,
};


================================================================================
### FILE: miniprogram\utils\payment.js
================================================================================

const { request } = require('./api');
const ui = require('./ui');
const { extractErrorMessage } = require('./error');

function requestPayment(params) {
  return new Promise((resolve, reject) => {
    wx.requestPayment({
      ...params,
      success: resolve,
      fail: reject,
    });
  });
}

async function createOrderAndPay(inventoryItemIds) {
  wx.showLoading({ title: 'æ­£åœ¨åˆ›å»ºè®¢å•...' });
  const order = await request({
    url: '/orders/create',
    method: 'POST',
    data: { inventoryItemIds },
  });

  wx.showLoading({ title: 'è·å–æ”¯ä»˜å‚æ•°...' });
  const payParams = await request({
    url: '/orders/' + order.id + '/pay',
    method: 'POST',
  });

  wx.hideLoading();
  await requestPayment(payParams);
  return order;
}

async function safeCreateOrderAndPay(inventoryItemIds) {
  try {
    const order = await createOrderAndPay(inventoryItemIds);
    wx.showToast({ title: 'æ”¯ä»˜æˆåŠŸ', icon: 'success' });
    return { success: true, order };
  } catch (error) {
    wx.hideLoading();
    if (error && error.errMsg && error.errMsg.indexOf('cancel') !== -1) {
      wx.showToast({ title: 'æ”¯ä»˜å·²å–æ¶ˆ', icon: 'none' });
      return { success: false, cancelled: true };
    }
    ui.showError(extractErrorMessage(error, 'ç½‘ç»œè¯·æ±‚å¤±è´¥'));
    return { success: false, cancelled: false, error };
  }
}

module.exports = {
  createOrderAndPay,
  safeCreateOrderAndPay,
};


================================================================================
### FILE: miniprogram\utils\token.js
================================================================================

// miniprogram/utils/token.js
const TOKEN_KEY = 'authToken';
const USER_ID_KEY = 'userId';

const setToken = (token) => wx.setStorageSync(TOKEN_KEY, token);
const getToken = () => wx.getStorageSync(TOKEN_KEY);
const setUserId = (userId) => wx.setStorageSync(USER_ID_KEY, userId);
const getUserId = () => wx.getStorageSync(USER_ID_KEY);
const clearToken = () => {
  wx.removeStorageSync(TOKEN_KEY);
  wx.removeStorageSync(USER_ID_KEY);
};

module.exports = {
  setToken,
  getToken,
  setUserId,
  getUserId,
  clearToken,
};


================================================================================
### FILE: miniprogram\utils\ui.js
================================================================================

function showError(message = 'è¯·æ±‚å¤±è´¥ï¼Œè¯·ç¨åå†è¯•') {
  wx.showToast({
    title: message,
    icon: 'none',
    duration: 2000
  });
}

module.exports = {
  showError
};


================================================================================
### FILE: package-lock.json
================================================================================

{
  "name": "miniprogram-13",
  "lockfileVersion": 3,
  "requires": true,
  "packages": {
    "": {
      "dependencies": {
        "axios": "^1.11.0",
        "dotenv": "^17.2.2",
        "jsonwebtoken": "^9.0.2",
        "wechatpay-node-v3": "^2.2.1"
      },
      "devDependencies": {
        "@types/jsonwebtoken": "^9.0.10"
      }
    },
    "node_modules/@fidm/asn1": {
      "version": "1.0.4",
      "resolved": "https://registry.npmmirror.com/@fidm/asn1/-/asn1-1.0.4.tgz",
      "integrity": "sha512-esd1jyNvRb2HVaQGq2Gg8Z0kbQPXzV9Tq5Z14KNIov6KfFD6PTaRIO8UpcsYiTNzOqJpmyzWgVTrUwFV3UF4TQ==",
      "license": "MIT",
      "engines": {
        "node": ">= 8"
      }
    },
    "node_modules/@fidm/x509": {
      "version": "1.2.1",
      "resolved": "https://registry.npmmirror.com/@fidm/x509/-/x509-1.2.1.tgz",
      "integrity": "sha512-nwc2iesjyc9hkuzcrMCBXQRn653XuAUKorfWM8PZyJawiy1QzLj4vahwzaI25+pfpwOLvMzbJ0uKpWLDNmo16w==",
      "license": "MIT",
      "dependencies": {
        "@fidm/asn1": "^1.0.4",
        "tweetnacl": "^1.0.1"
      },
      "engines": {
        "node": ">= 8"
      }
    },
    "node_modules/@noble/hashes": {
      "version": "1.8.0",
      "resolved": "https://registry.npmmirror.com/@noble/hashes/-/hashes-1.8.0.tgz",
      "integrity": "sha512-jCs9ldd7NwzpgXDIf6P3+NrHh9/sD6CQdxHyjQI+h/6rDNo88ypBxxz45UDuZHz9r3tNz7N/VInSVoVdtXEI4A==",
      "license": "MIT",
      "engines": {
        "node": "^14.21.3 || >=16"
      },
      "funding": {
        "url": "https://paulmillr.com/funding/"
      }
    },
    "node_modules/@paralleldrive/cuid2": {
      "version": "2.2.2",
      "resolved": "https://registry.npmmirror.com/@paralleldrive/cuid2/-/cuid2-2.2.2.tgz",
      "integrity": "sha512-ZOBkgDwEdoYVlSeRbYYXs0S9MejQofiVYoTbKzy/6GQa39/q5tQU2IX46+shYnUkpEl3wc+J6wRlar7r2EK2xA==",
      "license": "MIT",
      "dependencies": {
        "@noble/hashes": "^1.1.5"
      }
    },
    "node_modules/@types/jsonwebtoken": {
      "version": "9.0.10",
      "resolved": "https://registry.npmmirror.com/@types/jsonwebtoken/-/jsonwebtoken-9.0.10.tgz",
      "integrity": "sha512-asx5hIG9Qmf/1oStypjanR7iKTv0gXQ1Ov/jfrX6kS/EO0OFni8orbmGCn0672NHR3kXHwpAwR+B368ZGN/2rA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@types/ms": "*",
        "@types/node": "*"
      }
    },
    "node_modules/@types/ms": {
      "version": "2.1.0",
      "resolved": "https://registry.npmmirror.com/@types/ms/-/ms-2.1.0.tgz",
      "integrity": "sha512-GsCCIZDE/p3i96vtEqx+7dBUGXrc7zeSK3wwPHIaRThS+9OhWIXRqzs4d6k1SVU8g91DrNRWxWUGhp5KXQb2VA==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@types/node": {
      "version": "24.3.1",
      "resolved": "https://registry.npmmirror.com/@types/node/-/node-24.3.1.tgz",
      "integrity": "sha512-3vXmQDXy+woz+gnrTvuvNrPzekOi+Ds0ReMxw0LzBiK3a+1k0kQn9f2NWk+lgD4rJehFUmYy2gMhJ2ZI+7YP9g==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "undici-types": "~7.10.0"
      }
    },
    "node_modules/asap": {
      "version": "2.0.6",
      "resolved": "https://registry.npmmirror.com/asap/-/asap-2.0.6.tgz",
      "integrity": "sha512-BSHWgDSAiKs50o2Re8ppvp3seVHXSRM44cdSsT9FfNEUUZLOGWVCsiWaRPWM1Znn+mqZ1OfVZ3z3DWEzSp7hRA==",
      "license": "MIT"
    },
    "node_modules/asynckit": {
      "version": "0.4.0",
      "resolved": "https://registry.npmmirror.com/asynckit/-/asynckit-0.4.0.tgz",
      "integrity": "sha512-Oei9OH4tRh0YqU3GxhX79dM/mwVgvbZJaSNaRk+bshkj0S5cfHcgYakreBjrHwatXKbz+IoIdYLxrKim2MjW0Q==",
      "license": "MIT"
    },
    "node_modules/axios": {
      "version": "1.11.0",
      "resolved": "https://registry.npmmirror.com/axios/-/axios-1.11.0.tgz",
      "integrity": "sha512-1Lx3WLFQWm3ooKDYZD1eXmoGO9fxYQjrycfHFC8P0sCfQVXyROp0p9PFWBehewBOdCwHc+f/b8I0fMto5eSfwA==",
      "license": "MIT",
      "dependencies": {
        "follow-redirects": "^1.15.6",
        "form-data": "^4.0.4",
        "proxy-from-env": "^1.1.0"
      }
    },
    "node_modules/buffer-equal-constant-time": {
      "version": "1.0.1",
      "resolved": "https://registry.npmmirror.com/buffer-equal-constant-time/-/buffer-equal-constant-time-1.0.1.tgz",
      "integrity": "sha512-zRpUiDwd/xk6ADqPMATG8vc9VPrkck7T07OIx0gnjmJAnHnTVXNQG3vfvWNuiZIkwu9KrKdA1iJKfsfTVxE6NA==",
      "license": "BSD-3-Clause"
    },
    "node_modules/call-bind-apply-helpers": {
      "version": "1.0.2",
      "resolved": "https://registry.npmmirror.com/call-bind-apply-helpers/-/call-bind-apply-helpers-1.0.2.tgz",
      "integrity": "sha512-Sp1ablJ0ivDkSzjcaJdxEunN5/XvksFJ2sMBFfq6x0ryhQV/2b/KwFe21cMpmHtPOSij8K99/wSfoEuTObmuMQ==",
      "license": "MIT",
      "dependencies": {
        "es-errors": "^1.3.0",
        "function-bind": "^1.1.2"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/call-bound": {
      "version": "1.0.4",
      "resolved": "https://registry.npmmirror.com/call-bound/-/call-bound-1.0.4.tgz",
      "integrity": "sha512-+ys997U96po4Kx/ABpBCqhA9EuxJaQWDQg7295H4hBphv3IZg0boBKuwYpt4YXp6MZ5AmZQnU/tyMTlRpaSejg==",
      "license": "MIT",
      "dependencies": {
        "call-bind-apply-helpers": "^1.0.2",
        "get-intrinsic": "^1.3.0"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/combined-stream": {
      "version": "1.0.8",
      "resolved": "https://registry.npmmirror.com/combined-stream/-/combined-stream-1.0.8.tgz",
      "integrity": "sha512-FQN4MRfuJeHf7cBbBMJFXhKSDq+2kAArBlmRBvcvFE5BB1HZKXtSFASDhdlz9zOYwxh8lDdnvmMOe/+5cdoEdg==",
      "license": "MIT",
      "dependencies": {
        "delayed-stream": "~1.0.0"
      },
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/component-emitter": {
      "version": "1.3.1",
      "resolved": "https://registry.npmmirror.com/component-emitter/-/component-emitter-1.3.1.tgz",
      "integrity": "sha512-T0+barUSQRTUQASh8bx02dl+DhF54GtIDY13Y3m9oWTklKbb3Wv974meRpeZ3lp1JpLVECWWNHC4vaG2XHXouQ==",
      "license": "MIT",
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/cookiejar": {
      "version": "2.1.4",
      "resolved": "https://registry.npmmirror.com/cookiejar/-/cookiejar-2.1.4.tgz",
      "integrity": "sha512-LDx6oHrK+PhzLKJU9j5S7/Y3jM/mUHvD/DeI1WQmJn652iPC5Y4TBzC9l+5OMOXlyTTA+SmVUPm0HQUwpD5Jqw==",
      "license": "MIT"
    },
    "node_modules/debug": {
      "version": "4.4.1",
      "resolved": "https://registry.npmmirror.com/debug/-/debug-4.4.1.tgz",
      "integrity": "sha512-KcKCqiftBJcZr++7ykoDIEwSa3XWowTfNPo92BYxjXiyYEVrUQh2aLyhxBCwww+heortUFxEJYcRzosstTEBYQ==",
      "license": "MIT",
      "dependencies": {
        "ms": "^2.1.3"
      },
      "engines": {
        "node": ">=6.0"
      },
      "peerDependenciesMeta": {
        "supports-color": {
          "optional": true
        }
      }
    },
    "node_modules/delayed-stream": {
      "version": "1.0.0",
      "resolved": "https://registry.npmmirror.com/delayed-stream/-/delayed-stream-1.0.0.tgz",
      "integrity": "sha512-ZySD7Nf91aLB0RxL4KGrKHBXl7Eds1DAmEdcoVawXnLD7SDhpNgtuII2aAkg7a7QS41jxPSZ17p4VdGnMHk3MQ==",
      "license": "MIT",
      "engines": {
        "node": ">=0.4.0"
      }
    },
    "node_modules/dezalgo": {
      "version": "1.0.4",
      "resolved": "https://registry.npmmirror.com/dezalgo/-/dezalgo-1.0.4.tgz",
      "integrity": "sha512-rXSP0bf+5n0Qonsb+SVVfNfIsimO4HEtmnIpPHY8Q1UCzKlQrDMfdobr8nJOOsRgWCyMRqeSBQzmWUMq7zvVig==",
      "license": "ISC",
      "dependencies": {
        "asap": "^2.0.0",
        "wrappy": "1"
      }
    },
    "node_modules/dotenv": {
      "version": "17.2.2",
      "resolved": "https://registry.npmmirror.com/dotenv/-/dotenv-17.2.2.tgz",
      "integrity": "sha512-Sf2LSQP+bOlhKWWyhFsn0UsfdK/kCWRv1iuA2gXAwt3dyNabr6QSj00I2V10pidqz69soatm9ZwZvpQMTIOd5Q==",
      "license": "BSD-2-Clause",
      "engines": {
        "node": ">=12"
      },
      "funding": {
        "url": "https://dotenvx.com"
      }
    },
    "node_modules/dunder-proto": {
      "version": "1.0.1",
      "resolved": "https://registry.npmmirror.com/dunder-proto/-/dunder-proto-1.0.1.tgz",
      "integrity": "sha512-KIN/nDJBQRcXw0MLVhZE9iQHmG68qAVIBg9CqmUYjmQIhgij9U5MFvrqkUL5FbtyyzZuOeOt0zdeRe4UY7ct+A==",
      "license": "MIT",
      "dependencies": {
        "call-bind-apply-helpers": "^1.0.1",
        "es-errors": "^1.3.0",
        "gopd": "^1.2.0"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/ecdsa-sig-formatter": {
      "version": "1.0.11",
      "resolved": "https://registry.npmmirror.com/ecdsa-sig-formatter/-/ecdsa-sig-formatter-1.0.11.tgz",
      "integrity": "sha512-nagl3RYrbNv6kQkeJIpt6NJZy8twLB/2vtz6yN9Z4vRKHN4/QZJIEbqohALSgwKdnksuY3k5Addp5lg8sVoVcQ==",
      "license": "Apache-2.0",
      "dependencies": {
        "safe-buffer": "^5.0.1"
      }
    },
    "node_modules/es-define-property": {
      "version": "1.0.1",
      "resolved": "https://registry.npmmirror.com/es-define-property/-/es-define-property-1.0.1.tgz",
      "integrity": "sha512-e3nRfgfUZ4rNGL232gUgX06QNyyez04KdjFrF+LTRoOXmrOgFKDg4BCdsjW8EnT69eqdYGmRpJwiPVYNrCaW3g==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/es-errors": {
      "version": "1.3.0",
      "resolved": "https://registry.npmmirror.com/es-errors/-/es-errors-1.3.0.tgz",
      "integrity": "sha512-Zf5H2Kxt2xjTvbJvP2ZWLEICxA6j+hAmMzIlypy4xcBg1vKVnx89Wy0GbS+kf5cwCVFFzdCFh2XSCFNULS6csw==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/es-object-atoms": {
      "version": "1.1.1",
      "resolved": "https://registry.npmmirror.com/es-object-atoms/-/es-object-atoms-1.1.1.tgz",
      "integrity": "sha512-FGgH2h8zKNim9ljj7dankFPcICIK9Cp5bm+c2gQSYePhpaG5+esrLODihIorn+Pe6FGJzWhXQotPv73jTaldXA==",
      "license": "MIT",
      "dependencies": {
        "es-errors": "^1.3.0"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/es-set-tostringtag": {
      "version": "2.1.0",
      "resolved": "https://registry.npmmirror.com/es-set-tostringtag/-/es-set-tostringtag-2.1.0.tgz",
      "integrity": "sha512-j6vWzfrGVfyXxge+O0x5sh6cvxAog0a/4Rdd2K36zCMV5eJ+/+tOAngRO8cODMNWbVRdVlmGZQL2YS3yR8bIUA==",
      "license": "MIT",
      "dependencies": {
        "es-errors": "^1.3.0",
        "get-intrinsic": "^1.2.6",
        "has-tostringtag": "^1.0.2",
        "hasown": "^2.0.2"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/fast-safe-stringify": {
      "version": "2.1.1",
      "resolved": "https://registry.npmmirror.com/fast-safe-stringify/-/fast-safe-stringify-2.1.1.tgz",
      "integrity": "sha512-W+KJc2dmILlPplD/H4K9l9LcAHAfPtP6BY84uVLXQ6Evcz9Lcg33Y2z1IVblT6xdY54PXYVHEv+0Wpq8Io6zkA==",
      "license": "MIT"
    },
    "node_modules/follow-redirects": {
      "version": "1.15.11",
      "resolved": "https://registry.npmmirror.com/follow-redirects/-/follow-redirects-1.15.11.tgz",
      "integrity": "sha512-deG2P0JfjrTxl50XGCDyfI97ZGVCxIpfKYmfyrQ54n5FO/0gfIES8C/Psl6kWVDolizcaaxZJnTS0QSMxvnsBQ==",
      "funding": [
        {
          "type": "individual",
          "url": "https://github.com/sponsors/RubenVerborgh"
        }
      ],
      "license": "MIT",
      "engines": {
        "node": ">=4.0"
      },
      "peerDependenciesMeta": {
        "debug": {
          "optional": true
        }
      }
    },
    "node_modules/form-data": {
      "version": "4.0.4",
      "resolved": "https://registry.npmmirror.com/form-data/-/form-data-4.0.4.tgz",
      "integrity": "sha512-KrGhL9Q4zjj0kiUt5OO4Mr/A/jlI2jDYs5eHBpYHPcBEVSiipAvn2Ko2HnPe20rmcuuvMHNdZFp+4IlGTMF0Ow==",
      "license": "MIT",
      "dependencies": {
        "asynckit": "^0.4.0",
        "combined-stream": "^1.0.8",
        "es-set-tostringtag": "^2.1.0",
        "hasown": "^2.0.2",
        "mime-types": "^2.1.12"
      },
      "engines": {
        "node": ">= 6"
      }
    },
    "node_modules/formidable": {
      "version": "2.1.5",
      "resolved": "https://registry.npmmirror.com/formidable/-/formidable-2.1.5.tgz",
      "integrity": "sha512-Oz5Hwvwak/DCaXVVUtPn4oLMLLy1CdclLKO1LFgU7XzDpVMUU5UjlSLpGMocyQNNk8F6IJW9M/YdooSn2MRI+Q==",
      "license": "MIT",
      "dependencies": {
        "@paralleldrive/cuid2": "^2.2.2",
        "dezalgo": "^1.0.4",
        "once": "^1.4.0",
        "qs": "^6.11.0"
      },
      "funding": {
        "url": "https://ko-fi.com/tunnckoCore/commissions"
      }
    },
    "node_modules/function-bind": {
      "version": "1.1.2",
      "resolved": "https://registry.npmmirror.com/function-bind/-/function-bind-1.1.2.tgz",
      "integrity": "sha512-7XHNxH7qX9xG5mIwxkhumTox/MIRNcOgDrxWsMt2pAr23WHp6MrRlN7FBSFpCpr+oVO0F744iUgR82nJMfG2SA==",
      "license": "MIT",
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/get-intrinsic": {
      "version": "1.3.0",
      "resolved": "https://registry.npmmirror.com/get-intrinsic/-/get-intrinsic-1.3.0.tgz",
      "integrity": "sha512-9fSjSaos/fRIVIp+xSJlE6lfwhES7LNtKaCBIamHsjr2na1BiABJPo0mOjjz8GJDURarmCPGqaiVg5mfjb98CQ==",
      "license": "MIT",
      "dependencies": {
        "call-bind-apply-helpers": "^1.0.2",
        "es-define-property": "^1.0.1",
        "es-errors": "^1.3.0",
        "es-object-atoms": "^1.1.1",
        "function-bind": "^1.1.2",
        "get-proto": "^1.0.1",
        "gopd": "^1.2.0",
        "has-symbols": "^1.1.0",
        "hasown": "^2.0.2",
        "math-intrinsics": "^1.1.0"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/get-proto": {
      "version": "1.0.1",
      "resolved": "https://registry.npmmirror.com/get-proto/-/get-proto-1.0.1.tgz",
      "integrity": "sha512-sTSfBjoXBp89JvIKIefqw7U2CCebsc74kiY6awiGogKtoSGbgjYE/G/+l9sF3MWFPNc9IcoOC4ODfKHfxFmp0g==",
      "license": "MIT",
      "dependencies": {
        "dunder-proto": "^1.0.1",
        "es-object-atoms": "^1.0.0"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/gopd": {
      "version": "1.2.0",
      "resolved": "https://registry.npmmirror.com/gopd/-/gopd-1.2.0.tgz",
      "integrity": "sha512-ZUKRh6/kUFoAiTAtTYPZJ3hw9wNxx+BIBOijnlG9PnrJsCcSjs1wyyD6vJpaYtgnzDrKYRSqf3OO6Rfa93xsRg==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/has-symbols": {
      "version": "1.1.0",
      "resolved": "https://registry.npmmirror.com/has-symbols/-/has-symbols-1.1.0.tgz",
      "integrity": "sha512-1cDNdwJ2Jaohmb3sg4OmKaMBwuC48sYni5HUw2DvsC8LjGTLK9h+eb1X6RyuOHe4hT0ULCW68iomhjUoKUqlPQ==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/has-tostringtag": {
      "version": "1.0.2",
      "resolved": "https://registry.npmmirror.com/has-tostringtag/-/has-tostringtag-1.0.2.tgz",
      "integrity": "sha512-NqADB8VjPFLM2V0VvHUewwwsw0ZWBaIdgo+ieHtK3hasLz4qeCRjYcqfB6AQrBggRKppKF8L52/VqdVsO47Dlw==",
      "license": "MIT",
      "dependencies": {
        "has-symbols": "^1.0.3"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/hasown": {
      "version": "2.0.2",
      "resolved": "https://registry.npmmirror.com/hasown/-/hasown-2.0.2.tgz",
      "integrity": "sha512-0hJU9SCPvmMzIBdZFqNPXWa6dqh7WdH0cII9y+CyS8rG3nL48Bclra9HmKhVVUHyPWNH5Y7xDwAB7bfgSjkUMQ==",
      "license": "MIT",
      "dependencies": {
        "function-bind": "^1.1.2"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/jsonwebtoken": {
      "version": "9.0.2",
      "resolved": "https://registry.npmmirror.com/jsonwebtoken/-/jsonwebtoken-9.0.2.tgz",
      "integrity": "sha512-PRp66vJ865SSqOlgqS8hujT5U4AOgMfhrwYIuIhfKaoSCZcirrmASQr8CX7cUg+RMih+hgznrjp99o+W4pJLHQ==",
      "license": "MIT",
      "dependencies": {
        "jws": "^3.2.2",
        "lodash.includes": "^4.3.0",
        "lodash.isboolean": "^3.0.3",
        "lodash.isinteger": "^4.0.4",
        "lodash.isnumber": "^3.0.3",
        "lodash.isplainobject": "^4.0.6",
        "lodash.isstring": "^4.0.1",
        "lodash.once": "^4.0.0",
        "ms": "^2.1.1",
        "semver": "^7.5.4"
      },
      "engines": {
        "node": ">=12",
        "npm": ">=6"
      }
    },
    "node_modules/jwa": {
      "version": "1.4.2",
      "resolved": "https://registry.npmmirror.com/jwa/-/jwa-1.4.2.tgz",
      "integrity": "sha512-eeH5JO+21J78qMvTIDdBXidBd6nG2kZjg5Ohz/1fpa28Z4CcsWUzJ1ZZyFq/3z3N17aZy+ZuBoHljASbL1WfOw==",
      "license": "MIT",
      "dependencies": {
        "buffer-equal-constant-time": "^1.0.1",
        "ecdsa-sig-formatter": "1.0.11",
        "safe-buffer": "^5.0.1"
      }
    },
    "node_modules/jws": {
      "version": "3.2.2",
      "resolved": "https://registry.npmmirror.com/jws/-/jws-3.2.2.tgz",
      "integrity": "sha512-YHlZCB6lMTllWDtSPHz/ZXTsi8S00usEV6v1tjq8tOUZzw7DpSDWVXjXDre6ed1w/pd495ODpHZYSdkRTsa0HA==",
      "license": "MIT",
      "dependencies": {
        "jwa": "^1.4.1",
        "safe-buffer": "^5.0.1"
      }
    },
    "node_modules/lodash.includes": {
      "version": "4.3.0",
      "resolved": "https://registry.npmmirror.com/lodash.includes/-/lodash.includes-4.3.0.tgz",
      "integrity": "sha512-W3Bx6mdkRTGtlJISOvVD/lbqjTlPPUDTMnlXZFnVwi9NKJ6tiAk6LVdlhZMm17VZisqhKcgzpO5Wz91PCt5b0w==",
      "license": "MIT"
    },
    "node_modules/lodash.isboolean": {
      "version": "3.0.3",
      "resolved": "https://registry.npmmirror.com/lodash.isboolean/-/lodash.isboolean-3.0.3.tgz",
      "integrity": "sha512-Bz5mupy2SVbPHURB98VAcw+aHh4vRV5IPNhILUCsOzRmsTmSQ17jIuqopAentWoehktxGd9e/hbIXq980/1QJg==",
      "license": "MIT"
    },
    "node_modules/lodash.isinteger": {
      "version": "4.0.4",
      "resolved": "https://registry.npmmirror.com/lodash.isinteger/-/lodash.isinteger-4.0.4.tgz",
      "integrity": "sha512-DBwtEWN2caHQ9/imiNeEA5ys1JoRtRfY3d7V9wkqtbycnAmTvRRmbHKDV4a0EYc678/dia0jrte4tjYwVBaZUA==",
      "license": "MIT"
    },
    "node_modules/lodash.isnumber": {
      "version": "3.0.3",
      "resolved": "https://registry.npmmirror.com/lodash.isnumber/-/lodash.isnumber-3.0.3.tgz",
      "integrity": "sha512-QYqzpfwO3/CWf3XP+Z+tkQsfaLL/EnUlXWVkIk5FUPc4sBdTehEqZONuyRt2P67PXAk+NXmTBcc97zw9t1FQrw==",
      "license": "MIT"
    },
    "node_modules/lodash.isplainobject": {
      "version": "4.0.6",
      "resolved": "https://registry.npmmirror.com/lodash.isplainobject/-/lodash.isplainobject-4.0.6.tgz",
      "integrity": "sha512-oSXzaWypCMHkPC3NvBEaPHf0KsA5mvPrOPgQWDsbg8n7orZ290M0BmC/jgRZ4vcJ6DTAhjrsSYgdsW/F+MFOBA==",
      "license": "MIT"
    },
    "node_modules/lodash.isstring": {
      "version": "4.0.1",
      "resolved": "https://registry.npmmirror.com/lodash.isstring/-/lodash.isstring-4.0.1.tgz",
      "integrity": "sha512-0wJxfxH1wgO3GrbuP+dTTk7op+6L41QCXbGINEmD+ny/G/eCqGzxyCsh7159S+mgDDcoarnBw6PC1PS5+wUGgw==",
      "license": "MIT"
    },
    "node_modules/lodash.once": {
      "version": "4.1.1",
      "resolved": "https://registry.npmmirror.com/lodash.once/-/lodash.once-4.1.1.tgz",
      "integrity": "sha512-Sb487aTOCr9drQVL8pIxOzVhafOjZN9UU54hiN8PU3uAiSV7lx1yYNpbNmex2PK6dSJoNTSJUUswT651yww3Mg==",
      "license": "MIT"
    },
    "node_modules/math-intrinsics": {
      "version": "1.1.0",
      "resolved": "https://registry.npmmirror.com/math-intrinsics/-/math-intrinsics-1.1.0.tgz",
      "integrity": "sha512-/IXtbwEk5HTPyEwyKX6hGkYXxM9nbj64B+ilVJnC/R6B0pH5G4V3b0pVbL7DBj4tkhBAppbQUlf6F6Xl9LHu1g==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/methods": {
      "version": "1.1.2",
      "resolved": "https://registry.npmmirror.com/methods/-/methods-1.1.2.tgz",
      "integrity": "sha512-iclAHeNqNm68zFtnZ0e+1L2yUIdvzNoauKU4WBA3VvH/vPFieF7qfRlwUZU+DA9P9bPXIS90ulxoUoCH23sV2w==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/mime": {
      "version": "2.6.0",
      "resolved": "https://registry.npmmirror.com/mime/-/mime-2.6.0.tgz",
      "integrity": "sha512-USPkMeET31rOMiarsBNIHZKLGgvKc/LrjofAnBlOttf5ajRvqiRA8QsenbcooctK6d6Ts6aqZXBA+XbkKthiQg==",
      "license": "MIT",
      "bin": {
        "mime": "cli.js"
      },
      "engines": {
        "node": ">=4.0.0"
      }
    },
    "node_modules/mime-db": {
      "version": "1.52.0",
      "resolved": "https://registry.npmmirror.com/mime-db/-/mime-db-1.52.0.tgz",
      "integrity": "sha512-sPU4uV7dYlvtWJxwwxHD0PuihVNiE7TyAbQ5SWxDCB9mUYvOgroQOwYQQOKPJ8CIbE+1ETVlOoK1UC2nU3gYvg==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/mime-types": {
      "version": "2.1.35",
      "resolved": "https://registry.npmmirror.com/mime-types/-/mime-types-2.1.35.tgz",
      "integrity": "sha512-ZDY+bPm5zTTF+YpCrAU9nK0UgICYPT0QtT1NZWFv4s++TNkcgVaT0g6+4R2uI4MjQjzysHB1zxuWL50hzaeXiw==",
      "license": "MIT",
      "dependencies": {
        "mime-db": "1.52.0"
      },
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/ms": {
      "version": "2.1.3",
      "resolved": "https://registry.npmmirror.com/ms/-/ms-2.1.3.tgz",
      "integrity": "sha512-6FlzubTLZG3J2a/NVCAleEhjzq5oxgHyaCU9yYXvcLsvoVaHJq/s5xXI6/XXP6tz7R9xAOtHnSO/tXtF3WRTlA==",
      "license": "MIT"
    },
    "node_modules/object-inspect": {
      "version": "1.13.4",
      "resolved": "https://registry.npmmirror.com/object-inspect/-/object-inspect-1.13.4.tgz",
      "integrity": "sha512-W67iLl4J2EXEGTbfeHCffrjDfitvLANg0UlX3wFUUSTx92KXRFegMHUVgSqE+wvhAbi4WqjGg9czysTV2Epbew==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/once": {
      "version": "1.4.0",
      "resolved": "https://registry.npmmirror.com/once/-/once-1.4.0.tgz",
      "integrity": "sha512-lNaJgI+2Q5URQBkccEKHTQOPaXdUxnZZElQTZY0MFUAuaEqe1E+Nyvgdz/aIyNi6Z9MzO5dv1H8n58/GELp3+w==",
      "license": "ISC",
      "dependencies": {
        "wrappy": "1"
      }
    },
    "node_modules/proxy-from-env": {
      "version": "1.1.0",
      "resolved": "https://registry.npmmirror.com/proxy-from-env/-/proxy-from-env-1.1.0.tgz",
      "integrity": "sha512-D+zkORCbA9f1tdWRK0RaCR3GPv50cMxcrz4X8k5LTSUD1Dkw47mKJEZQNunItRTkWwgtaUSo1RVFRIG9ZXiFYg==",
      "license": "MIT"
    },
    "node_modules/qs": {
      "version": "6.14.0",
      "resolved": "https://registry.npmmirror.com/qs/-/qs-6.14.0.tgz",
      "integrity": "sha512-YWWTjgABSKcvs/nWBi9PycY/JiPJqOD4JA6o9Sej2AtvSGarXxKC3OQSk4pAarbdQlKAh5D4FCQkJNkW+GAn3w==",
      "license": "BSD-3-Clause",
      "dependencies": {
        "side-channel": "^1.1.0"
      },
      "engines": {
        "node": ">=0.6"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/safe-buffer": {
      "version": "5.2.1",
      "resolved": "https://registry.npmmirror.com/safe-buffer/-/safe-buffer-5.2.1.tgz",
      "integrity": "sha512-rp3So07KcdmmKbGvgaNxQSJr7bGVSVk5S9Eq1F+ppbRo70+YeaDxkw5Dd8NPN+GD6bjnYm2VuPuCXmpuYvmCXQ==",
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/feross"
        },
        {
          "type": "patreon",
          "url": "https://www.patreon.com/feross"
        },
        {
          "type": "consulting",
          "url": "https://feross.org/support"
        }
      ],
      "license": "MIT"
    },
    "node_modules/semver": {
      "version": "7.7.2",
      "resolved": "https://registry.npmmirror.com/semver/-/semver-7.7.2.tgz",
      "integrity": "sha512-RF0Fw+rO5AMf9MAyaRXI4AV0Ulj5lMHqVxxdSgiVbixSCXoEmmX/jk0CuJw4+3SqroYO9VoUh+HcuJivvtJemA==",
      "license": "ISC",
      "bin": {
        "semver": "bin/semver.js"
      },
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/side-channel": {
      "version": "1.1.0",
      "resolved": "https://registry.npmmirror.com/side-channel/-/side-channel-1.1.0.tgz",
      "integrity": "sha512-ZX99e6tRweoUXqR+VBrslhda51Nh5MTQwou5tnUDgbtyM0dBgmhEDtWGP/xbKn6hqfPRHujUNwz5fy/wbbhnpw==",
      "license": "MIT",
      "dependencies": {
        "es-errors": "^1.3.0",
        "object-inspect": "^1.13.3",
        "side-channel-list": "^1.0.0",
        "side-channel-map": "^1.0.1",
        "side-channel-weakmap": "^1.0.2"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/side-channel-list": {
      "version": "1.0.0",
      "resolved": "https://registry.npmmirror.com/side-channel-list/-/side-channel-list-1.0.0.tgz",
      "integrity": "sha512-FCLHtRD/gnpCiCHEiJLOwdmFP+wzCmDEkc9y7NsYxeF4u7Btsn1ZuwgwJGxImImHicJArLP4R0yX4c2KCrMrTA==",
      "license": "MIT",
      "dependencies": {
        "es-errors": "^1.3.0",
        "object-inspect": "^1.13.3"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/side-channel-map": {
      "version": "1.0.1",
      "resolved": "https://registry.npmmirror.com/side-channel-map/-/side-channel-map-1.0.1.tgz",
      "integrity": "sha512-VCjCNfgMsby3tTdo02nbjtM/ewra6jPHmpThenkTYh8pG9ucZ/1P8So4u4FGBek/BjpOVsDCMoLA/iuBKIFXRA==",
      "license": "MIT",
      "dependencies": {
        "call-bound": "^1.0.2",
        "es-errors": "^1.3.0",
        "get-intrinsic": "^1.2.5",
        "object-inspect": "^1.13.3"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/side-channel-weakmap": {
      "version": "1.0.2",
      "resolved": "https://registry.npmmirror.com/side-channel-weakmap/-/side-channel-weakmap-1.0.2.tgz",
      "integrity": "sha512-WPS/HvHQTYnHisLo9McqBHOJk2FkHO/tlpvldyrnem4aeQp4hai3gythswg6p01oSoTl58rcpiFAjF2br2Ak2A==",
      "license": "MIT",
      "dependencies": {
        "call-bound": "^1.0.2",
        "es-errors": "^1.3.0",
        "get-intrinsic": "^1.2.5",
        "object-inspect": "^1.13.3",
        "side-channel-map": "^1.0.1"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/superagent": {
      "version": "8.0.6",
      "resolved": "https://registry.npmmirror.com/superagent/-/superagent-8.0.6.tgz",
      "integrity": "sha512-HqSe6DSIh3hEn6cJvCkaM1BLi466f1LHi4yubR0tpewlMpk4RUFFy35bKz8SsPBwYfIIJy5eclp+3tCYAuX0bw==",
      "deprecated": "Please upgrade to superagent v10.2.2+, see release notes at https://github.com/forwardemail/superagent/releases/tag/v10.2.2 - maintenance is supported by Forward Email @ https://forwardemail.net",
      "license": "MIT",
      "dependencies": {
        "component-emitter": "^1.3.0",
        "cookiejar": "^2.1.3",
        "debug": "^4.3.4",
        "fast-safe-stringify": "^2.1.1",
        "form-data": "^4.0.0",
        "formidable": "^2.1.1",
        "methods": "^1.1.2",
        "mime": "2.6.0",
        "qs": "^6.11.0",
        "semver": "^7.3.8"
      },
      "engines": {
        "node": ">=6.4.0 <13 || >=14"
      }
    },
    "node_modules/tweetnacl": {
      "version": "1.0.3",
      "resolved": "https://registry.npmmirror.com/tweetnacl/-/tweetnacl-1.0.3.tgz",
      "integrity": "sha512-6rt+RN7aOi1nGMyC4Xa5DdYiukl2UWCbcJft7YhxReBGQD7OAM8Pbxw6YMo4r2diNEA8FEmu32YOn9rhaiE5yw==",
      "license": "Unlicense"
    },
    "node_modules/undici-types": {
      "version": "7.10.0",
      "resolved": "https://registry.npmmirror.com/undici-types/-/undici-types-7.10.0.tgz",
      "integrity": "sha512-t5Fy/nfn+14LuOc2KNYg75vZqClpAiqscVvMygNnlsHBFpSXdJaYtXMcdNLpl/Qvc3P2cB3s6lOV51nqsFq4ag==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/wechatpay-node-v3": {
      "version": "2.2.1",
      "resolved": "https://registry.npmmirror.com/wechatpay-node-v3/-/wechatpay-node-v3-2.2.1.tgz",
      "integrity": "sha512-z+n8Mrzn0UNoLJPBRrY8ZG6yo9xxNihlGvwvAbV8Nlnm4tTap2UjwIikGkhryC8gOmwrlvJfSUd+x1cK3ks1hA==",
      "license": "MIT",
      "dependencies": {
        "@fidm/x509": "1.2.1",
        "superagent": "8.0.6"
      }
    },
    "node_modules/wrappy": {
      "version": "1.0.2",
      "resolved": "https://registry.npmmirror.com/wrappy/-/wrappy-1.0.2.tgz",
      "integrity": "sha512-l4Sp/DRseor9wL6EvV2+TuQn63dMkPjZ/sp9XkghTEbV9KlPS1xUsZ3u7/IQO4wxtcFB4bgpQPRcR3QCvezPcQ==",
      "license": "ISC"
    }
  }
}


================================================================================
### FILE: package.json
================================================================================

{
  "dependencies": {
    "axios": "^1.11.0",
    "dotenv": "^17.2.2",
    "jsonwebtoken": "^9.0.2",
    "wechatpay-node-v3": "^2.2.1"
  },
  "devDependencies": {
    "@types/jsonwebtoken": "^9.0.10"
  }
}


================================================================================
### FILE: project.private.config.json
================================================================================

{
  "setting": {
    "compileHotReLoad": true,
    "urlCheck": false,
    "coverView": true,
    "lazyloadPlaceholderEnable": false,
    "skylineRenderEnable": false,
    "preloadBackgroundData": false,
    "autoAudits": false,
    "useApiHook": true,
    "useApiHostProcess": true,
    "showShadowRootInWxmlPanel": true,
    "useStaticServer": false,
    "useLanDebug": false,
    "showES6CompileOption": false,
    "checkInvalidKey": true,
    "ignoreDevUnusedFiles": true,
    "bigPackageSizeSupport": false,
    "useIsolateContext": true
  },
  "condition": {},
  "description": "é¡¹ç›®ç§æœ‰é…ç½®æ–‡ä»¶ã€‚æ­¤æ–‡ä»¶ä¸­çš„å†…å®¹å°†è¦†ç›– project.config.json ä¸­çš„ç›¸åŒå­—æ®µã€‚é¡¹ç›®çš„æ”¹åŠ¨ä¼˜å…ˆåŒæ­¥åˆ°æ­¤æ–‡ä»¶ä¸­ã€‚è¯¦è§æ–‡æ¡£ï¼šhttps://developers.weixin.qq.com/miniprogram/dev/devtools/projectconfig.html",
  "projectname": "%E5%9B%BE%E4%B9%A6",
  "libVersion": "3.9.3"
}


================================================================================
### FILE: update_user_metrics.js
================================================================================

const { PrismaClient } = require('@prisma/client');

const prisma = new PrismaClient();

async function updateUserMetrics() {
  try {
    // Get the current user count
    const userCount = await prisma.user.count();
    console.log(`Found ${userCount} users in database`);

    // Update the metrics by triggering the metrics object
    // Since we can't directly access the metrics object, we'll make an HTTP request
    const response = await fetch('http://localhost:8080/metrics');
    const metrics = await response.text();

    console.log('Current user metrics:');
    console.log(metrics.split('\n').filter(line => line.includes('bookworm_users_logged_in_total')));

  } catch (error) {
    console.error('Error updating metrics:', error);
  } finally {
    await prisma.$disconnect();
  }
}

updateUserMetrics();


================================================================================
### FILE: å®¡æŸ¥ (v2 - å¸¦è„±æ•åŠŸèƒ½).py
================================================================================

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Bookworm é¡¹ç›®ä»£ç å®¡æŸ¥æ–‡ä»¶ç”Ÿæˆå™¨ (v3 - æ™ºèƒ½åŒ…å«æœºåˆ¶)
åŸºäºæ–‡ä»¶æ‰©å±•åå’Œè·¯å¾„æ¨¡å¼æ™ºèƒ½åŒ…å«æ‰€æœ‰æ ¸å¿ƒä¸šåŠ¡ä»£ç ï¼Œé¿å…é—æ¼å…³é”®æ–‡ä»¶ã€‚

ä½¿ç”¨æ–¹æ³•:
1. å°†æ­¤è„šæœ¬ä¿å­˜ä¸º `å®¡æŸ¥.py` æ”¾åœ¨é¡¹ç›®æ ¹ç›®å½•ã€‚
2. åœ¨ç»ˆç«¯ä¸­è¿è¡Œ: `python3 å®¡æŸ¥.py`

è¾“å‡º:
    bookworm_code_review.txt
"""

import os
import datetime
import fnmatch

# ==============================================================================
# æ™ºèƒ½æ–‡ä»¶åŒ…å«è§„åˆ™ - åŸºäºæ‰©å±•åå’Œè·¯å¾„æ¨¡å¼
# ==============================================================================

# æ ¸å¿ƒä¸šåŠ¡æ–‡ä»¶æ‰©å±•å (ç²¾ç®€ç‰ˆ)
CORE_EXTENSIONS = {
    '.ts', '.js', '.prisma', '.md', '.env'
}

# å…³é”®ä¸šåŠ¡æ–‡ä»¶è·¯å¾„ (åªåŒ…å«æ ¸å¿ƒé€»è¾‘)
ESSENTIAL_PATTERNS = [
    'CLAUDE.md',
    'bookworm-backend/src/index.ts',
    'bookworm-backend/src/config.ts',
    'bookworm-backend/src/db.ts',
    'bookworm-backend/src/errors.ts',
    'bookworm-backend/src/services/*.ts',
    'bookworm-backend/prisma/schema.prisma',
    'bookworm-backend/.env*',
    'bookworm-backend/package.json',
    'bookworm-backend/src/jobs/*.ts',
    'bookworm-backend/src/plugins/*.ts',
    # Re-include the most critical integration test as a representative sample
    'bookworm-backend/src/tests/order.integration.test.ts',
    'bookworm-backend/src/tests/concurrent-order-control.integration.test.ts',
    'bookworm-backend/src/tests/paymentSecurity.integration.test.ts',
    # Also include the setup files, they provide critical context on HOW tests are run
    'bookworm-backend/src/tests/database-integration-setup.ts',
    'bookworm-backend/src/tests/globalSetup.ts',
    'miniprogram/app.js',
    'miniprogram/app.json',
    'miniprogram/config.js',
    'miniprogram/utils/api.js',
    'miniprogram/utils/auth.js',
    'miniprogram/pages/*/index.js'
]

# æ˜ç¡®æ’é™¤çš„æ–‡ä»¶ç±»å‹ (å‡å°‘å™ªéŸ³)
EXCLUDE_EXTENSIONS = {
    '.wxml', '.wxss', '.json', '.css', '.html', '.sql'
}

# æ’é™¤ç‰¹å®šæ–‡ä»¶
EXCLUDE_SPECIFIC = {
    'miniprogram/sitemap.json',
    'project.config.json',
    '.eslintrc.js',
    'bookworm-backend/public/*',
    'bookworm-backend/src/tests/*'
}

# æ’é™¤ç›®å½•å’Œæ–‡ä»¶æ¨¡å¼ (çœŸæ­£æ— ç”¨çš„æ–‡ä»¶)
EXCLUDE_DIRS = {
    'node_modules', '.git', '__pycache__', 'dist', 'build', '.idea', 
    '.vscode', 'miniprogram_npm', '.nyc_output', 'coverage'
}

EXCLUDE_FILES = {
    'package-lock.json', 'yarn.lock', '.DS_Store', 'Thumbs.db',
    'project.private.config.json', '*.log', '*.tmp', '*.cache'
}

# æ•æ„Ÿæ–‡ä»¶åˆ—è¡¨ (è¿™äº›æ–‡ä»¶çš„å†…å®¹å°†è¢«è„±æ•)
SENSITIVE_FILES = {
    'bookworm-backend/.env'
}

def should_include_dir(dir_path):
    dir_name = os.path.basename(dir_path)
    return dir_name not in EXCLUDE_DIRS and not dir_name.startswith('.')

def matches_any_pattern(file_path, patterns):
    """æ£€æŸ¥æ–‡ä»¶è·¯å¾„æ˜¯å¦åŒ¹é…ä»»ä½•ä¸€ä¸ªglobæ¨¡å¼"""
    for pattern in patterns:
        if fnmatch.fnmatch(file_path, pattern):
            return True
    return False

def should_include_file(file_path, project_root):
    """ç²¾ç®€åˆ¤æ–­æ–‡ä»¶æ˜¯å¦åº”è¯¥åŒ…å«åœ¨å®¡æŸ¥ä¸­ - åªè¦æ ¸å¿ƒä¸šåŠ¡é€»è¾‘"""
    # è½¬æ¢ä¸ºç›¸å¯¹è·¯å¾„
    try:
        rel_path = os.path.relpath(file_path, project_root).replace(os.sep, '/')
    except ValueError:
        return False
    
    # æ’é™¤æ˜ç¡®ä¸éœ€è¦çš„æ–‡ä»¶
    for exclude_pattern in EXCLUDE_SPECIFIC:
        if fnmatch.fnmatch(rel_path, exclude_pattern):
            return False
    
    # æ’é™¤ç‰¹å®šæ‰©å±•å
    _, ext = os.path.splitext(file_path)
    if ext.lower() in EXCLUDE_EXTENSIONS:
        return False
    
    # æ£€æŸ¥æ˜¯å¦åœ¨æ’é™¤æ–‡ä»¶åˆ—è¡¨ä¸­
    filename = os.path.basename(file_path)
    for exclude_pattern in EXCLUDE_FILES:
        if fnmatch.fnmatch(filename, exclude_pattern):
            return False
    
    # åªåŒ…å«æ ¸å¿ƒæ‰©å±•åçš„æ–‡ä»¶
    if ext.lower() in CORE_EXTENSIONS:
        # ä½†å¿…é¡»åŒ¹é…å…³é”®è·¯å¾„æ¨¡å¼
        return matches_any_pattern(rel_path, ESSENTIAL_PATTERNS)
    
    return False

def collect_files_to_review(project_root):
    """æ”¶é›†æ‰€æœ‰éœ€è¦å®¡æŸ¥çš„æ–‡ä»¶"""
    files_to_review = set()
    
    for root, dirs, files in os.walk(project_root):
        # è¿‡æ»¤ç›®å½•
        dirs[:] = [d for d in dirs if should_include_dir(os.path.join(root, d))]
        
        for file in files:
            file_path = os.path.join(root, file)
            if should_include_file(file_path, project_root):
                rel_path = os.path.relpath(file_path, project_root)
                files_to_review.add(rel_path)
    
    return sorted(files_to_review)

def get_file_tree(root_path, prefix=""):
    items = []
    try:
        entries = sorted([e for e in os.listdir(root_path) if e not in EXCLUDE_FILES and should_include_dir(os.path.join(root_path, e))])
        for i, entry_name in enumerate(entries):
            is_last = i == len(entries) - 1
            connector = "â””â”€â”€ " if is_last else "â”œâ”€â”€ "
            full_path = os.path.join(root_path, entry_name)
            is_dir = os.path.isdir(full_path)
            items.append(f"{prefix}{connector}{entry_name}{'/' if is_dir else ''}")
            if is_dir:
                new_prefix = prefix + ("    " if is_last else "â”‚   ")
                items.extend(get_file_tree(full_path, new_prefix))
    except PermissionError:
        items.append(f"{prefix}â””â”€â”€ [Permission Denied]")
    return items

def read_file_content(file_path):
    encodings = ['utf-8', 'gbk', 'latin-1']
    for encoding in encodings:
        try:
            with open(file_path, 'r', encoding=encoding) as f:
                return f.read()
        except Exception:
            continue
    return f"[Error: Unable to decode file '{os.path.basename(file_path)}']"

def sanitize_sensitive_content(rel_path, content):
    """å¦‚æœæ–‡ä»¶åœ¨æ•æ„Ÿåˆ—è¡¨ä¸­ï¼Œåˆ™å¯¹å…¶å†…å®¹è¿›è¡Œè„±æ•å¤„ç†"""
    normalized_path = rel_path.replace(os.sep, '/')
    if normalized_path in SENSITIVE_FILES:
        lines = content.strip().split('\n')
        sanitized_lines = []
        for line in lines:
            if line.strip().startswith('#') or not line.strip():
                sanitized_lines.append(line)
            else:
                parts = line.split('=', 1)
                if len(parts) == 2:
                    key = parts[0]
                    sanitized_lines.append(f"{key}=[REDACTED]")
                else:
                    sanitized_lines.append("[REDACTED]")
        return f"#\n# CONTENT OF SENSITIVE FILE '{normalized_path}' HAS BEEN REDACTED\n#\n" + "\n".join(sanitized_lines)
    return content

def generate_core_review_file(project_root):
    output_filename = 'bookworm_code_review.txt'
    output_filepath = os.path.join(project_root, output_filename)
    
    # æ”¶é›†æ‰€æœ‰è¦å®¡æŸ¥çš„æ–‡ä»¶
    files_to_review = collect_files_to_review(project_root)
    
    with open(output_filepath, 'w', encoding='utf-8') as f:
        f.write("=" * 80 + "\nBOOKWORM PROJECT - COMPREHENSIVE CODE REVIEW\n" + "=" * 80 + "\n")
        f.write(f"Generated on: {datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
        f.write(f"Mode: Essential files only - Core business logic and architecture.\n")
        f.write(f"Total files included: {len(files_to_review)} (ç²¾ç®€ç‰ˆ)\n\n")

        f.write("### ğŸ“ PROJECT FILE TREE ###\n" + "-" * 40 + "\n")
        f.write(f"{os.path.basename(project_root)}/\n")
        for item in get_file_tree(project_root):
            f.write(item + "\n")
        f.write("\n\n")
        
        # æŒ‰ç±»å‹åˆ†ç»„æ˜¾ç¤ºæ–‡ä»¶åˆ—è¡¨
        backend_files = [f for f in files_to_review if f.startswith('bookworm-backend/')]
        frontend_files = [f for f in files_to_review if f.startswith('miniprogram/')]
        root_files = [f for f in files_to_review if '/' not in f]
        
        f.write(f"### ğŸ“‹ INCLUDED FILES SUMMARY ###\n" + "-" * 40 + "\n")
        f.write(f"Root files ({len(root_files)}): {', '.join(root_files)}\n")
        f.write(f"Backend files ({len(backend_files)}): {len(backend_files)} TypeScript/config files\n")
        f.write(f"Frontend files ({len(frontend_files)}): {len(frontend_files)} WeChat Mini Program files\n\n")
        
        f.write(f"### ğŸ“„ SOURCE CODE CONTENT ###\n" + "-" * 40 + "\n\n")

        for rel_path in files_to_review:
            full_path = os.path.join(project_root, rel_path)
            f.write("=" * 80 + f"\n### FILE: {rel_path}\n" + "=" * 80 + "\n\n")
            if os.path.exists(full_path) and os.path.isfile(full_path):
                content = read_file_content(full_path)
                sanitized_content = sanitize_sensitive_content(rel_path, content)
                f.write(sanitized_content.strip() + "\n\n\n")
            else:
                f.write(f"[FILE NOT FOUND]\n\n\n")

        f.write("=" * 80 + "\nCOMPREHENSIVE CODE REVIEW REPORT GENERATION COMPLETE.\n" + "=" * 80 + "\n")
    
    return output_filepath

def main():
    project_root = os.getcwd()
    print("[START] Generating core code review report for Bookworm...")
    try:
        output_file = generate_core_review_file(project_root)
        file_size = os.path.getsize(output_file)
        size_str = f"{file_size / 1024:.2f} KB" if file_size > 1024 else f"{file_size} bytes"
        files_count = len(collect_files_to_review(project_root))
        print(f"[SUCCESS] Comprehensive review report generated!")
        print(f"  - Output file: {os.path.basename(output_file)}")
        print(f"  - File size: {size_str}")
        print(f"  - Files included: {files_count} (smart inclusion algorithm)")
        print("[INFO] All core business files automatically detected and included.")
        print("[INFO] Sensitive files like '.env' have been automatically redacted.")
    except Exception as e:
        print(f"[ERROR] Failed to generate report: {e}")

if __name__ == "__main__":
    main()


================================================================================
### FILE: å®¡æŸ¥.py
================================================================================

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Bookworm é¡¹ç›®ä»£ç å®¡æŸ¥æ–‡ä»¶ç”Ÿæˆå™¨ (åŸå§‹ç‰ˆ - ä¸è„±æ•)
åŸºäºæ–‡ä»¶æ‰©å±•åå’Œè·¯å¾„æ¨¡å¼æ™ºèƒ½åŒ…å«æ‰€æœ‰æ ¸å¿ƒä¸šåŠ¡ä»£ç ï¼Œä¿æŒåŸå§‹æ•°æ®ä¸è„±æ•ã€‚

ä½¿ç”¨æ–¹æ³•:
1. å°†æ­¤è„šæœ¬ä¿å­˜ä¸º `å®¡æŸ¥.py` æ”¾åœ¨é¡¹ç›®æ ¹ç›®å½•ã€‚
2. åœ¨ç»ˆç«¯ä¸­è¿è¡Œ: `python3 å®¡æŸ¥.py`

è¾“å‡º:
    bookworm_code_review.txt
"""

import os
import datetime
import fnmatch

# ==============================================================================
# æ™ºèƒ½æ–‡ä»¶åŒ…å«è§„åˆ™ (v4 - å¥å£®ç‰ˆ)
# å“²å­¦: å¹¿æ³›åŒ…å«æ‰€æœ‰æ½œåœ¨çš„æºä»£ç å’Œé…ç½®æ–‡ä»¶ï¼Œç„¶åç²¾ç¡®æ’é™¤å·²çŸ¥çš„å™ªéŸ³ã€‚
# è¿™æ¯”ç»´æŠ¤ä¸€ä¸ªè„†å¼±çš„"å¿…è¦æ–‡ä»¶"ç™½åå•è¦å¥å£®å¾—å¤šã€‚
# ==============================================================================

# 1. å®šä¹‰ä»€ä¹ˆæ˜¯æºä»£ç /é…ç½®æ–‡ä»¶ (é€šè¿‡æ‰©å±•å)
#    è¿™äº›æ˜¯æˆ‘ä»¬å…³å¿ƒçš„ä¸œè¥¿ã€‚
SOURCE_CODE_EXTENSIONS = {
    '.ts', '.js', '.prisma', '.md', '.sql',  # Code & Schema
    '.json', '.env', '.toml', '.yml', '.yaml', # Configs
    '.py' # Include the script itself for context
}

# 2. å®šä¹‰ä»€ä¹ˆæ˜¯ç»å¯¹çš„å™ªéŸ³ (é€šè¿‡è·¯å¾„å’Œæ–‡ä»¶åæ¨¡å¼)
#    è¿™äº›ä¸œè¥¿æ°¸è¿œä¸åº”è¯¥å‡ºç°åœ¨å®¡æŸ¥æŠ¥å‘Šé‡Œã€‚
EXCLUDE_PATTERNS = [
    # ç›®å½•
    '**/node_modules/**',
    '**/.git/**',
    '**/dist/**',
    '**/build/**',
    '**/coverage/**',
    '**/.nyc_output/**',
    '**/miniprogram_npm/**',
    '**/.vscode/**',
    '**/.idea/**',
    '**/__pycache__/**',

    # é”æ–‡ä»¶å’Œç§æœ‰é…ç½®
    '**/package-lock.json',
    '**/yarn.lock',
    '**/project.private.config.json',

    # ç¼–è¯‘è¾“å‡ºæˆ–ç¼“å­˜
    '**/*.log',
    '**/*.tmp',
    '**/*.cache',
    '**/.DS_Store',

    # æ˜ç¡®ä¸å…³å¿ƒçš„å‰ç«¯èµ„æºå’Œé…ç½®æ–‡ä»¶
    'miniprogram/images/**',
    'miniprogram/**/*.wxml',
    'miniprogram/**/*.wxss',
    'miniprogram/sitemap.json',
    'project.config.json',
    '.eslintrc.js',
    'bookworm-backend/public/**',

    # æˆ‘ä»¬åªå…³å¿ƒé›†æˆæµ‹è¯•ï¼Œå•å…ƒæµ‹è¯•å™ªéŸ³å¤ªå¤§
    'bookworm-backend/src/tests/*.test.ts',
    'bookworm-backend/src/tests/__mocks__/**',
    'bookworm-backend/vitest.config.ts',
    'bookworm-backend/vitest.integration.config.ts',
    'bookworm-backend/vitest.database-integration.config.ts'
]

# 3. å®šä¹‰æ•æ„Ÿæ–‡ä»¶ (å†…å®¹éœ€è¦è„±æ•)
#    è¿™ä¸ªç‰ˆæœ¬æˆ‘ä»¬å…ˆä¸è„±æ•ï¼Œä½†ä¿ç•™åˆ—è¡¨ä»¥ä¾¿åˆ‡æ¢ã€‚
SENSITIVE_FILES = {
    # 'bookworm-backend/.env' # æš‚æ—¶æ³¨é‡Šæ‰ï¼Œä»¥ä¾¿ä½ çœ‹åˆ°å®Œæ•´å†…å®¹
}

def should_include_dir(dir_path):
    """A robust check to prevent descending into known garbage directories."""
    dir_name = os.path.basename(dir_path)
    # These are the top-level directories we ALWAYS want to skip.
    garbage_dirs = {'node_modules', '.git', 'dist', 'build', 'coverage', '.nyc_output', 'miniprogram_npm', '.vscode', '.idea', '__pycache__'}
    if dir_name in garbage_dirs:
        return False
    return True

def matches_any_pattern(file_path, patterns):
    """æ£€æŸ¥æ–‡ä»¶è·¯å¾„æ˜¯å¦åŒ¹é…ä»»ä½•ä¸€ä¸ªglobæ¨¡å¼"""
    for pattern in patterns:
        if fnmatch.fnmatch(file_path, pattern):
            return True
    return False

def should_include_file(file_path, project_root):
    """v4å¥å£®ç‰ˆæœ¬ï¼šå…ˆåŒ…å«æ‰€æœ‰æºä»£ç ï¼Œç„¶åæ’é™¤å™ªéŸ³"""
    # è½¬æ¢ä¸ºç›¸å¯¹è·¯å¾„
    try:
        rel_path = os.path.relpath(file_path, project_root).replace(os.sep, '/')
    except ValueError:
        return False

    # ç¬¬ä¸€æ­¥ï¼šæ£€æŸ¥æ˜¯å¦æ˜¯æˆ‘ä»¬å…³å¿ƒçš„æºä»£ç æ–‡ä»¶ç±»å‹
    _, ext = os.path.splitext(file_path)
    if ext.lower() not in SOURCE_CODE_EXTENSIONS:
        return False

    # ç¬¬äºŒæ­¥ï¼šæ£€æŸ¥æ˜¯å¦åŒ¹é…ä»»ä½•æ’é™¤æ¨¡å¼
    for exclude_pattern in EXCLUDE_PATTERNS:
        if fnmatch.fnmatch(rel_path, exclude_pattern):
            return False

    # å¦‚æœæ—¢æ˜¯æºä»£ç æ–‡ä»¶ï¼Œåˆä¸åŒ¹é…æ’é™¤æ¨¡å¼ï¼Œå°±åŒ…å«å®ƒ
    return True

def collect_files_to_review(project_root):
    """æ”¶é›†æ‰€æœ‰éœ€è¦å®¡æŸ¥çš„æ–‡ä»¶"""
    files_to_review = set()
    
    for root, dirs, files in os.walk(project_root):
        # è¿‡æ»¤ç›®å½•
        dirs[:] = [d for d in dirs if should_include_dir(os.path.join(root, d))]
        
        for file in files:
            file_path = os.path.join(root, file)
            if should_include_file(file_path, project_root):
                rel_path = os.path.relpath(file_path, project_root)
                files_to_review.add(rel_path)
    
    return sorted(files_to_review)

def get_file_tree(root_path, prefix=""):
    items = []
    try:
        entries = sorted(os.listdir(root_path))
        
        filtered_entries = [
            e for e in entries 
            if os.path.join(root_path, e) not in EXCLUDE_FILES
        ]
        
        dirs = [d for d in filtered_entries if os.path.isdir(os.path.join(root_path, d)) and should_include_dir(d)]
        files = [f for f in filtered_entries if os.path.isfile(os.path.join(root_path, f)) and f not in EXCLUDE_FILES]
        
        all_entries = dirs + files
        for i, entry_name in enumerate(all_entries):
            is_last = i == len(all_entries) - 1
            connector = "â””â”€â”€ " if is_last else "â”œâ”€â”€ "
            items.append(f"{prefix}{connector}{entry_name}{'/' if entry_name in dirs else ''}")
            
            if entry_name in dirs:
                new_prefix = prefix + ("    " if is_last else "â”‚   ")
                items.extend(get_file_tree(os.path.join(root_path, entry_name), new_prefix))
    except PermissionError:
        items.append(f"{prefix}â””â”€â”€ [Permission Denied]")
    return items

def read_file_content(file_path):
    encodings = ['utf-8', 'gbk', 'latin-1']
    for encoding in encodings:
        try:
            with open(file_path, 'r', encoding=encoding) as f:
                return f.read()
        except Exception:
            continue
    return f"[Error: Unable to decode file '{os.path.basename(file_path)}' with common encodings]"

def generate_core_review_file(project_root):
    output_filename = 'bookworm_code_review.txt'
    output_filepath = os.path.join(project_root, output_filename)
    
    # æ”¶é›†æ‰€æœ‰è¦å®¡æŸ¥çš„æ–‡ä»¶
    files_to_review = collect_files_to_review(project_root)
    
    with open(output_filepath, 'w', encoding='utf-8') as f:
        f.write("=" * 80 + "\nBOOKWORM PROJECT - ESSENTIAL CODE REVIEW (UNREDACTED)\n" + "=" * 80 + "\n")
        f.write(f"Generated on: {datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
        f.write(f"Mode: Essential files only - Core business logic with original data.\n")
        f.write(f"Total files included: {len(files_to_review)} (ç²¾ç®€ç‰ˆ)\n\n")

        # f.write("### ğŸ“ PROJECT FILE TREE ###\n" + "-" * 40 + "\n")
        # f.write(f"{os.path.basename(project_root)}/\n")
        # for item in get_file_tree(project_root):
        #     f.write(item + "\n")
        # f.write("\n\n")
        
        # æŒ‰ç±»å‹åˆ†ç»„æ˜¾ç¤ºæ–‡ä»¶åˆ—è¡¨
        backend_files = [f for f in files_to_review if f.startswith('bookworm-backend')]
        frontend_files = [f for f in files_to_review if f.startswith('miniprogram')]
        root_files = [f for f in files_to_review if os.sep not in f and '/' not in f]
        
        f.write(f"### ğŸ“‹ INCLUDED FILES SUMMARY ###\n" + "-" * 40 + "\n")
        f.write(f"Root files ({len(root_files)}): {', '.join(root_files) if root_files else 'None'}\n")
        f.write(f"Backend files ({len(backend_files)}): {len(backend_files)} TypeScript/config files\n")
        f.write(f"Frontend files ({len(frontend_files)}): {len(frontend_files)} WeChat Mini Program files\n\n")
        
        f.write(f"### ğŸ“„ SOURCE CODE CONTENT ###\n" + "-" * 40 + "\n\n")

        for rel_path in files_to_review:
            full_path = os.path.join(project_root, rel_path)
            f.write("=" * 80 + f"\n### FILE: {rel_path}\n" + "=" * 80 + "\n\n")
            if os.path.exists(full_path) and os.path.isfile(full_path):
                content = read_file_content(full_path)
                f.write(content.strip() + "\n\n\n")
            else:
                f.write(f"[FILE NOT FOUND]\n\n\n")

        f.write("=" * 80 + "\nESSENTIAL CODE REVIEW REPORT GENERATION COMPLETE.\n" + "=" * 80 + "\n")
    
    return output_filepath

def main():
    project_root = os.getcwd()
    print("[START] Generating essential code review report for Bookworm (UNREDACTED)...")
    try:
        output_file = generate_core_review_file(project_root)
        files_count = len(collect_files_to_review(project_root))
        file_size = os.path.getsize(output_file)
        size_str = f"{file_size / 1024:.2f} KB" if file_size > 1024 else f"{file_size} bytes"
        print(f"[SUCCESS] Essential review report generated!")
        print(f"  - Output file: {os.path.basename(output_file)}")
        print(f"  - File size: {size_str}")
        print(f"  - Files included: {files_count} (smart inclusion algorithm)")
        print("[INFO] All core business files automatically detected and included.")
        print("[WARNING] This version contains original data - DO NOT share externally.")
    except Exception as e:
        print(f"[ERROR] Failed to generate report: {e}")

if __name__ == "__main__":
    main()


================================================================================
ESSENTIAL CODE REVIEW REPORT GENERATION COMPLETE.
================================================================================
