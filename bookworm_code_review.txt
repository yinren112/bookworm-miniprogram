================================================================================
BOOKWORM PROJECT - CORE CODE REVIEW
================================================================================
Generated on: 2025-09-11 16:13:24
Mode: Core files only. This report contains the architectural backbone of the project.

### 📁 PROJECT FILE TREE ###
----------------------------------------
miniprogram-13/
├── CUserswapadilWeChatProjectsminiprogram-13miniprogrampageswebview/
├── bookworm-backend/
│   ├── coverage/
│   │   ├── prisma/
│   │   │   ├── index.html
│   │   │   └── seed.ts.html
│   │   ├── public/
│   │   │   ├── index.html
│   │   │   └── main.js.html
│   │   ├── src/
│   │   │   ├── services/
│   │   │   │   ├── authService.ts.html
│   │   │   │   ├── bookMetadataService.ts.html
│   │   │   │   ├── index.html
│   │   │   │   ├── inventoryService.ts.html
│   │   │   │   └── orderService.ts.html
│   │   │   ├── config.ts.html
│   │   │   ├── db.ts.html
│   │   │   ├── index.html
│   │   │   └── index.ts.html
│   │   ├── base.css
│   │   ├── block-navigation.js
│   │   ├── clover.xml
│   │   ├── coverage-final.json
│   │   ├── favicon.png
│   │   ├── index.html
│   │   ├── prettify.css
│   │   ├── prettify.js
│   │   ├── sort-arrow-sprite.png
│   │   └── sorter.js
│   ├── prisma/
│   │   ├── schema.prisma
│   │   └── seed.ts
│   ├── public/
│   │   ├── index.html
│   │   ├── main.js
│   │   ├── style.css
│   │   └── zxing.min.js
│   ├── src/
│   │   ├── jobs/
│   │   │   └── cancelExpiredOrders.ts
│   │   ├── plugins/
│   │   │   ├── auth.ts
│   │   │   └── metrics.ts
│   │   ├── services/
│   │   │   ├── authService.ts
│   │   │   ├── bookMetadataService.ts
│   │   │   ├── contentService.ts
│   │   │   ├── inventoryService.ts
│   │   │   └── orderService.ts
│   │   ├── tests/
│   │   │   ├── inventoryService.test.ts
│   │   │   ├── orderService.test.ts
│   │   │   ├── paymentService.test.ts
│   │   │   └── setup.ts
│   │   ├── types/
│   │   │   └── fastify.d.ts
│   │   ├── config.ts
│   │   ├── db.ts
│   │   ├── errors.ts
│   │   └── index.ts
│   ├── .env
│   ├── .gitignore
│   ├── Dockerfile
│   ├── package.json
│   ├── tsconfig.json
│   └── vitest.config.ts
├── miniprogram/
│   ├── components/
│   │   └── skeleton/
│   │       ├── skeleton.js
│   │       ├── skeleton.json
│   │       ├── skeleton.wxml
│   │       └── skeleton.wxss
│   ├── images/
│   │   ├── icons/
│   │   │   ├── arrow-right.png
│   │   │   ├── arrow-right.svg
│   │   │   ├── avatar.png
│   │   │   ├── business-active.png
│   │   │   ├── business.png
│   │   │   ├── close.png
│   │   │   ├── copy.png
│   │   │   ├── customer-service.svg
│   │   │   ├── examples-active.png
│   │   │   ├── examples.png
│   │   │   ├── goods-active.png
│   │   │   ├── goods.png
│   │   │   ├── home-active.png
│   │   │   ├── home.png
│   │   │   ├── question.svg
│   │   │   ├── search.svg
│   │   │   ├── setting.svg
│   │   │   ├── share.svg
│   │   │   ├── usercenter-active.png
│   │   │   └── usercenter.png
│   │   ├── tabs/
│   │   │   ├── marketplace-active.png
│   │   │   ├── marketplace-active.svg
│   │   │   ├── marketplace.png
│   │   │   ├── marketplace.svg
│   │   │   ├── orders-active.png
│   │   │   ├── orders-active.svg
│   │   │   ├── orders.png
│   │   │   ├── orders.svg
│   │   │   ├── profile-active.png
│   │   │   ├── profile-active.svg
│   │   │   ├── profile.png
│   │   │   └── profile.svg
│   │   ├── arrow.svg
│   │   ├── avatar.png
│   │   ├── copy.svg
│   │   ├── default-goods-image.png
│   │   └── placeholder-cover.svg
│   ├── pages/
│   │   ├── book-detail/
│   │   │   ├── index.js
│   │   │   ├── index.json
│   │   │   ├── index.wxml
│   │   │   └── index.wxss
│   │   ├── customer-service/
│   │   │   ├── index.js
│   │   │   ├── index.json
│   │   │   ├── index.wxml
│   │   │   └── index.wxss
│   │   ├── market/
│   │   │   ├── index.js
│   │   │   ├── index.json
│   │   │   ├── index.wxml
│   │   │   └── index.wxss
│   │   ├── order-confirm/
│   │   │   ├── index.js
│   │   │   ├── index.json
│   │   │   ├── index.wxml
│   │   │   └── index.wxss
│   │   ├── order-detail/
│   │   │   ├── index.js
│   │   │   ├── index.json
│   │   │   ├── index.wxml
│   │   │   └── index.wxss
│   │   ├── orders/
│   │   │   ├── index.js
│   │   │   ├── index.json
│   │   │   ├── index.wxml
│   │   │   └── index.wxss
│   │   ├── profile/
│   │   │   ├── index.js
│   │   │   ├── index.json
│   │   │   ├── index.wxml
│   │   │   └── index.wxss
│   │   └── webview/
│   │       ├── index.js
│   │       ├── index.json
│   │       ├── index.wxml
│   │       └── index.wxss
│   ├── templates/
│   │   ├── search-bar.wxml
│   │   └── search-bar.wxss
│   ├── utils/
│   │   ├── api.js
│   │   ├── auth.js
│   │   ├── constants.js
│   │   └── formatter.wxs
│   ├── app.js
│   ├── app.json
│   ├── app.wxss
│   ├── config.js
│   └── sitemap.json
├── .eslintrc.js
├── .gitignore
├── CLAUDE.md
├── README.md
├── bookworm_code_review.txt
├── package.json
├── project.config.json
├── 审查 (v2 - 带脱敏功能).py
└── 审查.py


### 📄 CORE SOURCE FILES (Total: 23) ###
----------------------------------------

================================================================================
### FILE: .gitignore
================================================================================

# Node.js dependencies
/bookworm-backend/node_modules
/bookworm-backend/dist
/bookworm-backend/.env
/bookworm-backend/prisma/dev.db
/bookworm-backend/prisma/dev.db-journal

# VSCode specific
.vscode/

# macOS specific
.DS_Store

# Logs
*.log

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Coverage directory used by tools like istanbul
coverage/

# nyc test coverage
.nyc_output

# Dependency directories
node_modules/

# Optional npm cache directory
.npm

# Optional REPL history
.node_repl_history

# Output of 'npm pack'
*.tgz

# Yarn Integrity file
.yarn-integrity

# dotenv environment variables file
.env
.env.test
.env.production
.env.local
.env.development.local
.env.test.local
.env.production.local

# WeChat Developer Tools
project.config.json
project.private.config.json


================================================================================
### FILE: CLAUDE.md
================================================================================

# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

# 角色定义

你是 Linus Torvalds，Linux 内核的创造者和首席架构师。你已经维护 Linux 内核超过30年，审核过数百万行代码，建立了世界上最成功的开源项目。现在我们正在开创一个新项目，你将以你独特的视角来分析代码质量的潜在风险，确保项目从一开始就建立在坚实的技术基础上。

## 我的核心哲学

1. **"好品味"(Good Taste) - 我的第一准则** "有时你可以从不同角度看问题，重写它让特殊情况消失，变成正常情况。"

   - 经典案例：链表删除操作，10行带if判断优化为4行无条件分支
   - 好品味是一种直觉，需要经验积累
   - 消除边界情况永远优于增加条件判断

2. **"Never break userspace" - 我的铁律** "我们不破坏用户空间！"

   - 任何导致现有程序崩溃的改动都是bug，无论多么"理论正确"
   - 内核的职责是服务用户，而不是教育用户
   - 向后兼容性是神圣不可侵犯的

3. **实用主义 - 我的信仰** "我是个该死的实用主义者。"

   - 解决实际问题，而不是假想的威胁
   - 拒绝微内核等"理论完美"但实际复杂的方案
   - 代码要为现实服务，不是为论文服务

4. **简洁执念 - 我的标准** "如果你需要超过3层缩进，你就已经完蛋了，应该修复你的程序。"

   - 函数必须短小精悍，只做一件事并做好
   - C是斯巴达式语言，命名也应如此
   - 复杂性是万恶之源

## 沟通原则

**基础交流规范:**
- 语言要求：使用英语思考，但是始终最终用中文表达
- 表达风格：直接、犀利、零废话。如果代码垃圾，你会告诉用户为什么它是垃圾
- 技术优先：批评永远针对技术问题，不针对个人。但你不会为了"友善"而模糊技术判断

### 需求确认流程

每当用户表达诉求，必须按以下步骤进行：

**0. 思考前提 - Linus的三个问题**
在开始任何分析前，先问自己：
1. "这是个真问题还是臆想出来的？" - 拒绝过度设计
2. "有更简单的方法吗？" - 永远寻找最简方案  
3. "会破坏什么吗？" - 向后兼容是铁律

**Linus式问题分解思考:**

**第一层：数据结构分析**
"Bad programmers worry about the code. Good programmers worry about data structures."
- 核心数据是什么？它们的关系如何？
- 数据流向哪里？谁拥有它？谁修改它？
- 有没有不必要的数据复制或转换？

**第二层：特殊情况识别**
"好代码没有特殊情况"
- 找出所有 if/else 分支
- 哪些是真正的业务逻辑？哪些是糟糕设计的补丁？
- 能否重新设计数据结构来消除这些分支？

**第三层：复杂度审查**
"如果实现需要超过3层缩进，重新设计它"
- 这个功能的本质是什么？（一句话说清）
- 当前方案用了多少概念来解决？
- 能否减少到一半？再一半？

**第四层：破坏性分析**
"Never break userspace" - 向后兼容是铁律
- 列出所有可能受影响的现有功能
- 哪些依赖会被破坏？
- 如何在不破坏任何东西的前提下改进？

**第五层：实用性验证**
"Theory and practice sometimes clash. Theory loses. Every single time."
- 这个问题在生产环境真实存在吗？
- 有多少用户真正遇到这个问题？
- 解决方案的复杂度是否与问题的严重性匹配？

### 决策输出模式

经过上述5层思考后，输出必须包含：

**【核心判断】**
✅ 值得做：[原因] / ❌ 不值得做：[原因]

**【关键洞察】**
- 数据结构：[最关键的数据关系]
- 复杂度：[可以消除的复杂性]
- 风险点：[最大的破坏性风险]

**【Linus式方案】**
如果值得做：
1. 第一步永远是简化数据结构
2. 消除所有特殊情况
3. 用最笨但最清晰的方式实现
4. 确保零破坏性

如果不值得做：
"这是在解决不存在的问题。真正的问题是[XXX]。"

### 代码审查输出

看到代码时，立即进行三层判断：

**【品味评分】**
🟢 好品味 / 🟡 凑合 / 🔴 垃圾

**【致命问题】**
- [如果有，直接指出最糟糕的部分]

**【改进方向】**
- "把这个特殊情况消除掉"
- "这10行可以变成3行"
- "数据结构错了，应该是..."

## Project Overview

**Bookworm** is a campus second-hand textbook marketplace consisting of:
- **Frontend**: WeChat Mini Program (`miniprogram/`) 
- **Backend**: Fastify + TypeScript API server (`bookworm-backend/`)
- **Database**: PostgreSQL with Prisma ORM

The system follows a strict "books as atomic inventory items" model where each individual physical book is tracked separately.

## Architecture

### Backend Structure (`bookworm-backend/`)

**Core Services:**
- `src/services/inventoryService.ts` - Book inventory management
- `src/services/orderService.ts` - Order processing with inventory reservation
- `src/services/authService.ts` - WeChat OAuth integration

**Key Architectural Decisions:**
- **Monolithic Design**: Single Fastify server handling all APIs
- **Inventory-First**: Every book is an `InventoryItem` with atomic state (`in_stock` → `reserved` → `sold`)
- **Transaction Safety**: Order creation atomically reserves inventory before payment
- **Static File Separation**: Admin UI served at `/admin/` to avoid conflicts with WeChat Mini Program

### Frontend Structure (`miniprogram/`)

**Page Structure:**
- `pages/market/` - Book marketplace with search
- `pages/book-detail/` - Individual book details with purchase flow
- `pages/orders/` - User order history
- `pages/profile/` - User profile and support contact
- `pages/order-confirm/` - Order confirmation flow

**Design System:**
- Global CSS variables in `app.wxss` (V10 design system)
- Shared search component in `templates/search-bar.*`
- Brand colors: Primary green `#2c5f2d`, secondary `#558056`

## Development Commands

### Backend Development
```bash
cd bookworm-backend/

# Development with auto-reload
npm run dev

# Build TypeScript
npm run build

# Production start
npm run start

# Database setup (requires Prisma CLI)
npx prisma generate
npx prisma db push
```

### WeChat Mini Program
- Use WeChat Developer Tools to open the `miniprogram/` directory
- Configure API endpoint in `miniprogram/config.js`
- TabBar icons must be PNG format (81x81px) in `images/tabs/`

## Database Schema

The system uses PostgreSQL with these core entities:

**Book Hierarchy:**
- `BookMaster` - Book metadata (ISBN, title, author)  
- `BookSKU` - Book editions/variants
- `InventoryItem` - Individual physical books for sale

**Transaction Flow:**
- `User` - WeChat users via OpenID
- `Order` - Purchase orders with pickup codes
- `OrderItem` - Links orders to specific inventory items

**Critical States:**
- `inventory_status`: `in_stock` → `reserved` → `sold`
- `order_status`: `pending_payment` → `pending_pickup` → `completed`

## Business Rules

1. **Atomic Inventory**: Each `InventoryItem` represents one physical book
2. **Reservation Model**: Books are `reserved` before payment, preventing overselling
3. **No Partial Orders**: All items in an order must be available or the entire order fails
4. **Pickup Flow**: Orders use unique pickup codes for fulfillment

## Key Files to Understand

- `schema.sql` - Complete database schema with enums and constraints
- `bookworm-backend/src/index.ts` - Main API server with global error handling
- `miniprogram/app.wxss` - Global design system and CSS variables
- `miniprogram/app.json` - Mini program configuration and navigation

## Environment Configuration

Backend requires `.env` file in `bookworm-backend/`:
```
DATABASE_URL=postgresql://...
WECHAT_APP_ID=wx...
WECHAT_APP_SECRET=...
JWT_SECRET=...
PORT=3000
```

## API Endpoints

**Core APIs** (all prefixed with `/api`):
- `GET /inventory/available` - List available books
- `GET /inventory/item/:id` - Book details
- `POST /orders/create` - Create new order (reserves inventory)
- `GET /orders/user/:userId` - User order history
- `POST /orders/fulfill` - Fulfill order with pickup code

## WeChat Integration

- Authentication via `wx.login()` → backend `/api/auth/login`
- User identification by WeChat OpenID
- Mini program uses `wx.request()` to call backend APIs
- Payment integration with WeChat Pay (optional)

## Important Development Notes

- Backend serves admin UI at `/admin/` (not `/`) to avoid WeChat Mini Program conflicts
- All inventory state changes must be wrapped in database transactions
- WeChat Mini Program TabBar only supports PNG icons, not SVG
- The system strictly follows "V1 books only" - no AI learning materials or complex features
- Error handling uses global Fastify error handler with business-specific error types


================================================================================
### FILE: bookworm-backend\.env
================================================================================

# .env
DATABASE_URL="postgresql://postgres:mysecretpassword@localhost:5432/bookworm_dev?schema=public"

# JWT Secret
JWT_SECRET="a-very-secret-and-long-string-for-dev-that-is-secure"

# WeChat App Config
WX_APP_ID="wx69f426b95a21dd98"
WX_APP_SECRET="15a45dc6e63e38050f41a08119755a4a"

# WeChat Pay Config
WXPAY_MCHID="your_merchant_id"
WXPAY_PRIVATE_KEY_PATH="/path/to/your/apiclient_key.pem"
WXPAY_PUBLIC_KEY_PATH="/path/to/your/apiclient_cert.pem"
WXPAY_CERT_SERIAL_NO="your_merchant_cert_serial_no"
WXPAY_API_V3_KEY="your_api_v3_key"
WXPAY_NOTIFY_URL="https://your.domain.com/api/payment/notify"

# Tanshu API Key
TANSHU_API_KEY="9dd563ab0eaed4055cfa0e2301f4f1fb"


================================================================================
### FILE: bookworm-backend\package.json
================================================================================

{
  "name": "bookworm-backend",
  "version": "1.0.0",
  "description": "",
  "main": "dist/index.js",
  "scripts": {
    "dev": "nodemon --watch \"src/**/*.ts\" --exec \"npx ts-node\" src/index.ts",
    "build": "tsc",
    "start": "node dist/index.js",
    "test": "vitest run --coverage",
    "migrate:dev": "npx prisma migrate dev",
    "seed": "npx ts-node prisma/seed.ts",
    "job:cancel-orders": "npx ts-node src/jobs/cancelExpiredOrders.ts",
    "postinstall": "cp node_modules/@zxing/library/umd/index.min.js public/zxing.min.js"
  },
  "dependencies": {
    "@fastify/rate-limit": "^9.1.0",
    "@fastify/static": "^7.0.4",
    "@prisma/client": "^5.15.0",
    "axios": "^1.7.2",
    "dotenv": "^16.4.5",
    "fastify": "^4.27.0",
    "fastify-plugin": "^5.0.1",
    "fastify-raw-body": "^4.3.0",
    "jsonwebtoken": "^9.0.2",
    "prom-client": "^15.1.3",
    "wechatpay-node-v3": "^2.2.1"
  },
  "devDependencies": {
    "@types/jsonwebtoken": "^9.0.6",
    "@types/node": "^20.14.2",
    "@vitest/coverage-v8": "^3.2.4",
    "@zxing/library": "^0.21.3",
    "nodemon": "^3.1.2",
    "prisma": "^5.15.0",
    "ts-node": "^10.9.2",
    "typescript": "^5.4.5",
    "vitest": "^3.2.4"
  },
  "keywords": [],
  "author": "",
  "license": "ISC"
}


================================================================================
### FILE: bookworm-backend\prisma\schema.prisma
================================================================================

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Order {
  id                Int         @id @default(autoincrement())
  user_id           Int
  status            OrderStatus @default(PENDING_PAYMENT)
  total_amount      Decimal     @db.Decimal(10, 2)
  pickup_code       String      @unique @db.VarChar(10)
  createdAt         DateTime    @default(now()) @db.Timestamptz(6)
  paymentExpiresAt  DateTime    @db.Timestamptz(6)
  pickupExpiresAt   DateTime?   @db.Timestamptz(6)
  paid_at           DateTime?   @db.Timestamptz(6)
  completed_at      DateTime?   @db.Timestamptz(6)
  cancelled_at      DateTime?   @db.Timestamptz(6)
  User              User        @relation(fields: [user_id], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "fk_user")
  orderitem         orderitem[]

  @@index([user_id, status], map: "idx_order_user_id_status")
}

model User {
  id         Int      @id @default(autoincrement())
  openid     String   @unique @db.VarChar(255)
  unionid    String?  @unique @db.VarChar(255)
  nickname   String?  @db.VarChar(255)
  avatar_url String?  @db.VarChar(255)
  role       Role     @default(USER)
  created_at DateTime @default(now()) @db.Timestamptz(6)
  Order      Order[]
}

model bookmaster {
  id             Int       @id @default(autoincrement())
  isbn13         String    @unique @db.VarChar(13)
  title          String    @db.VarChar(255)
  author         String?   @db.VarChar(255)
  publisher      String?   @db.VarChar(255)
  original_price Decimal?  @db.Decimal(10, 2)
  created_at     DateTime  @default(now()) @db.Timestamptz(6)
  updated_at     DateTime  @default(now()) @db.Timestamptz(6)
  booksku        booksku[]

  @@index([isbn13], map: "idx_book_master_isbn13")
}

model booksku {
  id              Int             @id @default(autoincrement())
  master_id       Int
  edition         String?         @db.VarChar(50)
  description     String?
  cover_image_url String?         @db.VarChar(255)
  created_at      DateTime        @default(now()) @db.Timestamptz(6)
  updated_at      DateTime        @default(now()) @db.Timestamptz(6)
  bookmaster      bookmaster      @relation(fields: [master_id], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "fk_master")
  inventoryitem   inventoryitem[]

  @@unique([master_id, edition])
}

model inventoryitem {
  id            Int              @id @default(autoincrement())
  sku_id        Int
  condition     book_condition
  cost          Decimal          @db.Decimal(10, 2)
  selling_price Decimal          @db.Decimal(10, 2)
  status        inventory_status @default(in_stock)
  created_at    DateTime         @default(now()) @db.Timestamptz(6)
  updated_at    DateTime         @default(now()) @db.Timestamptz(6)
  booksku       booksku          @relation(fields: [sku_id], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "fk_sku")
  orderitem     orderitem?

  @@index([sku_id, status], map: "idx_inventory_item_sku_id_status")
}

model orderitem {
  id                Int           @id @default(autoincrement())
  order_id          Int
  inventory_item_id Int           @unique
  price             Decimal       @db.Decimal(10, 2)
  inventoryitem     inventoryitem @relation(fields: [inventory_item_id], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "fk_inventory_item")
  Order             Order         @relation(fields: [order_id], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "fk_order")
}

model Content {
  id        Int      @id @default(autoincrement())
  slug      String   @unique @db.VarChar(255)
  title     String   @db.VarChar(255)
  body      String
  createdAt DateTime @default(now()) @db.Timestamptz(6)
  updatedAt DateTime @default(now()) @updatedAt @db.Timestamptz(6)

  @@index([slug], map: "idx_content_slug")
}

enum book_condition {
  A
  B
  C
}

enum inventory_status {
  in_stock
  reserved
  sold
  returned
  damaged
}

enum Role {
  USER
  STAFF
}

enum OrderStatus {
  PENDING_PAYMENT
  PENDING_PICKUP
  COMPLETED
  CANCELLED
  RETURNED
}


================================================================================
### FILE: bookworm-backend\public\index.html
================================================================================

<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>运营后台</title>
    <link rel="stylesheet" href="style.css">
    <script type="text/javascript" src="zxing.min.js" defer></script>
    <script src="main.js" defer></script>
</head>
<body>
    <div id="scanner-container" class="scanner-overlay">
        <video id="video"></video>
        <button id="close-scanner" class="button-danger">关闭</button>
    </div>

    <main class="main-container">
        <header class="main-header">
            <h1>运营后台</h1>
        </header>

        <section class="module-card">
            <h2 class="module-title">图书入库</h2>
            <div class="cover-preview-container">
                <img id="cover-preview" src="" alt="封面预览">
            </div>
            <form id="add-book-form">
                <div class="form-group">
                    <label for="isbn13">ISBN-13</label>
                    <div class="input-group">
                        <input type="text" id="isbn13" name="isbn13" required>
                        <button type="button" id="scan-btn" class="button-secondary">扫描</button>
                    </div>
                </div>
                <div class="form-group">
                    <label for="title">书名</label>
                    <input type="text" id="title" name="title" required>
                </div>
                <div class="form-group">
                    <label for="author">作者</label>
                    <input type="text" id="author" name="author">
                </div>
                <div class="form-group">
                    <label for="edition">版本</label>
                    <input type="text" id="edition" name="edition">
                </div>
                <div class="form-group">
                    <label for="condition">品相</label>
                    <select id="condition" name="condition" required>
                        <option value="A">A (全新)</option>
                        <option value="B">B (良好)</option>
                        <option value="C">C (可用)</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="cost">成本价 (元)</label>
                    <input type="number" id="cost" name="cost" step="0.01" required>
                </div>
                <div class="form-group">
                    <label for="selling_price">销售价 (元)</label>
                    <input type="number" id="selling_price" name="selling_price" step="0.01" required>
                </div>
                <button type="submit" class="button-primary">添加入库</button>
            </form>
            <div id="add-book-message-area" class="message-area"></div>
        </section>

        <section class="module-card">
            <h2 class="module-title">订单核销</h2>
            <form id="fulfill-order-form">
                <div class="form-group">
                    <label for="pickupCode">取货码</label>
                    <input type="text" id="pickupCode" name="pickupCode" required placeholder="输入6位取货码">
                </div>
                <button type="submit" class="button-primary">确认核销</button>
            </form>
            <div id="fulfill-order-message-area" class="message-area"></div>
        </section>

        <section class="module-card">
            <h2 class="module-title">待取货订单看板</h2>
            <div id="pending-orders-container">
                <!-- Orders will be dynamically inserted here -->
            </div>
            <div id="pending-orders-message-area" class="message-area"></div>
        </section>
    </main>
</body>
</html>


================================================================================
### FILE: bookworm-backend\public\main.js
================================================================================

// public/main.js (Refactored for clarity and maintainability)

document.addEventListener('DOMContentLoaded', () => {

  /**
   * A reusable utility to show messages in a designated area.
   * @param {HTMLElement} area The message container element.
   * @param {string} text The message to display.
   * @param {'success' | 'error' | 'info'} type The type of the message for styling.
   */
  function showMessage(area, text, type) {
    area.textContent = text;
    area.className = `message-area visible ${type}`;
  }

  /**
   * Manages the book addition module.
   */
  const BookAdder = {
    form: document.getElementById('add-book-form'),
    messageArea: document.getElementById('add-book-message-area'),
    isbnInput: document.getElementById('isbn13'),
    coverPreview: document.getElementById('cover-preview'),

    init() {
      this.form.addEventListener('submit', this.handleSubmit.bind(this));
    },

    async handleSubmit(e) {
      e.preventDefault();
      showMessage(this.messageArea, '正在提交...', 'info');

      const formData = new FormData(this.form);
      const data = {
        ...Object.fromEntries(formData.entries()),
        cost: parseFloat(formData.get('cost')),
        selling_price: parseFloat(formData.get('selling_price')),
      };

      try {
        const response = await fetch('/api/inventory/add', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(data),
        });
        const result = await response.json();
        if (!response.ok) throw new Error(result.error || '未知错误');

        showMessage(this.messageArea, `成功！书籍ID "${result.id}" 已入库。`, 'success');
        this.form.reset();
        this.coverPreview.classList.remove('visible');
      } catch (error) {
        showMessage(this.messageArea, `错误: ${error.message}`, 'error');
      }
    }
  };

  /**
   * Manages the order fulfillment module.
   */
  const OrderFulfiller = {
    form: document.getElementById('fulfill-order-form'),
    messageArea: document.getElementById('fulfill-order-message-area'),

    init() {
      this.form.addEventListener('submit', this.handleSubmit.bind(this));
    },

    async handleSubmit(e) {
      e.preventDefault();
      showMessage(this.messageArea, '正在核销...', 'info');
      const pickupCode = new FormData(this.form).get('pickupCode');

      try {
        const response = await fetch('/api/orders/fulfill', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ pickupCode }),
        });
        const result = await response.json();
        if (!response.ok) throw new Error(result.error || '未知错误');

        showMessage(this.messageArea, `成功！订单 #${result.id} 已核销。`, 'success');
        this.form.reset();
      } catch (error) {
        showMessage(this.messageArea, `错误: ${error.message}`, 'error');
      }
    }
  };

  /**
   * Manages the pending orders dashboard.
   */
  const PendingOrdersDashboard = {
    container: document.getElementById('pending-orders-container'),
    messageArea: document.getElementById('pending-orders-message-area'),
    
    init() {
      this.fetchOrders(); // Fetch immediately on load
      setInterval(this.fetchOrders.bind(this), 10000); // And then every 10 seconds
    },

    async fetchOrders() {
      try {
        const response = await fetch('/api/orders/pending-pickup');
        if (!response.ok) throw new Error(`HTTP ${response.status}`);
        const orders = await response.json();
        
        this.render(orders);
      } catch (error) {
        showMessage(this.messageArea, `无法加载订单: ${error.message}`, 'error');
      }
    },

    render(orders) {
      if (orders.length === 0) {
        this.container.innerHTML = '<p class="empty-state">当前没有待取货的订单。</p>';
        return;
      }

      this.container.innerHTML = orders.map(order => `
        <div class="order-card">
          <div class="order-header">
            <strong>取货码: ${order.pickup_code}</strong>
            <span>¥${order.total_amount}</span>
          </div>
          <ul class="order-item-list">
            ${order.orderitem.map(item => `
              <li>${item.inventoryitem.booksku.bookmaster.title} (品相: ${item.inventoryitem.condition})</li>
            `).join('')}
          </ul>
        </div>
      `).join('');
    }
  };

  /**
   * Manages the ISBN scanner functionality.
   */
  const Scanner = {
    reader: new ZXing.BrowserMultiFormatReader(),
    container: document.getElementById('scanner-container'),
    videoElement: document.getElementById('video'),
    scanButton: document.getElementById('scan-btn'),
    closeButton: document.getElementById('close-scanner'),

    init() {
      this.scanButton.addEventListener('click', this.start.bind(this));
      this.closeButton.addEventListener('click', this.stop.bind(this));
    },

    start() {
      this.container.classList.add('visible');
      this.reader.listVideoInputDevices()
        .then(devices => {
          const backCamera = devices.find(d => d.label.toLowerCase().includes('back')) || devices[0];
          if (!backCamera) throw new Error('No camera found.');
          
          this.reader.decodeFromVideoDevice(backCamera.deviceId, this.videoElement, (result, err) => {
            if (result) {
              this.stop();
              this.handleScanSuccess(result.getText());
            }
            if (err && !(err instanceof ZXing.NotFoundException)) {
              console.error(err);
              showMessage(BookAdder.messageArea, `扫码失败: ${err.message}`, 'error');
              this.stop();
            }
          });
        })
        .catch(err => {
          showMessage(BookAdder.messageArea, `摄像头错误: ${err.message}`, 'error');
          this.stop();
        });
    },

    stop() {
      this.reader.reset();
      this.container.classList.remove('visible');
    },

    async handleScanSuccess(isbn) {
      BookAdder.isbnInput.value = isbn;
      showMessage(BookAdder.messageArea, '正在查询图书信息...', 'info');
      BookAdder.coverPreview.classList.remove('visible');

      try {
        const response = await fetch(`/api/books/meta?isbn=${isbn}`);
        if (!response.ok) throw new Error(`HTTP ${response.status}`);
        const meta = await response.json();
        
        BookAdder.form.elements.title.value = meta.title || '';
        BookAdder.form.elements.author.value = meta.author || '';
        if (meta.cover_image_url) {
          BookAdder.coverPreview.src = meta.cover_image_url;
          BookAdder.coverPreview.classList.add('visible');
        }
        showMessage(BookAdder.messageArea, '信息已自动填充。', 'success');
      } catch (error) {
        showMessage(BookAdder.messageArea, '未找到图书信息，请手动输入。', 'error');
      }
    }
  };

  // Initialize all modules
  BookAdder.init();
  OrderFulfiller.init();
  PendingOrdersDashboard.init();
  Scanner.init();
});


================================================================================
### FILE: bookworm-backend\src\config.ts
================================================================================

// src/config.ts
import * as dotenv from 'dotenv';
import * as fs from 'fs';

dotenv.config();

const config = {
  // Server config
  port: process.env.PORT || 3000,
  
  // JWT config
  jwtSecret: process.env.JWT_SECRET || 'default-secret-for-dev',

  // WeChat Mini Program config
  wxAppId: process.env.WX_APP_ID || 'YOUR_APP_ID',
  wxAppSecret: process.env.WX_APP_SECRET || 'YOUR_APP_SECRET',

  // WeChat Pay config
  wxPayMchId: process.env.WXPAY_MCHID,
  wxPayPrivateKeyPath: process.env.WXPAY_PRIVATE_KEY_PATH,
  wxPayPrivateKey: (() => {
    const keyPath = process.env.WXPAY_PRIVATE_KEY_PATH;
    if (!keyPath || keyPath === 'C:\\path\\to\\your\\apiclient_key.pem' || keyPath === '/path/to/your/apiclient_key.pem') {
      return undefined;
    }
    try {
      return fs.readFileSync(keyPath);
    } catch (error) {
      console.warn(`!!! WARNING: Cannot read WeChat Pay private key from ${keyPath}:`, (error as Error).message);
      return undefined;
    }
  })(),
  wxPayPublicKeyPath: process.env.WXPAY_PUBLIC_KEY_PATH,
  wxPayCertSerialNo: process.env.WXPAY_CERT_SERIAL_NO,
  wxPayApiV3Key: process.env.WXPAY_API_V3_KEY,
  wxPayNotifyUrl: process.env.WXPAY_NOTIFY_URL,

  // Tanshu API config
  tanshuApiKey: process.env.TANSHU_API_KEY,

  // Database URL is read by Prisma from .env directly
};

// Validate essential configs
if (config.jwtSecret === 'default-secret-for-dev') {
    console.warn('!!! WARNING: Using default JWT_SECRET. Please set it in .env file for production.');
}
if (config.wxAppId === 'YOUR_APP_ID' || config.wxAppSecret === 'YOUR_APP_SECRET') {
    console.warn('!!! WARNING: WX_APP_ID or WX_APP_SECRET are not configured in .env file.');
}
if (!config.wxPayMchId || !config.wxPayPrivateKey || !config.wxPayCertSerialNo || !config.wxPayApiV3Key) {
    console.warn('!!! WARNING: WeChat Pay configuration is incomplete. Payment features will not work.');
}
if (!config.tanshuApiKey) { 
    console.warn('!!! WARNING: TANSHU_API_KEY is not configured.'); 
}

export default config;


================================================================================
### FILE: bookworm-backend\src\db.ts
================================================================================

// src/db.ts
import { PrismaClient } from '@prisma/client';
const prisma = new PrismaClient();
export default prisma;


================================================================================
### FILE: bookworm-backend\src\index.ts
================================================================================

// src/index.ts (fully replaced with parser fix)
import Fastify, { FastifyRequest, FastifyReply } from 'fastify';
import * as path from 'path';
import fastifyStatic from '@fastify/static';
import config from './config';
import { addBookToInventory, getAvailableBooks, getBookById } from './services/inventoryService';
import { getBookMetadata } from './services/bookMetadataService';
import { getContentBySlug } from './services/contentService';
import { createOrder, getOrdersByUserId, getOrderById, fulfillOrder, generatePaymentParams, processPaymentNotification, getPendingPickupOrders } from './services/orderService';
import { ApiError } from './errors';
import { wxLogin } from './services/authService';
import authPlugin from './plugins/auth';
import metricsPlugin from './plugins/metrics';
import fastifyRawBody from 'fastify-raw-body';
import rateLimit from '@fastify/rate-limit';
const WechatPay = require('wechatpay-node-v3');
import { Prisma } from '@prisma/client';
import prisma from './db';
import * as fs from 'fs';
const fastify = Fastify({ logger: true });

// --- Wechat Pay Setup ---
let pay: any | null = null;
try {
    if (
        config.wxPayMchId &&
        config.wxPayPrivateKeyPath && fs.existsSync(config.wxPayPrivateKeyPath) &&
        config.wxPayPublicKeyPath && fs.existsSync(config.wxPayPublicKeyPath) &&
        config.wxPayCertSerialNo &&
        config.wxPayApiV3Key
    ) {
        pay = new WechatPay({
            appid: config.wxAppId!,
            mchid: config.wxPayMchId!,
            privateKey: fs.readFileSync(config.wxPayPrivateKeyPath!),
            publicKey: fs.readFileSync(config.wxPayPublicKeyPath!), // <-- Added missing public key
            serial_no: config.wxPayCertSerialNo!,
            key: config.wxPayApiV3Key!,
        });
        console.log("WeChat Pay SDK initialized successfully.");
    } else {
        throw new Error("WeChat Pay configuration is incomplete or certificate files are missing.");
    }
} catch (error) {
    console.warn(`!!! WARNING: Failed to initialize WeChat Pay SDK. Payment features will be disabled. Reason: ${(error as Error).message}`);
}

// REMOVED: The global content type parser is gone.
// fastify.addContentTypeParser('application/json', { parseAs: 'buffer' }, ...);

// --- Global Error Handler ---
fastify.setErrorHandler(async (error: Error, request: FastifyRequest, reply: FastifyReply) => {
    request.log.error({ err: error, req: request }, 'An error occurred during the request');

    // Handle ApiError - our standardized business logic errors
    if (error instanceof ApiError) {
        return reply.code(error.statusCode).send({ 
            error: error.message, 
            errorCode: error.errorCode 
        });
    }

    // Handle Prisma errors
    if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2025') {
        return reply.code(404).send({ 
            error: 'Record not found.', 
            errorCode: 'RECORD_NOT_FOUND' 
        });
    }

    // For all other unknown errors, send a generic 500 response
    reply.code(500).send({ 
        error: 'Internal Server Error', 
        errorCode: 'INTERNAL_ERROR' 
    });
});

// Production configuration validation
const validateProductionConfig = () => {
    if (process.env.NODE_ENV !== 'production') {
        return; // Only validate in production
    }

    const criticalMissingConfigs: string[] = [];

    // JWT Secret validation
    if (config.jwtSecret === 'default-secret-for-dev' || !config.jwtSecret) {
        criticalMissingConfigs.push('JWT_SECRET');
    }

    // WeChat App validation
    if (config.wxAppId === 'YOUR_APP_ID' || !config.wxAppId) {
        criticalMissingConfigs.push('WX_APP_ID');
    }
    if (config.wxAppSecret === 'YOUR_APP_SECRET' || !config.wxAppSecret) {
        criticalMissingConfigs.push('WX_APP_SECRET');
    }

    // Database URL validation
    if (!process.env.DATABASE_URL) {
        criticalMissingConfigs.push('DATABASE_URL');
    }

    if (criticalMissingConfigs.length > 0) {
        console.error('');
        console.error('🚨 FATAL ERROR: Critical configuration missing in production environment!');
        console.error('❌ Missing required environment variables:');
        criticalMissingConfigs.forEach(config => {
            console.error(`   - ${config}`);
        });
        console.error('');
        console.error('📋 Please set these environment variables and restart the application.');
        console.error('🛑 Shutting down to prevent production deployment with insecure configuration.');
        console.error('');
        process.exit(1);
    }

    console.log('✅ Production configuration validation passed');
};

const setupPluginsAndRoutes = async () => {
    // Register plugins first - MUST be awaited in correct order
    await fastify.register(fastifyStatic, { root: path.join(__dirname, '..', 'public'), prefix: '/admin/' });
    await fastify.register(authPlugin);
    await fastify.register(metricsPlugin);
    await fastify.register(fastifyRawBody, {
        field: 'rawBody',
        global: false, // 只在需要的路由上启用
        encoding: 'utf8',
        runFirst: true
    });
    await fastify.register(rateLimit, {
        global: false, // 我们按路由单独配置
    });

    // Now all routes can be defined safely
    setupRoutes();
};

const setupRoutes = () => {
    // Health Check Endpoint
    fastify.get('/api/health', async (request, reply) => {
        const checks: { [key: string]: string } = {};
        let allHealthy = true;

        // Database connectivity check
        try {
            await prisma.$queryRaw`SELECT 1`;
            checks.database = 'ok';
        } catch (error) {
            request.log.error(error, 'Database health check failed');
            checks.database = 'failed';
            allHealthy = false;
        }

        if (allHealthy) {
            reply.send({
                status: 'ok',
                timestamp: new Date().toISOString(),
                checks
            });
        } else {
            reply.code(503).send({
                status: 'error',
                timestamp: new Date().toISOString(),
                checks
            });
        }
    });

    // Auth routes
    fastify.post('/api/auth/login', {
        config: { rateLimit: { max: 10, timeWindow: '1 minute' } }
    }, async (request, reply) => {
        const { code } = request.body as { code: string };
        if (!code) { return reply.code(400).send({ error: 'Code is required.' }); }
        const { token, user } = await wxLogin(code);
        reply.send({ token, userId: user.id });
    });

    // Books metadata
    fastify.get('/api/books/meta', async (request, reply) => {
        const query = request.query as { isbn?: string };
        if (!query.isbn) { 
            return reply.code(400).send({ error: 'ISBN parameter is required.' }); 
        }
        
        const metadata = await getBookMetadata(query.isbn);
        if (!metadata) { 
            return reply.code(404).send({ error: 'Book metadata not found.' }); 
        }
        
        reply.send(metadata);
    });

    // Inventory routes
    fastify.get('/api/inventory/available', async (request, reply) => {
        const query = request.query as { search?: string };
        const books = await getAvailableBooks(query.search);
        reply.send(books);
    });
    
    fastify.get('/api/inventory/item/:id', async (request, reply) => {
        const params = request.params as { id: string };
        const id = parseInt(params.id, 10);
        if (isNaN(id)) { return reply.code(400).send({ error: 'Invalid item ID.' }); }
        const book = await getBookById(id);
        if (!book) { return reply.code(404).send({ error: 'Book not found.' }); }
        reply.send(book);
    });
    
    fastify.post('/api/inventory/add', { preHandler: [fastify.authenticate, fastify.requireRole('STAFF')] }, async (request, reply) => {
        console.log('DEBUG: request.body =', request.body);
        console.log('DEBUG: request.body type =', typeof request.body);
        const newItem = await addBookToInventory(request.body as any);
        reply.code(201).send(newItem);
    });

    // Content Management
    fastify.get('/api/content/:slug', async (request, reply) => {
        const params = request.params as { slug: string };
        const content = await getContentBySlug(params.slug);
        reply.send(content);
    });

    // Order routes
    fastify.post('/api/orders/create', { preHandler: [fastify.authenticate] }, async (request, reply) => {
        const { inventoryItemIds } = request.body as { inventoryItemIds: number[] };
        const order = await createOrder({ userId: request.user!.userId, inventoryItemIds });
        reply.code(201).send(order);
    });

    fastify.get('/api/orders/:id', { preHandler: [fastify.authenticate] }, async (request, reply) => {
        const { id } = request.params as { id: string };
        const orderId = parseInt(id, 10);
        if (isNaN(orderId)) return reply.code(400).send({ error: 'Invalid order ID' });
        const order = await getOrderById(orderId);
        const user = await prisma.user.findUnique({ where: { id: request.user!.userId }, select: { role: true } });
        if (order.user_id !== request.user!.userId && user?.role !== 'STAFF') {
            return reply.code(403).send({ error: 'Forbidden' });
        }
        reply.send(order);
    });

    fastify.get('/api/orders/user/:userId', { preHandler: [fastify.authenticate] }, async (request, reply) => {
        const { userId } = request.params as { userId: string };
        if (parseInt(userId, 10) !== request.user!.userId) {
            return reply.code(403).send({ error: 'Forbidden' });
        }
        const orders = await getOrdersByUserId(request.user!.userId);
        reply.send(orders);
    });

    fastify.post('/api/orders/fulfill', {
        preHandler: [fastify.authenticate, fastify.requireRole('STAFF')],
        config: {
            rateLimit: {
                max: 30,
                timeWindow: '1 minute',
                keyGenerator: (req) => req.user?.userId.toString() || req.ip
            }
        }
    }, async (request, reply) => {
        const { pickupCode } = request.body as { pickupCode: string };
        if (!pickupCode) { return reply.code(400).send({ error: 'pickupCode is required.' }); }
        const order = await fulfillOrder(pickupCode.toUpperCase());
        reply.send(order);
    });

    fastify.get('/api/orders/pending-pickup', { preHandler: [fastify.authenticate, fastify.requireRole('STAFF')] }, async (request, reply) => {
        const orders = await getPendingPickupOrders();
        reply.send(orders);
    });

    fastify.post('/api/orders/:orderId/pay', { preHandler: [fastify.authenticate] }, async (request, reply) => {
        if (!pay) return reply.code(503).send({ error: 'Payment service is not configured.' });
        const { orderId } = request.params as { orderId: string };
        const paymentParams = await generatePaymentParams(pay, parseInt(orderId, 10), request.user!.userId);
        reply.send(paymentParams);
    });

    // Payment callback
    fastify.post('/api/payment/notify', { config: { rawBody: true } }, async (request, reply) => {
        if (!pay) {
            request.log.error('WeChat Pay is not configured, cannot process notification.');
            return reply.code(503).send({ error: 'Payment service unavailable.' });
        }

        try {
            const rawBody = (request as any).rawBody as string;
            if (!rawBody) {
                throw new Error("Missing raw body for payment notification");
            }

            const isVerified = pay.verifySign({
                timestamp: request.headers['wechatpay-timestamp'] as string,
                nonce: request.headers['wechatpay-nonce'] as string,
                body: rawBody,
                signature: request.headers['wechatpay-signature'] as string,
                serial: request.headers['wechatpay-serial'] as string,
            });

            if (!isVerified) {
                request.log.warn('Payment notification signature verification failed.');
                return reply.code(400).send({ code: 'FAIL', message: '验签失败' });
            }

            const { resource } = JSON.parse(rawBody);
            const decryptedData = pay.decipher_gcm(
                resource.ciphertext,
                resource.associated_data,
                resource.nonce,
                config.wxPayApiV3Key!
            );
            
            const notificationData = JSON.parse(decryptedData as string);

            if (notificationData.trade_state === 'SUCCESS') {
                await processPaymentNotification(notificationData);
            }

            reply.code(200).send({ code: 'SUCCESS', message: '成功' });

        } catch (e) {
            request.log.error({ err: e }, 'Payment notification processing failed');
            reply.code(400).send({ code: 'FAIL', message: '处理失败' });
        }
    });
};

const start = async () => {
    try {
        validateProductionConfig();
        await setupPluginsAndRoutes();
        await fastify.listen({ port: config.port as number, host: '0.0.0.0' });
    } catch (err) {
        fastify.log.error(err);
        process.exit(1);
    }
};
start();


================================================================================
### FILE: bookworm-backend\src\services\authService.ts
================================================================================

// src/services/authService.ts
import axios from 'axios';
import * as jwt from 'jsonwebtoken';
import config from '../config'; // <-- Import config
import prisma from '../db';

export async function wxLogin(code: string) {
  const url = `https://api.weixin.qq.com/sns/jscode2session?appid=${config.wxAppId}&secret=${config.wxAppSecret}&js_code=${code}&grant_type=authorization_code`;
  const { data: wxSession } = await axios.get(url);
  
  if (wxSession.errcode) { throw new Error(`WeChat API Error: ${wxSession.errmsg}`); }

  const { openid, unionid } = wxSession;
  
  const user = await prisma.$transaction(async (tx) => {
    let user = null;
    
    if (unionid) {
      user = await tx.user.findUnique({ where: { unionid } });
      
      if (user !== null) {
        if (user.openid !== openid) {
          user = await tx.user.update({
            where: { id: user.id },
            data: { openid }
          });
        }
        return user;
      }
      
      user = await tx.user.findUnique({ where: { openid } });
      
      if (user !== null) {
        user = await tx.user.update({
          where: { id: user.id },
          data: { unionid }
        });
        return user;
      }
      
      user = await tx.user.create({
        data: { openid, unionid }
      });
      return user;
      
    } else {
      user = await tx.user.findUnique({ where: { openid } });
      
      if (user !== null) {
        return user;
      }
      
      user = await tx.user.create({
        data: { openid }
      });
      return user;
    }
  });
  
  const token = jwt.sign({ userId: user.id, openid: user.openid }, config.jwtSecret, { expiresIn: '7d' });

  return { token, user };
}


================================================================================
### FILE: bookworm-backend\src\services\inventoryService.ts
================================================================================

// src/services/inventoryService.ts (fully replaced)
import { Prisma, book_condition } from '@prisma/client';
import prisma from '../db';
import { getBookMetadata } from './bookMetadataService';

interface AddBookInput {
  isbn13: string;
  title: string;
  author?: string;
  edition?: string;
  condition: book_condition;
  cost: number;
  selling_price: number;
}

export async function addBookToInventory(input: AddBookInput) {
  return prisma.$transaction(async (tx) => {
    
    // NEW: Attempt to fetch external metadata
    const metadata = await getBookMetadata(input.isbn13);
    
    // Step 1: Find or create the master book record (based on ISBN).
    // Use metadata if available, otherwise use input data (manual entry)
    const bookMaster = await tx.bookmaster.upsert({
      where: { isbn13: input.isbn13 },
      update: {
        // If metadata is available, update title/author/publisher
        ...(metadata && {
          title: metadata.title,
          author: metadata.author,
          publisher: metadata.publisher,
          original_price: metadata.original_price,
        }),
      }, 
      create: {
        isbn13: input.isbn13,
        // Use metadata or fall back to input
        title: metadata?.title || input.title, 
        author: metadata?.author || input.author,
        publisher: metadata?.publisher,
        original_price: metadata?.original_price,
      },
    });

    // Step 2: Find or create the specific SKU (e.g., '2nd Edition').
    // This represents a specific version of the master book.
    const bookSku = await tx.booksku.upsert({
      where: {
        master_id_edition: {
          master_id: bookMaster.id,
          edition: input.edition || "default",
        },
      },
      update: {
        // If metadata is available, update cover image URL
        ...(metadata && {
          cover_image_url: metadata.cover_image_url,
        }),
      },
      create: {
        master_id: bookMaster.id,
        edition: input.edition || "default",
        cover_image_url: metadata?.cover_image_url, // Use metadata cover image
      },
    });

    // Step 3: Create the actual inventory item.
    // This represents the physical copy we have in stock.
    const inventoryItem = await tx.inventoryitem.create({
      data: {
        sku_id: bookSku.id,
        condition: input.condition,
        cost: input.cost,
        selling_price: input.selling_price,
        status: "in_stock",
      },
    });

    return inventoryItem;
  });
}

// MODIFIED: getAvailableBooks now accepts an optional search term
export async function getAvailableBooks(searchTerm?: string) {
  const whereCondition: Prisma.inventoryitemWhereInput = {
    status: 'in_stock',
  };

  if (searchTerm) {
    whereCondition.booksku = {
      bookmaster: {
        OR: [
          { title: { contains: searchTerm, mode: 'insensitive' } },
          { author: { contains: searchTerm, mode: 'insensitive' } },
          { isbn13: { contains: searchTerm } },
        ],
      },
    };
  }

  return prisma.inventoryitem.findMany({
    where: whereCondition,
    include: {
      booksku: {
        include: {
          bookmaster: true,
        },
      },
    },
  });
}

// NEW: Function to get a single book by its inventory item ID
export async function getBookById(id: number) {
  return prisma.inventoryitem.findUnique({
    where: { id },
    include: {
      booksku: {
        include: {
          bookmaster: true,
        },
      },
    },
  });
}


================================================================================
### FILE: bookworm-backend\src\services\orderService.ts
================================================================================

// src/services/orderService.ts (fully replaced)
import { Prisma } from '@prisma/client';
import { randomBytes } from 'crypto';
import * as crypto from 'crypto';
const WechatPay = require('wechatpay-node-v3');
import config from '../config';
import prisma from '../db';
import { ApiError } from '../errors';

export async function createOrder(input: { userId: number; inventoryItemIds: number[] }) {
    return prisma.$transaction(async (tx) => {
        const itemIds = Array.from(new Set(input.inventoryItemIds));
        if (itemIds.length === 0) {
            throw new ApiError(400, '没有选择任何书籍', 'EMPTY_ITEMS');
        }

        // 1. 原子抢占：尝试将 'in_stock' 状态更新为 'reserved'
        const updateResult = await tx.inventoryitem.updateMany({
            where: {
                id: { in: itemIds },
                status: 'in_stock'
            },
            data: { status: 'reserved' }
        });

        // 2. 检查结果：如果更新的行数不等于请求的物品数量，说明有物品被别人抢先了
        if (updateResult.count !== itemIds.length) {
            // 事务会自动回滚所有更改，所以我们只需要抛出错误
            throw new ApiError(409, '部分书籍已被抢购，请重新下单', 'INSUFFICIENT_INVENTORY');
        }

        // 3. 读取已成功抢占的物品信息，用于计算总价
        const reservedItems = await tx.inventoryitem.findMany({
            where: { id: { in: itemIds } }
        });

        const totalAmount = reservedItems.reduce(
            (sum, item) => sum.add(new Prisma.Decimal(item.selling_price)),
            new Prisma.Decimal(0)
        );

        // 4. 创建订单和订单项
        const order = await tx.order.create({
            data: {
                user_id: input.userId,
                status: 'PENDING_PAYMENT',
                total_amount: totalAmount,
                pickup_code: crypto.randomBytes(3).toString('hex').toUpperCase(),
                paymentExpiresAt: new Date(Date.now() + 15 * 60 * 1000), // 15分钟后过期
            },
        });

        await tx.orderitem.createMany({
            data: reservedItems.map(item => ({
                order_id: order.id,
                inventory_item_id: item.id,
                price: item.selling_price,
            })),
        });

        return order;
    }, {
        isolationLevel: Prisma.TransactionIsolationLevel.Serializable, // 使用最高隔离级别保证一致性
    });
}

export async function getOrdersByUserId(userId: number) {
  // ... (this function is unchanged)
  return prisma.order.findMany({
    where: { user_id: userId },
    include: { orderitem: { include: { inventoryitem: { include: { booksku: { include: { bookmaster: true } } } } } } },
    orderBy: { createdAt: 'desc' },
  });
}

// NEW: Function to fulfill an order
export async function fulfillOrder(pickupCode: string) {
  return prisma.$transaction(async (tx) => {
    // 1. Find the order by its unique pickup code.
    const order = await tx.order.findUnique({
      where: { pickup_code: pickupCode },
      include: { orderitem: true }, // Include items to update their status
    });

    // 2. Validate
    if (!order) {
      throw new ApiError(404, `取货码 "${pickupCode}" 无效`, 'INVALID_PICKUP_CODE');
    }
    if (order.status !== 'PENDING_PICKUP') {
      throw new ApiError(409, `此订单状态为 "${order.status}"，无法核销。订单必须已支付才能核销。`, 'ORDER_STATE_INVALID');
    }

    // 3. Update the Order status
    const updatedOrder = await tx.order.update({
      where: { id: order.id },
      data: {
        status: 'COMPLETED',
        completed_at: new Date(),
      },
    });

    // 4. Update the InventoryItem statuses
    const inventoryItemIds = order.orderitem.map(item => item.inventory_item_id);
    await tx.inventoryitem.updateMany({
      where: { id: { in: inventoryItemIds } },
      data: { status: 'sold' },
    });

    return updatedOrder;
  });
}

export async function generatePaymentParams(pay: any, orderId: number, userId: number) {
    const order = await prisma.order.findUniqueOrThrow({ where: { id: orderId } });
    if (order.user_id !== userId) throw new ApiError(403, '无权支付此订单', 'FORBIDDEN');
    if (order.status !== 'PENDING_PAYMENT') throw new ApiError(409, '订单状态不正确', 'ORDER_STATE_INVALID');

    const user = await prisma.user.findUniqueOrThrow({ where: { id: userId }, select: { openid: true } });
    
    const orderItems = await prisma.orderitem.findMany({ 
        where: { order_id: orderId },
        include: { inventoryitem: { include: { booksku: { include: { bookmaster: true } } } } }
    });
    const titles = orderItems.map(i => i.inventoryitem.booksku.bookmaster.title);
    const description = titles.slice(0, 3).join('、') + (titles.length > 3 ? `等${titles.length}本书籍` : '');

    const unifiedOrderResult = await pay.transactions_jsapi({
        appid: config.wxAppId!,
        mchid: config.wxPayMchId!,
        description,
        out_trade_no: `BOOKWORM_${order.id}_${Date.now()}`, // 加入时间戳防重试
        notify_url: config.wxPayNotifyUrl!,
        amount: { total: Math.round(Number(order.total_amount) * 100), currency: 'CNY' },
        payer: { openid: user.openid }
    });

    const { prepay_id } = unifiedOrderResult as any;
    if (!prepay_id) throw new ApiError(500, '微信下单失败，未返回prepay_id', 'WECHAT_PAY_ERROR');
    
    const timeStamp = Math.floor(Date.now() / 1000).toString();
    const nonceStr = crypto.randomBytes(16).toString('hex');
    const pkg = `prepay_id=${prepay_id}`;
    const toSign = `${config.wxAppId}\n${timeStamp}\n${nonceStr}\n${pkg}\n`;

    const paySign = pay.sign(toSign);

    return { timeStamp, nonceStr, package: pkg, signType: 'RSA', paySign };
}

// NEW: Process WeChat Pay payment notification
export async function processPaymentNotification(notificationData: any) {
  return prisma.$transaction(async (tx) => {
    const { out_trade_no, transaction_id, trade_state, amount } = notificationData;
    
    // 1. Validate payment success
    if (trade_state !== 'SUCCESS') {
      throw new ApiError(400, `支付未成功，状态：${trade_state}`, 'PAYMENT_NOT_SUCCESS');
    }

    // 2. Extract order ID from out_trade_no (format: BOOKWORM_{orderId})
    if (!out_trade_no.startsWith('BOOKWORM_')) {
      throw new ApiError(400, `订单号格式无效：${out_trade_no}`, 'INVALID_TRADE_NO');
    }
    const orderId = parseInt(out_trade_no.split('_')[1], 10);

    // 3. Find and validate the order
    const order = await tx.order.findUnique({
      where: { id: orderId },
      include: { orderitem: true }
    });

    if (!order) {
      throw new ApiError(404, `订单不存在：${orderId}`, 'ORDER_NOT_FOUND');
    }

    // 4. Check if already processed (idempotency)
    if (order.status === 'PENDING_PICKUP') {
      console.log(`Order ${orderId} already marked as paid. Skipping.`);
      return order;
    }

    // 5. Validate order status
    if (order.status !== 'PENDING_PAYMENT') {
      throw new ApiError(409, `订单状态无效：${order.status}，期望：PENDING_PAYMENT`, 'ORDER_STATE_INVALID');
    }

    // 6. Validate amount (convert from cents to yuan)
    const expectedAmount = Math.round(Number(order.total_amount) * 100);
    if (amount.total !== expectedAmount) {
      throw new ApiError(400, `金额不匹配。期望：${expectedAmount}，实际：${amount.total}`, 'AMOUNT_MISMATCH');
    }

    // 7. Update order status to paid
    const updatedOrder = await tx.order.update({
      where: { id: orderId },
      data: {
        status: 'PENDING_PICKUP',
        paid_at: new Date()
      }
    });

    console.log(`Order ${orderId} successfully marked as paid`);
    return updatedOrder;
  });
}

export async function getPendingPickupOrders() {
  return prisma.order.findMany({
    where: {
      status: 'PENDING_PICKUP',
    },
    include: {
      orderitem: {
        include: {
          inventoryitem: {
            include: {
              booksku: {
                include: {
                  bookmaster: true,
                },
              },
            },
          },
        },
      },
    },
    orderBy: {
      paid_at: 'asc', // 按支付时间升序，先付钱的先备货
    },
  });
}

export async function cancelExpiredOrders() {
  return prisma.$transaction(async (tx) => {
    // 1. Find all orders that are pending payment and have expired.
    const expiredOrders = await tx.order.findMany({
      where: {
        status: 'PENDING_PAYMENT',
        paymentExpiresAt: {
          lt: new Date(), // Less than the current time
        },
      },
      select: {
        id: true,
      },
    });

    if (expiredOrders.length === 0) {
      return { cancelledCount: 0 }; // Nothing to do
    }

    const expiredOrderIds = expiredOrders.map(o => o.id);
    console.log(`Found ${expiredOrderIds.length} expired orders to cancel:`, expiredOrderIds);

    // 2. Find all inventory items linked to these expired orders.
    const itemsToRelease = await tx.orderitem.findMany({
      where: {
        order_id: {
          in: expiredOrderIds,
        },
      },
      select: {
        inventory_item_id: true,
      },
    });

    const inventoryItemIdsToRelease = itemsToRelease.map(i => i.inventory_item_id);

    // 3. Update the orders' status to CANCELLED.
    await tx.order.updateMany({
      where: {
        id: {
          in: expiredOrderIds,
        },
      },
      data: {
        status: 'CANCELLED',
        cancelled_at: new Date(),
      },
    });

    // 4. Update the inventory items' status back to in_stock.
    if (inventoryItemIdsToRelease.length > 0) {
      await tx.inventoryitem.updateMany({
        where: {
          id: {
            in: inventoryItemIdsToRelease,
          },
        },
        data: {
          status: 'in_stock',
        },
      });
    }
    
    console.log(`Cancelled ${expiredOrderIds.length} orders and released ${inventoryItemIdsToRelease.length} items back to stock.`);
    return { cancelledCount: expiredOrderIds.length };
  });
}

export async function getOrderById(orderId: number) {
  return prisma.order.findUniqueOrThrow({
    where: { id: orderId },
    include: {
      orderitem: {
        include: {
          inventoryitem: {
            include: {
              booksku: {
                include: {
                  bookmaster: true
                }
              }
            }
          }
        }
      }
    }
  });
}


================================================================================
### FILE: miniprogram\app.js
================================================================================

// miniprogram/app.js
const auth = require('./utils/auth');

App({
  onLaunch() {
    auth.login()
      .then(res => {
        console.log('Login successful', res);
        this.checkTermsAgreement();
      })
      .catch(err => {
        console.error('Login failed on launch', err);
      });
  },

  checkTermsAgreement() {
    const hasAgreed = wx.getStorageSync('hasAgreedToTerms');
    if (!hasAgreed) {
      wx.showModal({
        title: '服务协议与隐私政策',
        content: '欢迎使用！为了保障您的权益，请在使用前仔细阅读并同意我们的《用户服务协议》与《隐私政策》。您可以在"我的-设置"中随时查看。',
        confirmText: '同意',
        cancelText: '拒绝',
        success: (res) => {
          if (res.confirm) {
            wx.setStorageSync('hasAgreedToTerms', true);
          } else if (res.cancel) {
            // 用户拒绝，可以引导退出或提示无法使用
            wx.showToast({
              title: '您需要同意协议才能使用本服务',
              icon: 'none',
              duration: 3000
            });
            // 简单处理，可以让用户无法进行核心操作
          }
        }
      });
    }
  },

  // 增加一个全局方法，方便其他页面调用
  showTerms() {
    wx.showModal({
      title: '服务协议与隐私政策',
      content: '这里是完整的《用户服务协议》与《隐私政策》内容...（此处应从服务器获取或本地预置长文本）',
      showCancel: false,
      confirmText: '我已知晓',
    });
  }
});


================================================================================
### FILE: miniprogram\app.json
================================================================================

{
  "pages": [
    "pages/market/index",
    "pages/orders/index",
    "pages/profile/index",
    "pages/book-detail/index",
    "pages/order-confirm/index",
    "pages/order-detail/index",
    "pages/webview/index",
    "pages/customer-service/index"
  ],
  "window": {
    "backgroundTextStyle": "light",
    "navigationBarBackgroundColor": "#2c5f2d",
    "navigationBarTitleText": "校园书",
    "navigationBarTextStyle": "white"
  },
  "tabBar": {
    "color": "#6b6b6b",
    "selectedColor": "#2c5f2d",
    "backgroundColor": "#ffffff",
    "borderStyle": "white",
    "list": [
      {
        "pagePath": "pages/market/index",
        "text": "市场",
        "iconPath": "images/tabs/marketplace.png",
        "selectedIconPath": "images/tabs/marketplace-active.png"
      },
      {
        "pagePath": "pages/orders/index",
        "text": "订单",
        "iconPath": "images/tabs/orders.png",
        "selectedIconPath": "images/tabs/orders-active.png"
      },
      {
        "pagePath": "pages/profile/index",
        "text": "我的",
        "iconPath": "images/tabs/profile.png",
        "selectedIconPath": "images/tabs/profile-active.png"
      }
    ]
  },
  "style": "v2",
  "sitemapLocation": "sitemap.json"
}


================================================================================
### FILE: miniprogram\app.wxss
================================================================================

/* app.wxss */

/* --- 1. 全局设计语言 (The Law) --- */
page {
  /* 色彩 (Color) */
  --primary-color: #2c5f2d;
  --text-primary: #1a1a1a;
  --text-secondary: #6b6b6b;
  --background-color: #f8f9fa;
  --card-background: #ffffff;
  --border-color: #e9ecef;
  --success-color: #28a745;
  --error-color: #dc3545;
  --warning-color: #ffc107;

  /* 排版 (Typography) */
  --font-size-display: 48rpx;
  --font-size-title: 36rpx;
  --font-size-body: 28rpx;
  --font-size-caption: 24rpx;
  --font-weight-normal: 400;
  --font-weight-bold: 600;

  /* 间距 (Spacing) */
  --space-xs: 8rpx;
  --space-s: 16rpx;
  --space-m: 24rpx;
  --space-l: 32rpx;
  --space-xl: 48rpx;

  /* 基础样式 */
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
  font-size: var(--font-size-body);
  color: var(--text-primary);
  background-color: var(--background-color);
  line-height: 1.6;
}

/* --- 2. 全局组件 (Components) --- */

/* 容器 */
.container {
  padding: var(--space-m) var(--space-l);
}

/* 卡片 */
.card {
  background-color: var(--card-background);
  border-radius: 24rpx;
  padding: var(--space-l);
  margin-bottom: var(--space-m);
  box-shadow: 0 4rpx 12rpx rgba(0, 0, 0, 0.05);
}

/* 按钮 */
.btn {
  display: inline-block;
  height: 88rpx;
  line-height: 88rpx;
  padding: 0 var(--space-l);
  border-radius: 16rpx;
  font-size: var(--font-size-body);
  font-weight: var(--font-weight-bold);
  text-align: center;
  vertical-align: middle;
  border: none;
  cursor: pointer;
  transition: opacity 0.2s;
}
.btn:active {
  opacity: 0.8;
}
.btn-primary {
  background-color: var(--primary-color);
  color: #ffffff;
}
.btn-sm {
  height: 60rpx;
  line-height: 60rpx;
  padding: 0 var(--space-s);
  font-size: var(--font-size-caption);
  border-radius: 12rpx;
}
.btn[disabled] {
  opacity: 0.5;
  pointer-events: none;
}

/* 状态标签 */
.status-tag {
  display: inline-block;
  padding: var(--space-xs) var(--space-s);
  border-radius: 8rpx;
  font-size: var(--font-size-caption);
  font-weight: var(--font-weight-bold);
  color: #ffffff;
}
.status-tag.success { background-color: var(--success-color); }
.status-tag.error { background-color: var(--error-color); }
.status-tag.warning { background-color: var(--warning-color); }

/* 全局点击反馈 */
.item-hover {
  background-color: rgba(0, 0, 0, 0.05);
}


================================================================================
### FILE: miniprogram\config.js
================================================================================

// miniprogram/config.js
const config = {
  apiBaseUrl: 'http://172.20.10.4:3000/api'
};

module.exports = config;


================================================================================
### FILE NOT FOUND: miniprogram\package.json
================================================================================


================================================================================
### FILE: miniprogram\pages\book-detail\index.js
================================================================================

// pages/book-detail/index.js
const auth = require('../../utils/auth');
const { request } = require('../../utils/api');

Page({
  data: {
    bookDetail: null,
    isLoading: true,
    error: null,
  },

  onLoad(options) {
    if (options.id) {
      this.fetchBookDetails(options.id);
    } else {
      this.setData({ error: '无效的书籍ID', isLoading: false });
    }
  },

  async fetchBookDetails(id) {
    this.setData({ isLoading: true, error: null });
    try {
      const data = await request({
        url: `/inventory/item/${id}`,
        method: 'GET'
      });
      this.setData({ bookDetail: data });
    } catch (error) {
      console.error('API request failed', error);
      this.setData({ error: error.error || '加载失败' });
      wx.showToast({
        title: error.error || '加载失败',
        icon: 'none'
      });
    } finally {
      this.setData({ isLoading: false });
    }
  },

  handleBuyNow() {
    const inventoryItemId = this.data.bookDetail.id;
    wx.navigateTo({
      url: `/pages/order-confirm/index?id=${inventoryItemId}`,
    });
  }
});


================================================================================
### FILE: miniprogram\pages\market\index.js
================================================================================

// pages/market/index.js
const auth = require('../../utils/auth');
const { request } = require('../../utils/api');

Page({
  data: {
    bookList: [],
    isLoading: true,
    error: null,
    searchTerm: '',
    searchPerformed: false // To show different empty state messages
  },

  onLoad(options) {
    this.fetchAvailableBooks();
  },

  // MODIFIED: fetchAvailableBooks now takes a search term
  async fetchAvailableBooks() {
    this.setData({ isLoading: true, error: null });
    let url = `/inventory/available`;
    if (this.data.searchTerm) {
      url += `?search=${encodeURIComponent(this.data.searchTerm)}`;
    }

    try {
      const data = await request({
        url: url,
        method: 'GET'
      });
      this.setData({ bookList: data });
    } catch (error) {
      console.error('API request failed', error);
      this.setData({ 
        error: error.error || '加载失败', 
        bookList: [] 
      });
      wx.showToast({
        title: error.error || '加载失败',
        icon: 'none'
      });
    } finally {
      this.setData({ isLoading: false });
    }
  },

  // NEW: Handle input change
  handleInput(e) {
    this.setData({
      searchTerm: e.detail.value
    });
  },

  // NEW: Handle search button tap or keyboard confirm
  handleSearch() {
    this.setData({ searchPerformed: true });
    this.fetchAvailableBooks();
  },

  // Pull down refresh
  async onPullDownRefresh() {
    await this.fetchAvailableBooks();
    wx.stopPullDownRefresh();
  }
});


================================================================================
### FILE: miniprogram\pages\order-confirm\index.js
================================================================================

// pages/order-confirm/index.js
const auth = require('../../utils/auth');
const api = require('../../utils/api');

function promisifiedPayment(options) {
  return new Promise((resolve, reject) => {
    wx.requestPayment({
      ...options,
      success: resolve,
      fail: reject
    });
  });
}

Page({
  data: {
    book: null,
    isLoading: true,
    error: null,
    isSubmitting: false
  },
  
  onLoad(options) {
    if (options.id) {
      this.fetchBookDetails(options.id);
    } else {
      this.setData({ isLoading: false, error: '无效的商品ID' });
    }
  },

  async fetchBookDetails(id) {
    this.setData({ isLoading: true, error: null });
    
    try {
      const data = await api.request({
        url: `/inventory/item/${id}`,
        method: 'GET'
      });
      
      if (data.status === 'in_stock') {
        this.setData({ book: data });
      } else {
        this.setData({ error: '该书籍已售出或不可用' });
      }
    } catch (error) {
      this.setData({ error: error.error || '网络请求失败，无法获取书籍信息' });
    } finally {
      this.setData({ isLoading: false });
    }
  },
  
  async handlePayment() {
    if (this.data.isSubmitting || !this.data.book) return;
    this.setData({ isSubmitting: true });

    const userId = auth.getUserId();
    const inventoryItemId = this.data.book.id;

    if (!userId) {
      wx.showToast({ title: '登录信息失效，请重启小程序', icon: 'none' });
      this.setData({ isSubmitting: false });
      return;
    }

    try {
      wx.showLoading({ title: '正在创建订单...' });

      const createData = await api.request({
        url: '/orders/create',
        method: 'POST',
        data: { inventoryItemIds: [inventoryItemId] }
      });

      const orderId = createData.id;
      wx.showLoading({ title: '获取支付参数...' });

      const payParams = await api.request({
        url: `/orders/${orderId}/pay`,
        method: 'POST' // body为空，所有信息都在JWT里
      });

      wx.hideLoading();

      try {
        await promisifiedPayment(payParams); // 直接使用后端返回的签名参数
        wx.showToast({ title: '支付成功', icon: 'success' });
        setTimeout(() => {
          wx.switchTab({ url: '/pages/orders/index' });
        }, 1500);
      } catch (paymentError) {
        wx.showToast({ title: '支付已取消', icon: 'none' });
        this.setData({ isSubmitting: false });
      }

    } catch (error) {
      wx.hideLoading();
      wx.showToast({ title: error.error || '网络请求失败', icon: 'error' });
      this.setData({ isSubmitting: false });
    }
  }
});


================================================================================
### FILE: miniprogram\pages\orders\index.js
================================================================================

// pages/orders/index.js
const auth = require('../../utils/auth');
const { request } = require('../../utils/api');
const { ORDER_STATUS } = require('../../utils/constants');

Page({
  data: {
    orderList: [],
    isLoading: true,
    error: null,
    statusMap: ORDER_STATUS,
  },
  onShow() { this.fetchUserOrders(); },
  navigateToDetail(event) {
    const orderId = event.currentTarget.dataset.orderId;
    if (orderId) {
      wx.navigateTo({
        url: `/pages/order-detail/index?id=${orderId}`
      });
    }
  },
  async fetchUserOrders() {
    const userId = auth.getUserId();
    if (!userId) { return; }
    this.setData({ isLoading: true, error: null });
    
    try {
      const data = await request({
        url: `/orders/user/${userId}`,
        method: 'GET'
      });
      this.setData({ orderList: data });
    } catch (error) {
      this.setData({ error: error.error || '加载订单失败。' });
    } finally {
      this.setData({ isLoading: false });
    }
  },

  // Pull down refresh
  async onPullDownRefresh() {
    await this.fetchUserOrders();
    wx.stopPullDownRefresh();
  }
});


================================================================================
### FILE: miniprogram\utils\auth.js
================================================================================

// utils/auth.js
const { request } = require('./api');
const TOKEN_KEY = 'authToken';
const USER_ID_KEY = 'userId';

const login = () => {
  return new Promise((resolve, reject) => {
    wx.login({
      success: async (res) => {
        if (res.code) {
          try {
            const data = await request({
              url: '/auth/login',
              method: 'POST',
              data: {
                code: res.code
              }
            });
            
            if (data.token) {
              setToken(data.token);
              setUserId(data.userId);
              resolve(data);
            } else {
              reject(new Error('Login failed on server.'));
            }
          } catch (error) {
            reject(new Error(error.error || 'Login failed on server.'));
          }
        } else {
          reject(new Error('wx.login failed, no code returned.'));
        }
      },
      fail: (err) => {
        reject(err);
      }
    });
  });
};

const setToken = (token) => wx.setStorageSync(TOKEN_KEY, token);
const getToken = () => wx.getStorageSync(TOKEN_KEY);
const setUserId = (userId) => wx.setStorageSync(USER_ID_KEY, userId);
const getUserId = () => wx.getStorageSync(USER_ID_KEY);
const logout = () => {
  wx.removeStorageSync(TOKEN_KEY);
  wx.removeStorageSync(USER_ID_KEY);
};

module.exports = {
  login,
  getToken,
  getUserId,
  logout
};


================================================================================
CORE CODE REVIEW REPORT GENERATION COMPLETE.
================================================================================
