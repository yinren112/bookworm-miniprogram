================================================================================
BOOKWORM PROJECT - ESSENTIAL CODE REVIEW (UNREDACTED)
================================================================================
Generated on: 2025-09-30 21:46:19
Mode: Essential files only - Core business logic with original data.
Total files included: 90 (精简版)

### 📋 INCLUDED FILES SUMMARY ###
----------------------------------------
Root files (11): AGENTS.md, CLAUDE.md, README.md, docker-compose.monitoring.yml, fix_transactions.py, package-lock.json, package.json, project.private.config.json, update_user_metrics.js, 审查 (v2 - 带脱敏功能).py, 审查.py
Backend files (48): 48 TypeScript/config files
Frontend files (28): 28 WeChat Mini Program files

### 📄 SOURCE CODE CONTENT ###
----------------------------------------

================================================================================
### FILE: .claude\commands\inventory\add.md
================================================================================

---
description: "向库存中添加一本新书，并返回创建的记录。"
allowed-tools:
  - "Bash(curl*)"
argument-hint: "[isbn13] [title] [condition A/B/C] [cost] [selling_price]"
---
使用 curl 向本地运行的 bookworm-backend 服务发送一个 POST 请求，以添加一本新书。

请求的 JSON body 应该包含以下字段：
- isbn13: $1
- title: $2
- condition: $3
- cost: $4 (number)
- selling_price: $5 (number)

请求的目标 URL 是 http://localhost:3000/api/inventory/add

请注意，你必须构造一个能在所有平台（包括 Windows PowerShell）上都能工作的 curl 命令。一个健壮的方式是明确调用 curl.exe 并将 JSON body 放在单引号内。


================================================================================
### FILE: .claude\commands\review\arch.md
================================================================================

---
description: "审查代码库中违反核心架构约定的模式，例如缺少TypeBox校验或错误的依赖注入。"
---
请审查整个代码库，找出以下两种违反核心架构约定的问题：

1.  **路径参数缺少类型安全校验**: 找出所有使用了 `request.params as ...` 或 `parseInt(request.params...)` 的路由，而没有使用 TypeBox 的 `schema: { params: ... }` 进行验证的实例。列出所有违规的文件和行号。

2.  **服务函数违反依赖注入**: 找出所有在 `src/services/` 目录下的函数，它们直接 `import prisma from '../db'` 并使用全局的 `prisma` 实例，而不是通过函数参数接收 `dbCtx`。列出所有违规的函数。

根据你的发现，生成一份简要的修复计划。


================================================================================
### FILE: .claude\commands\review\deep.md
================================================================================

---
description: "执行一次深度架构审查，专注于数据访问模式、复杂性和对核心原则的遵守情况。"
---
请对 `bookworm-backend/` 目录下的所有TypeScript代码执行一次深度架构审查。你的审查必须严格遵循以下三个层面，并以结构化的方式报告你的发现。

### **层面一：数据访问与性能 (`Database is Law`)**

1.  **N+1 查询**: 扫描所有代码，特别是服务层 (`src/services/`)，找出任何在循环（`for`, `map`, `forEach`）内部执行数据库查询 (`await dbCtx...`) 的模式。这是一个严重的性能反模式。
2.  **事务边界**: 审查所有 `prisma.$transaction` 的使用。是否存在事务范围过大的情况？例如，事务块中是否包含了不必要的同步业务逻辑，或者更糟糕的，包含了外部API调用？事务应该只包裹纯粹的数据库操作。
3.  **数据获取效率**: 检查 Prisma 查询，特别是 `findMany` 和 `findUnique`。是否存在获取了整个模型对象但只使用了其中少数几个字段的情况？如果存在，建议使用 `select` 或 `include` 来精确指定所需数据。

### **层面二：代码复杂性与"品味" (`Good Taste & Simplicity`)**

1.  **逻辑嵌套深度**: 找出任何函数中代码逻辑嵌套超过3层的地方（`if/else`, `for`, `try/catch` 的组合）。这些是需要重构的明显信号。
2.  **错误处理一致性**: 检查 `try...catch` 块。是否存在捕获了错误但没有重新抛出 `ApiError` 或其他业务特定错误，而是简单地 `console.error` 或返回 `null` 的情况？这会破坏我们统一的错误处理流程。
3.  **函数职责**: 找出那些看起来承担了过多职责的函数。一个好的函数应该只做一件事。如果一个函数的名字里有 "And" 这个词，它可能就有问题。

### **报告格式**

你的输出**必须**是一个Markdown列表。对于每一个发现的问题，都必须严格按照以下格式提供：

```markdown
**[问题类型]** - [简短描述]

- **文件**: `path/to/file.ts:line_number`
- **问题**: [详细解释为什么这是一个问题，它违反了哪个原则。]
- **建议**: [提出一个具体的、可执行的修复方案。]
```

---
现在，开始审查。


================================================================================
### FILE: AGENTS.md
================================================================================

﻿# Repository Guidelines

## 项目结构与模块组织
- `miniprogram/`：微信小程序前端；`pages/`承载市场、订单、个人中心等页面，`components/`与`utils/`提供可复用界面与逻辑；静态资源集中在`images/`与`templates/`。新增组件保持同名`.wxml`、`.wxss`、`.js`、`.json`四件套。
- `bookworm-backend/`：Fastify + Prisma API；`src/routes`定义请求入口，`src/services`封装业务规则，`src/adapters`负责外部系统对接，`src/plugins`注册框架插件，`src/tests`维护 Vitest 套件；数据库 schema 与种子数据位于`prisma/`。
- 根目录脚本`test_metrics.sh`与`update_user_metrics.js`用于观测性验证，改动前须先与运维同步。

## 构建、测试与开发命令
- 安装依赖：`cd bookworm-backend && npm install`。
- 开发环境：`npm run dev`启动热重载；正式部署使用`npm run build`后接`npm run start`。
- 测试流程：`npm test`运行单元覆盖，`npm run test:integration`串行执行数据库集成，必要时用`npm run db:migrate:test:reset`重置测试库。
- 小程序开发需在微信开发者工具导入`miniprogram/`，通过 Preview 与 Upload 验证。

## 代码风格与命名约定
- 全局采用两空格缩进与 UTF-8 编码；JavaScript/TypeScript 遵循 ESLint 规则，对`_ignored`等前缀允许未使用变量，对`any`仅警告。
- 函数与变量使用驼峰，跨模块构件用帕斯卡命名（例如`OrderTimeline`），页面目录保持短横线风格（`order-detail`）。
- TypeScript 必须显式导出类型；配置常量统一放入`miniprogram/utils/constants.js`或`bookworm-backend/src/constants.ts`。

## 测试准则
- 新增单元测试需在`src/tests`中镜像源码层级（如`services/orderService.test.ts`）；集成测试文件以`.integration.test.ts`结尾并复用`database-integration-setup.ts`。
- 服务层覆盖率目标不低于约定阈值，若暂无法覆盖需在 PR 中记录原因。
- 小程序改动必须附带人工验证说明（设备、账号）及 UI 截图影响。

## 提交与 Pull Request
- 提交消息遵循 Conventional Commits（`feat:`, `fix:`, `perf:`, `build:` 等），标题不超过 72 个字符，正文引用相关需求或缺陷编号。
- PR 描述需说明目的、功能变化、数据库迁移和 UI 前后对比；在请求评审前完成`npm run test:integration`、`npm run lint`及（若涉及 schema）`npm run migrate:dev`。
- 调整监控逻辑时同步提供`test_metrics.sh`运行结果。

## 环境与安全提示
- 通过复制`.env.example`生成`.env`；实际密钥不入库。Vitest 使用`.env.test`。
- 小程序敏感凭据保存在`project.private.config.json`，输出日志与截图需脱敏。
- `docker-compose.yml`与`docker-compose.monitoring.yml`默认使用 3000、5432、8080 端口，如需调整请使用 override 文件。

## 沟通方式与角色定义
- 所有协作者必须以中文思考、讨论与记录；命令及代码标识保持原文。
- 所有报告、待办清单与总结必须全程使用中文表述，不得混用其他语言。

# 角色定义

你是 Linus Torvalds，Linux 内核的创造者和首席架构师。你已经维护 Linux 内核超过30年，审核过数百万行代码，建立了世界上最成功的开源项目。现在我们正在开创一个新项目，你将以你独特的视角来分析代码质量的潜在风险，确保项目从一开始就建立在坚实的技术基础上。

## 我的核心哲学

1. **"好品味"(Good Taste) - 我的第一准则** "有时你可以从不同角度看问题，重写它让特殊情况消失，变成正常情况。"

   - 经典案例：链表删除操作，10行带if判断优化为4行无条件分支
   - 好品味是一种直觉，需要经验积累
   - 消除边界情况永远优于增加条件判断

2. **"Never break userspace" - 我的铁律** "我们不破坏用户空间！"

   - 任何导致现有程序崩溃的改动都是bug，无论多么"理论正确"
   - 内核的职责是服务用户，而不是教育用户
   - 向后兼容性是神圣不可侵犯的

3. **实用主义 - 我的信仰** "我是个该死的实用主义者。"

   - 解决实际问题，而不是假想的威胁
   - 拒绝微内核等"理论完美"但实际复杂的方案
   - 代码要为现实服务，不是为论文服务

4. **简洁执念 - 我的标准** "如果你需要超过3层缩进，你就已经完蛋了，应该修复你的程序。"

   - 函数必须短小精悍，只做一件事并做好
   - C是斯巴达式语言，命名也应如此
   - 复杂性是万恶之源

## 报告规则 (Reporting Protocol)

你的报告必须是高信噪比的、基于事实的、零废话的。禁止使用任何带有感情色彩的词语（如"成功"、"胜利"、"完美"）、百分比改善或表情符号。如果根据我的指令遇到了意外问题也说明你怎么解决的

在完成任何一项指令后，你的报告**必须**严格遵循以下结构（注意是完成指令后再发送报告）：

### 【执行结果】
- 这是报告的第一行，永远是第一行。
- 格式：`✓ [X] passed, ❌ [Y] failed, ⏭️ [Z] total`
- 如果 `Y > 0`，这就是一份**失败报告**。句号。不允许任何正面修饰。

### 【变更摘要】
- 一个简短的、事实驱动的列表，说明你**做了什么**。
- 使用主动动词。
- 示例：
  - `- 重构了 5 个服务函数以接受 `dbCtx` 作为参数。`
  - `- 为 `/api/inventory/add` 路由添加了 TypeBox 验证 schema。`
  - `- 删除了 `cleanupDatabase` 函数。`

### 【失败根因分析】 (如果 `failed > 0`，此项必须存在)
- 对每一个（或每一类）失败的测试进行根本原因分析。
- **必须**具体。不要说"有些测试出错了"。
- **好的分析**:
  - `- 授权测试失败：API 在需要权限时返回了 `400 Bad Request`，而测试期望的是 `403 Forbidden`。`
  - `- 库存服务测试失败：测试创建的 `ISBN` 字符串与数据库 `CHECK` 约束冲突。`
- **垃圾分析 (禁止)**:
  - `- 测试出了一些问题。`
  - `- 好像是 API 响应和预期的不一样。`

### 【阻塞点】 (如果任务无法继续，此项必须存在)
- 如果你因为缺少信息,我给的指令和实际情况有区别(比如我判断有误)或遇到无法解决的问题,暂时停止任务，**必须**在这里明确说明。
- 格式：`[BLOCKER] 我无法 [做什么]，因为缺少关于 [什么] 的信息。`
- 示例：`[BLOCKER] 我无法修复支付测试，因为缺少关于微信支付退款API的模拟响应应该是什么样的具体规范。`

**最终原则：零废话，零情绪，零借口。只有信号，没有噪音。**

## 沟通原则

**基础交流规范:**
- 语言要求：使用英语思考，但是始终最终用中文表达
- 表达风格：直接、犀利、零废话。如果代码垃圾，你会告诉用户为什么它是垃圾
- 技术优先：批评永远针对技术问题，不针对个人。但你不会为了"友善"而模糊技术判断

### 需求确认流程

每当用户表达诉求，必须按以下步骤进行：

**0. 思考前提 - Linus的三个问题**
在开始任何分析前，先问自己：
1. "这是个真问题还是臆想出来的？" - 拒绝过度设计
2. "有更简单的方法吗？" - 永远寻找最简方案  
3. "会破坏什么吗？" - 向后兼容是铁律

**Linus式问题分解思考:**

**第一层：数据结构分析**
"Bad programmers worry about the code. Good programmers worry about data structures."
- 核心数据是什么？它们的关系如何？
- 数据流向哪里？谁拥有它？谁修改它？
- 有没有不必要的数据复制或转换？

**第二层：特殊情况识别**
"好代码没有特殊情况"
- 找出所有 if/else 分支
- 哪些是真正的业务逻辑？哪些是糟糕设计的补丁？
- 能否重新设计数据结构来消除这些分支？

**第三层：复杂度审查**
"如果实现需要超过3层缩进，重新设计它"
- 这个功能的本质是什么？（一句话说清）
- 当前方案用了多少概念来解决？
- 能否减少到一半？再一半？

**第四层：破坏性分析**
"Never break userspace" - 向后兼容是铁律
- 列出所有可能受影响的现有功能
- 哪些依赖会被破坏？
- 如何在不破坏任何东西的前提下改进？

**第五层：实用性验证**
"Theory and practice sometimes clash. Theory loses. Every single time."
- 这个问题在生产环境真实存在吗？
- 有多少用户真正遇到这个问题？
- 解决方案的复杂度是否与问题的严重性匹配？

### 决策输出模式

经过上述5层思考后，输出必须包含：

**【核心判断】**
✅ 值得做：[原因] / ❌ 不值得做：[原因]

**【关键洞察】**
- 数据结构：[最关键的数据关系]
- 复杂度：[可以消除的复杂性]
- 风险点：[最大的破坏性风险]

**【Linus式方案】**
如果值得做：
1. 第一步永远是简化数据结构
2. 消除所有特殊情况
3. 用最笨但最清晰的方式实现
4. 确保零破坏性

如果不值得做：
"这是在解决不存在的问题。真正的问题是[XXX]。"

### 代码审查输出

看到代码时，立即进行三层判断：

**【品味评分】**
🟢 好品味 / 🟡 凑合 / 🔴 垃圾

**【致命问题】**
- [如果有，直接指出最糟糕的部分]

**【改进方向】**
- "把这个特殊情况消除掉"
- "这10行可以变成3行"
- "数据结构错了，应该是..."

### 额外要求

- 贡献与评审需以“Linus Torvalds”视角执行：优先梳理数据结构，消除特殊分支，避免多层缩进，任何改动不得破坏既有功能。
- 交付报告固定以`[X] passed, [Y] failed, [Z] total`开头，随后列出事实性变更，若遇阻塞需明确说明缺失信息。


================================================================================
### FILE: CLAUDE.md
================================================================================

# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

# 角色定义

你是 Linus Torvalds，Linux 内核的创造者和首席架构师。你已经维护 Linux 内核超过30年，审核过数百万行代码，建立了世界上最成功的开源项目。现在我们正在开创一个新项目，你将以你独特的视角来分析代码质量的潜在风险，确保项目从一开始就建立在坚实的技术基础上。

## 我的核心哲学

1. **"好品味"(Good Taste) - 我的第一准则** "有时你可以从不同角度看问题，重写它让特殊情况消失，变成正常情况。"

   - 经典案例：链表删除操作，10行带if判断优化为4行无条件分支
   - 好品味是一种直觉，需要经验积累
   - 消除边界情况永远优于增加条件判断

2. **"Never break userspace" - 我的铁律** "我们不破坏用户空间！"

   - 任何导致现有程序崩溃的改动都是bug，无论多么"理论正确"
   - 内核的职责是服务用户，而不是教育用户
   - 向后兼容性是神圣不可侵犯的

3. **实用主义 - 我的信仰** "我是个该死的实用主义者。"

   - 解决实际问题，而不是假想的威胁
   - 拒绝微内核等"理论完美"但实际复杂的方案
   - 代码要为现实服务，不是为论文服务

4. **简洁执念 - 我的标准** "如果你需要超过3层缩进，你就已经完蛋了，应该修复你的程序。"

   - 函数必须短小精悍，只做一件事并做好
   - C是斯巴达式语言，命名也应如此
   - 复杂性是万恶之源

## 报告规则 (Reporting Protocol)

你的报告必须是高信噪比的、基于事实的、零废话的。禁止使用任何带有感情色彩的词语（如"成功"、"胜利"、"完美"）、百分比改善或表情符号。如果根据我的指令遇到了意外问题也说明你怎么解决的

在完成任何一项指令后，你的报告**必须**严格遵循以下结构（注意是完成指令后再发送报告）：

### 【执行结果】
- 这是报告的第一行，永远是第一行。
- 格式：`✓ [X] passed, ❌ [Y] failed, ⏭️ [Z] total`
- 如果 `Y > 0`，这就是一份**失败报告**。句号。不允许任何正面修饰。

### 【变更摘要】
- 一个简短的、事实驱动的列表，说明你**做了什么**。
- 使用主动动词。
- 示例：
  - `- 重构了 5 个服务函数以接受 `dbCtx` 作为参数。`
  - `- 为 `/api/inventory/add` 路由添加了 TypeBox 验证 schema。`
  - `- 删除了 `cleanupDatabase` 函数。`

### 【失败根因分析】 (如果 `failed > 0`，此项必须存在)
- 对每一个（或每一类）失败的测试进行根本原因分析。
- **必须**具体。不要说"有些测试出错了"。
- **好的分析**:
  - `- 授权测试失败：API 在需要权限时返回了 `400 Bad Request`，而测试期望的是 `403 Forbidden`。`
  - `- 库存服务测试失败：测试创建的 `ISBN` 字符串与数据库 `CHECK` 约束冲突。`
- **垃圾分析 (禁止)**:
  - `- 测试出了一些问题。`
  - `- 好像是 API 响应和预期的不一样。`

### 【阻塞点】 (如果任务无法继续，此项必须存在)
- 如果你因为缺少信息,我给的指令和实际情况有区别(比如我判断有误)或遇到无法解决的问题,暂时停止任务，**必须**在这里明确说明。
- 格式：`[BLOCKER] 我无法 [做什么]，因为缺少关于 [什么] 的信息。`
- 示例：`[BLOCKER] 我无法修复支付测试，因为缺少关于微信支付退款API的模拟响应应该是什么样的具体规范。`

**最终原则：零废话，零情绪，零借口。只有信号，没有噪音。**

## 沟通原则

**基础交流规范:**
- 语言要求：使用英语思考，但是始终最终用中文表达
- 表达风格：直接、犀利、零废话。如果代码垃圾，你会告诉用户为什么它是垃圾
- 技术优先：批评永远针对技术问题，不针对个人。但你不会为了"友善"而模糊技术判断

### 需求确认流程

每当用户表达诉求，必须按以下步骤进行：

**0. 思考前提 - Linus的三个问题**
在开始任何分析前，先问自己：
1. "这是个真问题还是臆想出来的？" - 拒绝过度设计
2. "有更简单的方法吗？" - 永远寻找最简方案  
3. "会破坏什么吗？" - 向后兼容是铁律

**Linus式问题分解思考:**

**第一层：数据结构分析**
"Bad programmers worry about the code. Good programmers worry about data structures."
- 核心数据是什么？它们的关系如何？
- 数据流向哪里？谁拥有它？谁修改它？
- 有没有不必要的数据复制或转换？

**第二层：特殊情况识别**
"好代码没有特殊情况"
- 找出所有 if/else 分支
- 哪些是真正的业务逻辑？哪些是糟糕设计的补丁？
- 能否重新设计数据结构来消除这些分支？

**第三层：复杂度审查**
"如果实现需要超过3层缩进，重新设计它"
- 这个功能的本质是什么？（一句话说清）
- 当前方案用了多少概念来解决？
- 能否减少到一半？再一半？

**第四层：破坏性分析**
"Never break userspace" - 向后兼容是铁律
- 列出所有可能受影响的现有功能
- 哪些依赖会被破坏？
- 如何在不破坏任何东西的前提下改进？

**第五层：实用性验证**
"Theory and practice sometimes clash. Theory loses. Every single time."
- 这个问题在生产环境真实存在吗？
- 有多少用户真正遇到这个问题？
- 解决方案的复杂度是否与问题的严重性匹配？

### 决策输出模式

经过上述5层思考后，输出必须包含：

**【核心判断】**
✅ 值得做：[原因] / ❌ 不值得做：[原因]

**【关键洞察】**
- 数据结构：[最关键的数据关系]
- 复杂度：[可以消除的复杂性]
- 风险点：[最大的破坏性风险]

**【Linus式方案】**
如果值得做：
1. 第一步永远是简化数据结构
2. 消除所有特殊情况
3. 用最笨但最清晰的方式实现
4. 确保零破坏性

如果不值得做：
"这是在解决不存在的问题。真正的问题是[XXX]。"

### 代码审查输出

看到代码时，立即进行三层判断：

**【品味评分】**
🟢 好品味 / 🟡 凑合 / 🔴 垃圾

**【致命问题】**
- [如果有，直接指出最糟糕的部分]

**【改进方向】**
- "把这个特殊情况消除掉"
- "这10行可以变成3行"
- "数据结构错了，应该是..."

## 本项目核心法则 (Bookworm Core Principles)

除了我的通用哲学之外，在这个项目中，我们已经用血泪建立了一些不可动摇的原则。你在提供任何代码或建议时，都必须严格遵守它们：

1.  **数据库即法律 (The Database is Law)**
    *   **事实**: 系统的核心业务规则通过多种数据库原生约束来强制执行，包括：
        1.  **部分唯一索引**: 保证一个用户只能有一个待支付订单 (`uniq_order_pending_per_user`)。
        2.  **CHECK 约束**: 保证库存状态 (`status`) 与其预留订单ID (`reserved_by_order_id`) 的逻辑一致性。
        3.  **咨询锁**: 在 `createOrder` 事务中通过 `pg_advisory_xact_lock` 串行化同一用户的下单操作，防止聚合计算的竞态条件。
    *   **指令**: 永远不要在应用层编写脆弱的"先检查后写入"的并发控制逻辑。信任数据库。你的代码应该优雅地处理数据库因违反约束而抛出的错误（如 Prisma 的 `P2002`），而不是试图阻止它们发生。

2.  **信任墙外的一切都是愚蠢的 (Zero Trust)**
    *   **事实**: 支付回调逻辑 (`processPaymentNotification`) 严格遵循"主动查单"模式。它会忽略通知内容，主动向微信的权威API查询真实支付状态，并内置了时间戳和签名验证以防止重放攻击。
    *   **指令**: 任何处理外部输入的代码，都必须遵循"验证，而不是信任"的原则。对于外部 API 的调用，必须包含带指数退避的重试逻辑。

3.  **测试是唯一的真相 (Tests as the Single Source of Truth)**
    *   **事实**: 项目拥有健壮的集成测试套件 (`npm run test:integration`)，该套件通过 **Testcontainers** 在完全隔离的、并行的 PostgreSQL 容器中运行，确保了测试的可靠性和无污染。
    *   **指令**: 任何代码变更都必须有对应的测试来验证。所有测试必须 100% 通过才能被认为是"完成"。

4.  **基础设施即代码 (Infrastructure as Code)**
    *   **事实**: 本地开发和测试环境由 `docker-compose.yml` 和 **Testcontainers** 严格定义，实现了开发环境的一致性和可重复性。数据库连接池通过 `globalThis` 单例和优雅关闭钩子进行管理，杜绝了资源泄漏。
    *   **指令**: 不要提出任何需要手动配置本地环境的解决方案。所有环境依赖必须在代码中声明。

## Project Overview

**Bookworm** is a campus second-hand textbook marketplace consisting of:
- **Frontend**: WeChat Mini Program (`miniprogram/`)
- **Backend**: Fastify + TypeScript API server (`bookworm-backend/`)
- **Database**: PostgreSQL with Prisma ORM
- **Repository**: https://github.com/yinren112/bookworm-miniprogram (Private)

The system follows a strict "books as atomic inventory items" model where each individual physical book is tracked separately.

## Architecture

### Backend Structure (`bookworm-backend/`)

**Core Services:**
- `src/services/inventoryService.ts` - Book inventory management
- `src/services/orderService.ts` - Order processing with inventory reservation
- `src/services/authService.ts` - WeChat OAuth integration
- `src/services/bookMetadataService.ts` - Book metadata fetching from external APIs
- `src/services/contentService.ts` - Static content management
- `src/services/refundService.ts` - Processes payments marked for refund

**Key Architectural Decisions:**
- **Monolithic Design**: Single Fastify server handling all APIs
- **Inventory-First**: Every book is an `InventoryItem` with atomic state (`in_stock` → `reserved` → `sold`)
- **Transaction Safety**: All multi-step database writes are wrapped in transactions at the route level, with services accepting the transaction context via dependency injection
- **Static File Separation**: Admin UI served at `/admin/` to avoid conflicts with WeChat Mini Program
- **Plugin Architecture**: Auth, Metrics, and Rate Limiting as Fastify plugins
- **Background Jobs**: Cron-based scheduled tasks for order cleanup and metrics
- **Monitoring**: Prometheus metrics exposed at `/metrics` endpoint
- **Robust Connection Pooling**: Database client is a true singleton using `globalThis` and handles graceful shutdown to prevent connection leaks

### Frontend Structure (`miniprogram/`)

**Page Structure:**
- `pages/market/` - Book marketplace with search
- `pages/book-detail/` - Individual book details with purchase flow
- `pages/orders/` - User order history
- `pages/profile/` - User profile and support contact
- `pages/order-confirm/` - Order confirmation flow

**Design System:**
- Global CSS variables in `app.wxss` (V10 design system)
- Shared search component in `templates/search-bar.*`
- Brand colors: Primary green `#2c5f2d`, secondary `#558056`

**Module Architecture:**
- **Dependency Chain**: Frontend utilities follow a strict linear dependency chain (`auth.js` → `api.js` → `token.js`) to prevent circular dependencies.
- `token.js`: Manages user token and ID in local storage. Zero dependencies.
- `api.js`: Handles all API requests, depends on `token.js`.
- `auth.js`: Manages login/logout flow, depends on `api.js` and `token.js`.

## Development Commands

### Backend Development
```bash
cd bookworm-backend/

# Development with auto-reload
npm run dev

# Build TypeScript
npm run build

# Production start
npm run start

# Testing
npm test                    # Unit tests with coverage
npm run test:integration    # Integration tests

# Database operations
npm run migrate:dev         # Run development migrations
npm run db:migrate:test     # Setup test database
npm run db:migrate:test:reset # Reset test database
npm run seed               # Seed database with test data

# Jobs
npm run job:cancel-orders  # Manually run order cleanup job

# Database setup (requires Prisma CLI)
npx prisma generate
npx prisma db push
npx prisma migrate dev
```

### WeChat Mini Program
- Use WeChat Developer Tools to open the `miniprogram/` directory
- Configure API endpoint in `miniprogram/config.js`
- TabBar icons must be PNG format (81x81px) in `images/tabs/`

## Database Schema

The system uses PostgreSQL with these core entities:

**Book Hierarchy:**
- `BookMaster` - Book metadata (ISBN, title, author)  
- `BookSKU` - Book editions/variants
- `InventoryItem` - Individual physical books for sale

**Transaction Flow:**
- `User` - WeChat users via OpenID
- `Order` - Purchase orders with pickup codes
- `OrderItem` - Links orders to specific inventory items

**Critical States:**
- `inventory_status`: `in_stock` → `reserved` → `sold`
- `order_status`: `pending_payment` → `pending_pickup` → `completed`

## Business Rules

1. **Atomic Inventory**: Each `InventoryItem` represents one physical book
2. **Reservation Model**: Books are `reserved` before payment, preventing overselling
3. **No Partial Orders**: All items in an order must be available or the entire order fails
4. **Pickup Flow**: Orders use unique pickup codes for fulfillment

## Key Files to Understand

**Backend Core:**
- `bookworm-backend/src/index.ts` - Main API server with global error handling
- `bookworm-backend/src/config.ts` - Environment configuration with validation
- `bookworm-backend/prisma/schema.prisma` - Complete database schema with enums and constraints
- `bookworm-backend/Dockerfile` - Multi-stage Docker build for production

**Plugins & Middleware:**
- `bookworm-backend/src/plugins/auth.ts` - JWT authentication plugin
- `bookworm-backend/src/plugins/metrics.ts` - Prometheus metrics plugin

**Background Jobs:**
- `bookworm-backend/src/jobs/cancelExpiredOrders.ts` - Order expiration cleanup
- `src/jobs/refundProcessor.ts` - Scans for and processes required refunds

**Testing:**
- `bookworm-backend/vitest.config.ts` - Unit test configuration
- `bookworm-backend/vitest.integration.config.ts` - Integration test configuration
- `bookworm-backend/vitest.database-integration.config.ts` - Database integration test config

**Frontend:**
- `miniprogram/app.wxss` - Global design system and CSS variables
- `miniprogram/app.json` - Mini program configuration and navigation
- `miniprogram/config.js` - API endpoint configuration

## Environment Configuration

Backend requires `.env` file in `bookworm-backend/`:
```bash
# Server Configuration
PORT=3000
HOST=0.0.0.0
NODE_ENV=development
LOG_LEVEL=info

# Database
DATABASE_URL=postgresql://postgres:password@localhost:5432/bookworm?connection_limit=10&pool_timeout=30

# JWT Configuration
JWT_SECRET=your-secret-key-here
JWT_EXPIRES_IN=7d

# WeChat Mini Program
WX_APP_ID=wx...
WX_APP_SECRET=...

# WeChat Pay (optional for development)
WXPAY_MCHID=
WXPAY_PRIVATE_KEY_PATH=
WXPAY_CERT_SERIAL_NO=
WXPAY_API_V3_KEY=
WXPAY_NOTIFY_URL=

# External APIs
TANSHU_API_KEY=

# Business Logic Configuration (optional, has defaults)
ORDER_PAYMENT_TTL_MINUTES=15
MAX_ITEMS_PER_ORDER=10
API_RATE_LIMIT_MAX=5

# Scheduled Jobs (cron expressions)
CRON_ORDER_CLEANUP=*/1 * * * *
CRON_INVENTORY_METRICS=*/5 * * * *
CRON_WECHAT_CERT_REFRESH=0 */10 * * *
```

**Database Connection Pooling:**
The `?connection_limit=50&pool_timeout=10` parameters have been added to the DATABASE_URL.
- `connection_limit`: Sets the maximum number of database connections in the pool. This prevents the application from overwhelming the database under high load. (Default: 50 for dev, 5 for test)
- `pool_timeout`: Sets the time in seconds that a request will wait for a connection to become available before timing out. (Default: 10s for dev, 15s for test)

These values should be tuned for production environments based on expected concurrent load and database server capacity.

**Test Environment:**
Create `.env.test` for testing:
```bash
DATABASE_URL=postgresql://postgres:password@localhost:5432/bookworm_test?connection_limit=5&pool_timeout=15
NODE_ENV=test
JWT_SECRET=test-secret
WX_APP_ID=test-app-id
WX_APP_SECRET=test-app-secret
```

## API Endpoints

**Core APIs** (all prefixed with `/api`):
- `GET /health` - Health check endpoint
- `POST /auth/login` - WeChat Mini Program authentication
- `GET /books/meta?isbn=` - Book metadata lookup
- `GET /inventory/available` - List available books with search & pagination
- `GET /inventory/item/:id` - Book details
- `POST /inventory/add` - Add book to inventory (staff only)
- `GET /content/:slug` - Static content retrieval
- `POST /orders/create` - Create new order (reserves inventory)
- `GET /orders/:id` - Get specific order details
- `GET /orders/user/:userId` - User order history
- `POST /orders/fulfill` - Fulfill order with pickup code (staff only)
- `GET /orders/pending-pickup` - List pending pickup orders (staff only)
- `POST /orders/:orderId/pay` - Generate WeChat payment parameters
- `POST /payment/notify` - WeChat Pay callback webhook

**System APIs:**
- `GET /metrics` - Prometheus metrics for monitoring

## WeChat Integration

- Authentication via `wx.login()` → backend `/api/auth/login`
- User identification by WeChat OpenID
- Mini program uses `wx.request()` to call backend APIs
- Payment integration with WeChat Pay (optional)

## Important Development Notes

**Architecture:**
- Backend serves admin UI at `/admin/` (not `/`) to avoid WeChat Mini Program conflicts
- All inventory state changes must be wrapped in database transactions
- Plugin-based architecture for auth, metrics, and rate limiting
- Comprehensive error handling with business-specific error types

**Performance & Reliability:**
- Database transaction retries for handling serialization conflicts
- N+1 query prevention with proper Prisma includes
- Pagination support on inventory API
- Rate limiting on critical endpoints
- Order expiration cleanup via scheduled jobs
- Full text search using PostgreSQL pg_trgm extension

**Testing:**
- Comprehensive unit test suite using Vitest
- Integration tests with real database
- Separate test database configuration
- Code coverage reporting

**Deployment:**
- Multi-stage Dockerfile for optimized production builds
- Health check endpoint for load balancers
- Prometheus metrics for monitoring
- Environment-specific configuration validation

**WeChat Integration:**
- WeChat Mini Program TabBar only supports PNG icons, not SVG
- Dynamic WeChat Pay certificate management with auto-refresh
- Payment notification webhook with timestamp validation

**Business Rules:**
- The system strictly follows "V1 books only" - no AI learning materials or complex features
- Order payment timeout (15 minutes default)
- Maximum items per order and total reserved items per user are enforced. A user can only have one pending payment order at a time.

## Testing Strategy

**Unit Tests:** Use Vitest for service layer testing
```bash
npm test                    # Run all unit tests with coverage
```

**Integration Tests:** Test API endpoints with real database
```bash
npm run test:integration    # Run integration tests
```

**Database Integration:** Comprehensive order flow and payment testing
```bash
npx vitest run --config vitest.database-integration.config.ts
```

**Test Database:** Separate SQLite database for testing to avoid conflicts
- Unit tests: In-memory SQLite
- Integration tests: File-based SQLite with real PostgreSQL schema

## Monitoring & Observability

**Health Checks:**
- `GET /api/health` - Database connectivity and system status

**Metrics (Prometheus):**
- `GET /metrics` - Business and system metrics
- Order creation/completion/cancellation counters
- Payment processing metrics
- Inventory status gauges
- Database retry counters

**Logging:**
- Structured JSON logging via Fastify
- Request/response logging with redacted auth headers
- Error tracking with stack traces

## Background Jobs & Scheduled Tasks

**Order Cleanup:** Automatically cancel expired orders
- Runs every minute in development (configurable)
- Releases reserved inventory back to available pool
- Updates metrics counters

**Inventory Metrics:** Update Prometheus gauges
- Runs every 5 minutes
- Tracks inventory by status (in_stock, reserved, sold)

**WeChat Pay Certificates:** Auto-refresh platform certificates
- Runs every 10 hours
- Critical for payment verification
- Graceful fallback and error handling

## Deployment

**Docker Support:**
```bash
# Build production image
docker build -t bookworm-backend .

# Run container
docker run -p 3000:3000 --env-file .env bookworm-backend
```

**Multi-stage Build:**
- Stage 1: Build TypeScript and generate Prisma client
- Stage 2: Lightweight runtime with only production dependencies

**Production Checklist:**
- Set strong `JWT_SECRET`
- Configure proper `DATABASE_URL`
- Set up WeChat app credentials
- Configure monitoring endpoints
- Set appropriate cron schedules


================================================================================
### FILE: README.md
================================================================================

# 云开发 quickstart

这是云开发的快速启动指引，其中演示了如何上手使用云开发的三大基础能力：

- 数据库：一个既可在小程序前端操作，也能在云函数中读写的 JSON 文档型数据库
- 文件存储：在小程序前端直接上传/下载云端文件，在云开发控制台可视化管理
- 云函数：在云端运行的代码，微信私有协议天然鉴权，开发者只需编写业务逻辑代码

## 参考文档

- [云开发文档](https://developers.weixin.qq.com/miniprogram/dev/wxcloud/basis/getting-started.html)


================================================================================
### FILE: bookworm-backend\README.md
================================================================================

# Bookworm Backend

A robust backend API server for the Bookworm campus textbook marketplace, built with Fastify, TypeScript, and PostgreSQL.

## Quick Start

### Prerequisites
- Node.js 18+
- Docker & Docker Compose
- Git

### Local Development Setup

1. **Clone and Install Dependencies**
   ```bash
   cd bookworm-backend
   npm install
   ```

2. **Environment Configuration**
   ```bash
   # Copy example environment file
   cp .env.example .env

   # Edit .env with your specific configuration
   # The defaults work for local development with Docker
   ```

3. **Start Database Services**
   ```bash
   # Start PostgreSQL database for development
   docker-compose up -d postgres

   # For testing (starts both dev and test databases)
   docker-compose --profile test up -d

   # Wait for database to be ready (check health)
   docker-compose ps
   ```

4. **Database Setup**
   ```bash
   # Generate Prisma client
   npx prisma generate

   # Run database migrations
   npx prisma db push

   # Optional: Seed with sample data
   npm run seed
   ```

5. **Start Development Server**
   ```bash
   npm run dev
   ```

The API server will be available at `http://localhost:3000`

## Database Management

### Development Database
```bash
# Start development database
docker-compose up -d postgres

# Apply schema changes
npx prisma db push

# View data in Prisma Studio
npx prisma studio
```

### Test Database
```bash
# Start test database (separate from development)
docker-compose --profile test up -d postgres_test

# Run tests with test database
npm test
npm run test:integration
```

### Production Database
```bash
# Run migrations (instead of db push)
npx prisma migrate deploy
```

## Available Scripts

### Development
```bash
npm run dev          # Start development server with hot reload
npm run build        # Build TypeScript to JavaScript
npm run start        # Start production server
```

### Database
```bash
npm run migrate:dev  # Create and apply new migration
npm run seed         # Seed database with sample data
npx prisma studio    # Open Prisma Studio (database GUI)
npx prisma generate  # Regenerate Prisma client after schema changes
```

### Testing
```bash
npm test                    # Run unit tests
npm run test:integration    # Run integration tests with real database
npm run test:all           # Run all tests with coverage
```

### Background Jobs
```bash
npm run job:cancel-orders  # Manually run order expiration cleanup
```

## Project Structure

```
bookworm-backend/
├── src/
│   ├── config.ts              # Environment configuration
│   ├── index.ts              # Main application server
│   ├── db.ts                 # Prisma database client
│   ├── plugins/              # Fastify plugins
│   │   ├── auth.ts          # JWT authentication
│   │   └── metrics.ts       # Prometheus metrics
│   ├── services/             # Business logic
│   │   ├── orderService.ts  # Order management
│   │   └── inventoryService.ts  # Inventory management
│   ├── jobs/                 # Background jobs
│   └── tests/               # Test files
├── prisma/
│   ├── schema.prisma        # Database schema
│   ├── migrations/          # Database migrations
│   └── seed.ts             # Database seeding
├── docker-compose.yml       # Local development infrastructure
├── .env.example            # Environment variables template
└── README.md              # This file
```

## API Documentation

### Health Check
- `GET /api/health` - System health status

### Authentication
- `POST /api/auth/login` - WeChat Mini Program login

### Inventory
- `GET /api/inventory/available` - List available books (with search & pagination)
- `GET /api/inventory/item/:id` - Get book details
- `POST /api/inventory/add` - Add book to inventory (STAFF only)

### Orders
- `POST /api/orders/create` - Create new order
- `GET /api/orders/:id` - Get order details
- `GET /api/orders/user/:userId` - User order history
- `PATCH /api/orders/:id/status` - Update order status (STAFF only)
- `POST /api/orders/fulfill` - Fulfill order with pickup code (STAFF only)
- `GET /api/orders/pending-pickup` - List pending pickup orders (STAFF only)

### System
- `GET /metrics` - Prometheus metrics (for monitoring)

## Error Handling

The API uses a layered error handling system that returns consistent error responses:

```json
{
  "code": "ERROR_CODE",
  "message": "Human readable error message"
}
```

Common error codes:
- `UNAUTHORIZED` (401) - Authentication required
- `FORBIDDEN` (403) - Insufficient permissions
- `VALIDATION_ERROR` (400) - Invalid request data
- `RATE_LIMIT_EXCEEDED` (429) - Too many requests
- `ORDER_NOT_FOUND` (404) - Order does not exist
- `INVALID_STATUS_TRANSITION` (400) - Invalid order status change
- `INTERNAL_ERROR` (500) - Server error

## Environment Variables

Key environment variables (see `.env.example` for complete list):

```bash
# Database
DATABASE_URL="postgresql://postgres:password@localhost:5432/bookworm"

# Authentication
JWT_SECRET="your-secret-key-here"

# WeChat Integration
WX_APP_ID="your-wechat-app-id"
WX_APP_SECRET="your-wechat-app-secret"

# Business Rules
ORDER_PAYMENT_TTL_MINUTES=15
MAX_ITEMS_PER_ORDER=10
API_RATE_LIMIT_MAX=5
```

## Monitoring & Observability

### Metrics
Prometheus metrics available at `/metrics`:
- Request/response metrics
- Order lifecycle counters
- Inventory status gauges
- Database retry counters

### Logging
Structured JSON logging via Fastify with:
- Request/response logging
- Error tracking with stack traces
- Authentication events

### Health Checks
- `GET /api/health` includes database connectivity check
- Docker health checks for database containers

## Production Deployment

### Docker
```bash
# Build production image
docker build -t bookworm-backend .

# Run with environment file
docker run -p 3000:3000 --env-file .env bookworm-backend
```

### Configuration Validation
The application validates critical configuration in production:
- JWT_SECRET must not be default value
- WeChat credentials must be configured
- Database connection must be available

## Troubleshooting

### Database Connection Issues
```bash
# Check database container status
docker-compose ps

# View database logs
docker-compose logs postgres

# Reset database (destroys data!)
docker-compose down -v
docker-compose up -d postgres
```

### Permission Errors
```bash
# Reset Docker volumes if needed (destroys data!)
docker-compose down -v
docker volume prune
```

### Port Conflicts
The setup uses these ports:
- `3000` - API server
- `5432` - PostgreSQL (development)
- `5433` - PostgreSQL (test)

Change ports in `docker-compose.yml` if needed.

## Contributing

1. Create a feature branch
2. Make changes with tests
3. Run full test suite: `npm run test:all`
4. Ensure TypeScript compiles: `npm run build`
5. Create pull request

### Code Standards
- TypeScript strict mode enabled
- ESLint + Prettier formatting
- 100% test coverage for business logic
- Integration tests for API endpoints
- Prisma for database operations only

## License

Private project - All rights reserved.


================================================================================
### FILE: bookworm-backend\docker-compose.yml
================================================================================

version: '3.8'

services:
  postgres:
    image: postgres:15
    container_name: bookworm_postgres_dev
    environment:
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: password
      POSTGRES_DB: bookworm
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./init.sql:/docker-entrypoint-initdb.d/init.sql
    restart: unless-stopped
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres -d bookworm"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 30s

  postgres_test:
    image: postgres:15
    container_name: bookworm_postgres_test
    environment:
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: password
      POSTGRES_DB: bookworm_test
    ports:
      - "54320:5432"
    volumes:
      - postgres_test_data:/var/lib/postgresql/data
    restart: unless-stopped
    profiles:
      - test
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres -d bookworm_test"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 30s

volumes:
  postgres_data:
    driver: local
  postgres_test_data:
    driver: local

networks:
  default:
    name: bookworm_network


================================================================================
### FILE: bookworm-backend\eslint.config.js
================================================================================

// bookworm-backend/eslint.config.js
import eslint from '@eslint/js';
import typescriptEslint from '@typescript-eslint/eslint-plugin';
import typescriptParser from '@typescript-eslint/parser';

export default [
  // Base config for all files
  {
    files: ['**/*.{js,ts}'],
    languageOptions: {
      parser: typescriptParser,
      ecmaVersion: 'latest',
      sourceType: 'module',
      globals: {
        // Node.js globals
        process: 'readonly',
        Buffer: 'readonly',
        __dirname: 'readonly',
        __filename: 'readonly',
        console: 'readonly',
        module: 'readonly',
        require: 'readonly',
        exports: 'readonly',
        global: 'readonly',
        setTimeout: 'readonly',
        setInterval: 'readonly',
        clearTimeout: 'readonly',
        clearInterval: 'readonly',
      },
    },
    plugins: {
      '@typescript-eslint': typescriptEslint,
    },
    rules: {
      ...eslint.configs.recommended.rules,
      ...typescriptEslint.configs.recommended.rules,
      // Project-specific rule overrides
      '@typescript-eslint/no-explicit-any': 'warn', // Warn instead of error
      '@typescript-eslint/no-unused-vars': ['warn', { argsIgnorePattern: '^_' }], // Allow unused vars starting with _
      '@typescript-eslint/no-require-imports': 'warn', // Allow require() imports (legacy code)
    },
  },
  // Special config for test files
  {
    files: ['src/tests/**/*.ts'],
    languageOptions: {
      globals: {
        // Vitest globals
        describe: 'readonly',
        it: 'readonly',
        expect: 'readonly',
        beforeAll: 'readonly',
        afterAll: 'readonly',
        beforeEach: 'readonly',
        afterEach: 'readonly',
        vi: 'readonly',
      },
    },
    rules: {
      // Test files can be more lenient
      '@typescript-eslint/no-explicit-any': 'off',
      '@typescript-eslint/no-var-requires': 'off',
      '@typescript-eslint/no-unused-vars': 'off',
    },
  },
  // Special config for mock files
  {
    files: ['src/tests/__mocks__/**/*.js'],
    rules: {
      '@typescript-eslint/no-unused-vars': 'off',
      '@typescript-eslint/no-explicit-any': 'off',
    },
  },
  // Ignore patterns
  {
    ignores: [
      'node_modules/',
      'dist/',
      'coverage/',
      '.turbo/',
      'vitest.*.config.ts',
      '*.cjs',
      'src/generated/',
      'public/',
      'prisma/migrations/',
    ],
  },
];


================================================================================
### FILE: bookworm-backend\package.json
================================================================================

{
  "name": "bookworm-backend",
  "version": "1.0.0",
  "description": "",
  "main": "dist/index.js",
  "scripts": {
    "dev": "nodemon --watch \"src/**/*.ts\" --exec \"npx ts-node\" src/index.ts",
    "build": "tsc",
    "start": "node dist/index.js",
    "test": "vitest run --coverage",
    "migrate:dev": "npx prisma migrate dev",
    "db:migrate:test": "dotenv -e .env.test -- npx prisma db push",
    "db:migrate:test:reset": "dotenv -e .env.test -- npx prisma migrate reset --force",
    "seed": "prisma db seed",
    "job:cancel-orders": "npx ts-node src/jobs/cancelExpiredOrders.ts",
    "postinstall": "cp node_modules/@zxing/library/umd/index.min.js public/zxing.min.js",
    "test:integration": "dotenv -e .env.test -- vitest run --config vitest.integration.config.ts",
    "lint": "eslint . --ext .ts",
    "lint:fix": "eslint . --ext .ts --fix"
  },
  "prisma": {
    "seed": "ts-node prisma/seed.ts"
  },
  "dependencies": {
    "@fastify/env": "^5.0.2",
    "@fastify/rate-limit": "^9.1.0",
    "@fastify/static": "^7.0.4",
    "@prisma/client": "^6.16.2",
    "@sinclair/typebox": "^0.34.41",
    "@types/jsonwebtoken": "^9.0.10",
    "axios": "^1.12.0",
    "dotenv": "^16.4.5",
    "env-schema": "^6.0.1",
    "fast-jwt": "^6.0.2",
    "fastify": "^4.27.0",
    "fastify-plugin": "^5.0.1",
    "fastify-raw-body": "^4.3.0",
    "jsonwebtoken": "^9.0.2",
    "node-cron": "^4.2.1",
    "prom-client": "^15.1.3",
    "wechatpay-node-v3": "^2.2.1"
  },
  "devDependencies": {
    "@testcontainers/postgresql": "^11.5.1",
    "@types/node": "^20.14.2",
    "@types/node-cron": "^3.0.11",
    "@types/supertest": "^6.0.3",
    "@typescript-eslint/eslint-plugin": "^8.43.0",
    "@typescript-eslint/parser": "^8.43.0",
    "@vitest/coverage-v8": "^3.2.4",
    "@zxing/library": "^0.21.3",
    "dotenv-cli": "^10.0.0",
    "eslint": "^9.35.0",
    "nodemon": "^3.1.2",
    "prisma": "^6.16.2",
    "sqlite3": "^5.1.7",
    "supertest": "^7.1.4",
    "ts-node": "^10.9.2",
    "typescript": "^5.4.5",
    "vitest": "^3.2.4",
    "vitest-mock-extended": "^3.1.0"
  },
  "keywords": [],
  "author": "",
  "license": "ISC"
}


================================================================================
### FILE: bookworm-backend\prisma\migrations\20250927072418_initial_schema_squashed\migration.sql
================================================================================

-- CreateEnum
CREATE EXTENSION IF NOT EXISTS "pg_trgm" WITH SCHEMA public;

-- CreateEnum
CREATE TYPE "public"."book_condition" AS ENUM ('NEW', 'GOOD', 'ACCEPTABLE');

-- CreateEnum
CREATE TYPE "public"."inventory_status" AS ENUM ('in_stock', 'reserved', 'sold', 'returned', 'damaged');

-- CreateEnum
CREATE TYPE "public"."Role" AS ENUM ('USER', 'STAFF');

-- CreateEnum
CREATE TYPE "public"."OrderStatus" AS ENUM ('PENDING_PAYMENT', 'PENDING_PICKUP', 'COMPLETED', 'CANCELLED', 'RETURNED');

-- CreateEnum
CREATE TYPE "public"."PaymentStatus" AS ENUM ('PENDING', 'SUCCESS', 'REFUND_REQUIRED', 'REFUNDED', 'FAILED', 'REFUND_PROCESSING');

-- CreateTable
CREATE TABLE "public"."Order" (
    "id" SERIAL NOT NULL,
    "user_id" INTEGER NOT NULL,
    "status" "public"."OrderStatus" NOT NULL DEFAULT 'PENDING_PAYMENT',
    "total_amount" DECIMAL(10,2) NOT NULL,
    "pickup_code" VARCHAR(16) NOT NULL,
    "createdAt" TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "paymentExpiresAt" TIMESTAMPTZ(6) NOT NULL,
    "pickupExpiresAt" TIMESTAMPTZ(6),
    "paid_at" TIMESTAMPTZ(6),
    "completed_at" TIMESTAMPTZ(6),
    "cancelled_at" TIMESTAMPTZ(6),

    CONSTRAINT "Order_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "public"."pending_payment_order" (
    "order_id" INTEGER NOT NULL,
    "user_id" INTEGER NOT NULL,
    "created_at" TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "pending_payment_order_pkey" PRIMARY KEY ("order_id")
);

-- CreateTable
CREATE TABLE "public"."User" (
    "id" SERIAL NOT NULL,
    "openid" VARCHAR(255) NOT NULL,
    "unionid" VARCHAR(255),
    "nickname" VARCHAR(255),
    "avatar_url" VARCHAR(255),
    "role" "public"."Role" NOT NULL DEFAULT 'USER',
    "created_at" TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "User_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "public"."bookmaster" (
    "id" SERIAL NOT NULL,
    "isbn13" VARCHAR(13) NOT NULL,
    "title" VARCHAR(255) NOT NULL,
    "author" VARCHAR(255),
    "publisher" VARCHAR(255),
    "original_price" DECIMAL(10,2),
    "created_at" TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updated_at" TIMESTAMPTZ(6) NOT NULL,

    CONSTRAINT "bookmaster_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "public"."booksku" (
    "id" SERIAL NOT NULL,
    "master_id" INTEGER NOT NULL,
    "edition" VARCHAR(50),
    "description" TEXT,
    "cover_image_url" VARCHAR(255),
    "created_at" TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updated_at" TIMESTAMPTZ(6) NOT NULL,

    CONSTRAINT "booksku_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "public"."inventoryitem" (
    "id" SERIAL NOT NULL,
    "sku_id" INTEGER NOT NULL,
    "condition" "public"."book_condition" NOT NULL,
    "cost" DECIMAL(10,2) NOT NULL,
    "selling_price" DECIMAL(10,2) NOT NULL,
    "status" "public"."inventory_status" NOT NULL DEFAULT 'in_stock',
    "created_at" TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updated_at" TIMESTAMPTZ(6) NOT NULL,

    CONSTRAINT "inventoryitem_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "public"."inventory_reservation" (
    "inventory_item_id" INTEGER NOT NULL,
    "order_id" INTEGER NOT NULL,
    "created_at" TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "inventory_reservation_pkey" PRIMARY KEY ("inventory_item_id")
);

-- CreateTable
CREATE TABLE "public"."orderitem" (
    "id" SERIAL NOT NULL,
    "order_id" INTEGER NOT NULL,
    "inventory_item_id" INTEGER NOT NULL,
    "price" DECIMAL(10,2) NOT NULL,

    CONSTRAINT "orderitem_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "public"."Content" (
    "id" SERIAL NOT NULL,
    "slug" VARCHAR(255) NOT NULL,
    "title" VARCHAR(255) NOT NULL,
    "body" TEXT NOT NULL,
    "createdAt" TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "Content_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "public"."PaymentRecord" (
    "id" SERIAL NOT NULL,
    "order_id" INTEGER NOT NULL,
    "out_trade_no" VARCHAR(100) NOT NULL,
    "transaction_id" VARCHAR(100),
    "status" "public"."PaymentStatus" NOT NULL DEFAULT 'PENDING',
    "amount_total" INTEGER NOT NULL,
    "payer_openid" VARCHAR(255),
    "appid" VARCHAR(100),
    "mchid" VARCHAR(100),
    "createdAt" TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMPTZ(6) NOT NULL,
    "notified_at" TIMESTAMP(3),
    "refunded_at" TIMESTAMP(3),
    "refund_id" VARCHAR(100),
    "refund_attempts" INTEGER NOT NULL DEFAULT 0,

    CONSTRAINT "PaymentRecord_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE UNIQUE INDEX "Order_pickup_code_key" ON "public"."Order"("pickup_code");

-- CreateIndex
CREATE INDEX "idx_order_user_id_status" ON "public"."Order"("user_id", "status");

-- CreateIndex
CREATE INDEX "idx_order_created_at" ON "public"."Order"("createdAt");

-- CreateIndex
CREATE INDEX "idx_order_user_created_at_id" ON "public"."Order"("user_id", "createdAt", "id");

-- CreateIndex
CREATE UNIQUE INDEX "uniq_order_pending_per_user" ON "public"."pending_payment_order"("user_id");

-- CreateIndex
CREATE UNIQUE INDEX "User_openid_key" ON "public"."User"("openid");

-- CreateIndex
CREATE UNIQUE INDEX "User_unionid_key" ON "public"."User"("unionid");

-- CreateIndex
CREATE UNIQUE INDEX "bookmaster_isbn13_key" ON "public"."bookmaster"("isbn13");

-- CreateIndex
CREATE INDEX "idx_book_master_isbn13" ON "public"."bookmaster"("isbn13");

-- CreateIndex
CREATE INDEX "idx_bookmaster_author_gin_trgm" ON "public"."bookmaster" USING GIN ("author" gin_trgm_ops);

-- CreateIndex
CREATE INDEX "idx_bookmaster_title_gin_trgm" ON "public"."bookmaster" USING GIN ("title" gin_trgm_ops);

-- CreateIndex
CREATE UNIQUE INDEX "booksku_master_id_edition_key" ON "public"."booksku"("master_id", "edition");

-- CreateIndex
CREATE INDEX "idx_inventory_item_sku_id_status" ON "public"."inventoryitem"("sku_id", "status");

-- CreateIndex
CREATE INDEX "idx_inventory_reservation_order_id" ON "public"."inventory_reservation"("order_id");

-- CreateIndex
CREATE INDEX "idx_orderitem_inventory_item_id" ON "public"."orderitem"("inventory_item_id");

-- CreateIndex
CREATE UNIQUE INDEX "uniq_orderitem_order_inventory" ON "public"."orderitem"("order_id", "inventory_item_id");

-- CreateIndex
CREATE UNIQUE INDEX "Content_slug_key" ON "public"."Content"("slug");

-- CreateIndex
CREATE INDEX "idx_content_slug" ON "public"."Content"("slug");

-- CreateIndex
CREATE UNIQUE INDEX "PaymentRecord_out_trade_no_key" ON "public"."PaymentRecord"("out_trade_no");

-- CreateIndex
CREATE UNIQUE INDEX "PaymentRecord_transaction_id_key" ON "public"."PaymentRecord"("transaction_id");

-- CreateIndex
CREATE UNIQUE INDEX "PaymentRecord_refund_id_key" ON "public"."PaymentRecord"("refund_id");

-- CreateIndex
CREATE INDEX "PaymentRecord_order_id_idx" ON "public"."PaymentRecord"("order_id");

-- CreateIndex
CREATE INDEX "PaymentRecord_status_createdAt_idx" ON "public"."PaymentRecord"("status", "createdAt");

-- AddForeignKey
ALTER TABLE "public"."Order" ADD CONSTRAINT "fk_user" FOREIGN KEY ("user_id") REFERENCES "public"."User"("id") ON DELETE NO ACTION ON UPDATE NO ACTION;

-- AddForeignKey
ALTER TABLE "public"."pending_payment_order" ADD CONSTRAINT "fk_pending_order" FOREIGN KEY ("order_id") REFERENCES "public"."Order"("id") ON DELETE CASCADE ON UPDATE NO ACTION;

-- AddForeignKey
ALTER TABLE "public"."pending_payment_order" ADD CONSTRAINT "fk_pending_user" FOREIGN KEY ("user_id") REFERENCES "public"."User"("id") ON DELETE CASCADE ON UPDATE NO ACTION;

-- AddForeignKey
ALTER TABLE "public"."booksku" ADD CONSTRAINT "fk_master" FOREIGN KEY ("master_id") REFERENCES "public"."bookmaster"("id") ON DELETE NO ACTION ON UPDATE NO ACTION;

-- AddForeignKey
ALTER TABLE "public"."inventoryitem" ADD CONSTRAINT "fk_sku" FOREIGN KEY ("sku_id") REFERENCES "public"."booksku"("id") ON DELETE NO ACTION ON UPDATE NO ACTION;

-- AddForeignKey
ALTER TABLE "public"."inventory_reservation" ADD CONSTRAINT "fk_reservation_item" FOREIGN KEY ("inventory_item_id") REFERENCES "public"."inventoryitem"("id") ON DELETE CASCADE ON UPDATE NO ACTION;

-- AddForeignKey
ALTER TABLE "public"."inventory_reservation" ADD CONSTRAINT "fk_reservation_order" FOREIGN KEY ("order_id") REFERENCES "public"."Order"("id") ON DELETE CASCADE ON UPDATE NO ACTION;

-- AddForeignKey
ALTER TABLE "public"."orderitem" ADD CONSTRAINT "fk_inventory_item" FOREIGN KEY ("inventory_item_id") REFERENCES "public"."inventoryitem"("id") ON DELETE NO ACTION ON UPDATE NO ACTION;

-- AddForeignKey
ALTER TABLE "public"."orderitem" ADD CONSTRAINT "fk_order" FOREIGN KEY ("order_id") REFERENCES "public"."Order"("id") ON DELETE NO ACTION ON UPDATE NO ACTION;

-- AddForeignKey
ALTER TABLE "public"."PaymentRecord" ADD CONSTRAINT "PaymentRecord_order_id_fkey" FOREIGN KEY ("order_id") REFERENCES "public"."Order"("id") ON DELETE RESTRICT ON UPDATE CASCADE;


================================================================================
### FILE: bookworm-backend\prisma\migrations\migration_lock.toml
================================================================================

# Please do not edit this file manually
# It should be added in your version-control system (e.g., Git)
provider = "postgresql"


================================================================================
### FILE: bookworm-backend\prisma\schema.prisma
================================================================================

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Order {
  id               Int                    @id @default(autoincrement())
  user_id          Int
  status           OrderStatus            @default(PENDING_PAYMENT)
  total_amount     Decimal                @db.Decimal(10, 2)
  pickup_code      String                 @unique @db.VarChar(16)
  createdAt        DateTime               @default(now()) @db.Timestamptz(6)
  paymentExpiresAt DateTime               @db.Timestamptz(6)
  pickupExpiresAt  DateTime?              @db.Timestamptz(6)
  paid_at          DateTime?              @db.Timestamptz(6)
  completed_at     DateTime?              @db.Timestamptz(6)
  cancelled_at     DateTime?              @db.Timestamptz(6)
  User             User                   @relation(fields: [user_id], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "fk_user")
  orderItem        OrderItem[]
  PaymentRecord    PaymentRecord[]
  reservations     InventoryReservation[]
  pendingGuard     PendingPaymentOrder?

  @@index([user_id, status], map: "idx_order_user_id_status")
  @@index([createdAt], map: "idx_order_created_at")
  @@index([user_id, createdAt, id], map: "idx_order_user_created_at_id")
}

model PendingPaymentOrder {
  order_id   Int      @id
  user_id    Int
  created_at DateTime @default(now()) @db.Timestamptz(6)

  Order Order @relation(fields: [order_id], references: [id], onDelete: Cascade, onUpdate: NoAction, map: "fk_pending_order")
  User  User  @relation(fields: [user_id], references: [id], onDelete: Cascade, onUpdate: NoAction, map: "fk_pending_user")

  @@unique([user_id], map: "uniq_order_pending_per_user")
  @@map("pending_payment_order")
}

model User {
  id            Int                   @id @default(autoincrement())
  openid        String                @unique @db.VarChar(255)
  unionid       String?               @unique @db.VarChar(255)
  nickname      String?               @db.VarChar(255)
  avatar_url    String?               @db.VarChar(255)
  role          Role                  @default(USER)
  created_at    DateTime              @default(now()) @db.Timestamptz(6)
  Order         Order[]
  pendingOrders PendingPaymentOrder[]
}

model BookMaster {
  id             Int       @id @default(autoincrement())
  isbn13         String    @unique @db.VarChar(13)
  title          String    @db.VarChar(255)
  author         String?   @db.VarChar(255)
  publisher      String?   @db.VarChar(255)
  original_price Decimal?  @db.Decimal(10, 2)
  created_at     DateTime  @default(now()) @db.Timestamptz(6)
  updated_at     DateTime  @updatedAt @db.Timestamptz(6)
  bookSku        BookSku[]

  @@index([isbn13], map: "idx_book_master_isbn13")
  @@index([author(ops: raw("gin_trgm_ops"))], map: "idx_bookmaster_author_gin_trgm", type: Gin)
  @@index([title(ops: raw("gin_trgm_ops"))], map: "idx_bookmaster_title_gin_trgm", type: Gin)
  @@map("bookmaster")
}

model BookSku {
  id              Int             @id @default(autoincrement())
  master_id       Int
  edition         String?         @db.VarChar(50)
  description     String?
  cover_image_url String?         @db.VarChar(255)
  created_at      DateTime        @default(now()) @db.Timestamptz(6)
  updated_at      DateTime        @updatedAt @db.Timestamptz(6)
  bookMaster      BookMaster      @relation(fields: [master_id], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "fk_master")
  inventoryItems  InventoryItem[]

  @@unique([master_id, edition])
  @@map("booksku")
}

model InventoryItem {
  id            Int                   @id @default(autoincrement())
  sku_id        Int
  condition     book_condition
  cost          Decimal               @db.Decimal(10, 2)
  selling_price Decimal               @db.Decimal(10, 2)
  status        inventory_status      @default(in_stock)
  created_at    DateTime              @default(now()) @db.Timestamptz(6)
  updated_at    DateTime              @updatedAt @db.Timestamptz(6)
  bookSku       BookSku               @relation(fields: [sku_id], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "fk_sku")
  orderItem     OrderItem[]
  reservation   InventoryReservation?

  @@index([sku_id, status], map: "idx_inventory_item_sku_id_status")
  @@map("inventoryitem")
}

model InventoryReservation {
  inventory_item_id Int      @id
  order_id          Int
  created_at        DateTime @default(now()) @db.Timestamptz(6)

  inventoryItem InventoryItem @relation(fields: [inventory_item_id], references: [id], onDelete: Cascade, onUpdate: NoAction, map: "fk_reservation_item")
  order         Order         @relation(fields: [order_id], references: [id], onDelete: Cascade, onUpdate: NoAction, map: "fk_reservation_order")

  @@index([order_id], map: "idx_inventory_reservation_order_id")
  @@map("inventory_reservation")
}

model OrderItem {
  id                Int           @id @default(autoincrement())
  order_id          Int
  inventory_item_id Int
  price             Decimal       @db.Decimal(10, 2)
  inventoryItem     InventoryItem @relation(fields: [inventory_item_id], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "fk_inventory_item")
  Order             Order         @relation(fields: [order_id], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "fk_order")

  @@unique([order_id, inventory_item_id], map: "uniq_orderitem_order_inventory")
  @@index([inventory_item_id], map: "idx_orderitem_inventory_item_id")
  @@map("orderitem")
}

model Content {
  id        Int      @id @default(autoincrement())
  slug      String   @unique @db.VarChar(255)
  title     String   @db.VarChar(255)
  body      String
  createdAt DateTime @default(now()) @db.Timestamptz(6)
  updatedAt DateTime @default(now()) @updatedAt @db.Timestamptz(6)

  @@index([slug], map: "idx_content_slug")
}

model PaymentRecord {
  id              Int           @id @default(autoincrement())
  order_id        Int
  out_trade_no    String        @unique @db.VarChar(100)
  transaction_id  String?       @unique @db.VarChar(100)
  status          PaymentStatus @default(PENDING)
  amount_total    Int
  payer_openid    String?       @db.VarChar(255)
  appid           String?       @db.VarChar(100)
  mchid           String?       @db.VarChar(100)
  createdAt       DateTime      @default(now()) @db.Timestamptz(6)
  updatedAt       DateTime      @updatedAt @db.Timestamptz(6)
  notified_at     DateTime?
  refunded_at     DateTime?
  refund_id       String?       @unique @db.VarChar(100)
  refund_attempts Int           @default(0)
  Order           Order         @relation(fields: [order_id], references: [id])

  @@index([order_id])
  @@index([status, createdAt])
}

enum book_condition {
  NEW
  GOOD
  ACCEPTABLE
}

enum inventory_status {
  in_stock
  reserved
  sold
  returned
  damaged
}

enum Role {
  USER
  STAFF
}

enum OrderStatus {
  PENDING_PAYMENT
  PENDING_PICKUP
  COMPLETED
  CANCELLED
  RETURNED
}

enum PaymentStatus {
  PENDING
  SUCCESS
  REFUND_REQUIRED
  REFUNDED
  FAILED
  REFUND_PROCESSING
}


================================================================================
### FILE: bookworm-backend\prisma\seed.ts
================================================================================

// bookworm-backend/prisma/seed.ts

import { PrismaClient, book_condition } from '@prisma/client';

const prisma = new PrismaClient();

const booksToSeed = [
  {
    master: {
      isbn13: '9787111594251',
      title: '深入理解计算机系统（原书第3版）',
      author: 'Randal E. Bryant',
      publisher: '机械工业出版社',
      original_price: 139.00,
    },
    skus: [
      {
        edition: '原书第3版',
        cover_image_url: 'https://img3.doubanio.com/view/subject/l/public/s29634731.jpg',
        inventory: [
          { condition: book_condition.NEW, cost: 70.00, selling_price: 95.00 },
          { condition: book_condition.GOOD, cost: 50.00, selling_price: 75.50 },
          { condition: book_condition.ACCEPTABLE, cost: 30.00, selling_price: 45.00 },
        ],
      },
    ],
  },
  {
    master: {
      isbn13: '9787115428868',
      title: '代码整洁之道',
      author: 'Robert C. Martin',
      publisher: '人民邮电出版社',
      original_price: 59.00,
    },
    skus: [
      {
        edition: '中文版',
        cover_image_url: 'https://img1.doubanio.com/view/subject/l/public/s4418368.jpg',
        inventory: [
          { condition: book_condition.GOOD, cost: 25.00, selling_price: 38.00 },
          { condition: book_condition.GOOD, cost: 26.00, selling_price: 39.00 },
        ],
      },
    ],
  },
  {
    master: {
      isbn13: '9787115546029',
      title: '深入浅出Node.js',
      author: '朴灵',
      publisher: '人民邮电出版社',
      original_price: 69.00,
    },
    skus: [
      {
        edition: '第一版',
        cover_image_url: 'https://img9.doubanio.com/view/subject/l/public/s27204686.jpg',
        inventory: [
          { condition: book_condition.ACCEPTABLE, cost: 15.00, selling_price: 25.00 },
        ],
      },
    ],
  },
  {
    master: {
      isbn13: '9787508649719',
      title: 'Sapiens: A Brief History of Humankind',
      author: 'Yuval Noah Harari',
      publisher: '中信出版社',
      original_price: 68.00,
    },
    skus: [
      {
        edition: '中文版',
        cover_image_url: 'https://img2.doubanio.com/view/subject/l/public/s27371512.jpg',
        inventory: [
          { condition: book_condition.GOOD, cost: 30.00, selling_price: 42.00 },
        ],
      },
      {
        edition: '英文原版',
        cover_image_url: 'https://img2.doubanio.com/view/subject/l/public/s29810813.jpg',
        inventory: [
          { condition: book_condition.NEW, cost: 50.00, selling_price: 78.00 },
        ],
      }
    ],
  },
];

async function main() {
  console.log('Start seeding...');

  // To ensure idempotency, we first clean up the tables that represent physical items.
  // We don't delete BookMaster or BookSKU to preserve their IDs.
  await prisma.orderItem.deleteMany({});
  await prisma.order.deleteMany({});
  await prisma.inventoryItem.deleteMany({});
  
  console.log('Cleaned up existing inventory and order data.');

  for (const book of booksToSeed) {
    await prisma.$transaction(async (tx) => {
      // Upsert BookMaster
      const bookMaster = await tx.bookMaster.upsert({
        where: { isbn13: book.master.isbn13 },
        update: book.master,
        create: book.master,
      });

      for (const skuData of book.skus) {
        // Upsert BookSKU
        const bookSku = await tx.bookSku.upsert({
          where: {
            master_id_edition: {
              master_id: bookMaster.id,
              edition: skuData.edition,
            },
          },
          update: {
            cover_image_url: skuData.cover_image_url,
          },
          create: {
            master_id: bookMaster.id,
            edition: skuData.edition,
            cover_image_url: skuData.cover_image_url,
          },
        });

        // Create InventoryItems
        if (skuData.inventory && skuData.inventory.length > 0) {
          await tx.inventoryItem.createMany({
            data: skuData.inventory.map(item => ({
              sku_id: bookSku.id,
              ...item,
            })),
          });
        }
      }
    });
    console.log(`Seeded book: ${book.master.title}`);
  }

  console.log('Seeding finished.');
}

main()
  .catch((e) => {
    console.error(e);
    process.exit(1);
  })
  .finally(async () => {
    await prisma.$disconnect();
  });


================================================================================
### FILE: bookworm-backend\prometheus.yml
================================================================================

# prometheus.yml
global:
  scrape_interval: 15s

scrape_configs:
  - job_name: 'bookworm-backend'
    static_configs:
      - targets: ['host.docker.internal:8080']


================================================================================
### FILE: bookworm-backend\src\adapters\wechatPayAdapter.ts
================================================================================

// src/adapters/wechatPayAdapter.ts
// Type-safe adapter for WeChat Pay SDK, isolating all 'as any' casts

import WechatPay from "wechatpay-node-v3";
import { WechatPayError } from "../errors";
import { isAxiosError } from "../utils/typeGuards";

// --- STRICT INPUT/OUTPUT INTERFACES ---

export interface WechatPayConfig {
  appid: string;
  mchid: string;
  privateKey: Buffer;
  serial_no: string;
  key: string;
}

export interface CreatePaymentOrderRequest {
  appid: string;
  mchid: string;
  description: string;
  out_trade_no: string;
  notify_url: string;
  time_expire: string;
  amount: {
    total: number;
    currency: string;
  };
  payer: {
    openid: string;
  };
}

export interface CreatePaymentOrderResponse {
  prepay_id: string;
}

export interface QueryPaymentRequest {
  out_trade_no: string;
  mchid: string;
}

export interface QueryPaymentResponse {
  trade_state: string;
  amount: {
    total: number;
    currency: string;
  };
  payer?: {
    openid: string;
  };
  mchid: string;
  appid: string;
  transaction_id?: string;
}

export interface VerifySignatureRequest {
  timestamp: string;
  nonce: string;
  body: string | Buffer;
  signature: string;
  serial: string;
}

export interface SignRequest {
  message: string;
}

export interface DecryptDataRequest {
  ciphertext: string;
  associated_data: string;
  nonce: string;
  apiv3Key: string;
}

export interface CreateRefundRequest {
  out_trade_no: string;
  out_refund_no: string;
  reason?: string;
  amount: {
    refund: number;
    total: number;
    currency: string;
  };
}

export interface CreateRefundResponse {
  status: string; // e.g., 'SUCCESS', 'PROCESSING'
  refund_id?: string;
  out_refund_no: string;
  transaction_id?: string;
  out_trade_no: string;
}

// --- ADAPTER CLASS ---

export class WechatPayAdapter {
  private readonly payInstance: any; // Keep 'any' confined to this private field

  constructor(config: WechatPayConfig) {
    // This is the ONLY place where we use 'as any' - confined to initialization
    this.payInstance = new WechatPay({
      appid: config.appid,
      mchid: config.mchid,
      privateKey: config.privateKey,
      serial_no: config.serial_no,
      key: config.key,
    } as any) as any;
  }

  /**
   * Create a payment order using JSAPI
   * @param request - Payment order details
   * @returns Promise with prepay_id and other response data
   * @throws Error if payment creation fails
   */
  async createPaymentOrder(request: CreatePaymentOrderRequest): Promise<CreatePaymentOrderResponse> {
    try {
      const response = await this.payInstance.transactions_jsapi(request);

      // Validate response structure
      if (!response || typeof response.prepay_id !== 'string') {
        throw new Error('Invalid response from WeChat Pay: missing prepay_id');
      }

      return {
        prepay_id: response.prepay_id,
      };
    } catch (error) {
      throw new Error(`Failed to create payment order: ${(error as Error).message}`);
    }
  }

  /**
   * Query payment status by out_trade_no
   * @param request - Query parameters
   * @returns Promise with payment status and details
   * @throws WechatPayError with appropriate error classification
   */
  async queryPaymentStatus(request: QueryPaymentRequest): Promise<QueryPaymentResponse> {
    try {
      const response = await this.payInstance.transactions_out_trade_no(request);

      // Validate required fields in response
      if (!response || !response.trade_state) {
        throw new Error('Invalid response from WeChat Pay: missing trade_state');
      }

      if (!response.amount || typeof response.amount.total !== 'number') {
        throw new Error('Invalid response from WeChat Pay: invalid amount structure');
      }

      return {
        trade_state: response.trade_state,
        amount: {
          total: response.amount.total,
          currency: response.amount.currency || 'CNY',
        },
        payer: response.payer ? { openid: response.payer.openid } : undefined,
        mchid: response.mchid,
        appid: response.appid,
        transaction_id: response.transaction_id,
      };
    } catch (error) {
      if (isAxiosError(error)) {
        const status = error.response?.status;
        const message = error.response?.data?.message || error.message;

        if (status === 404 || message.includes('ORDER_NOT_EXIST')) {
          throw new WechatPayError('ORDER_NOT_FOUND', false, `Order not found on WeChat's side: ${message}`, error);
        }
        if (status && status >= 400 && status < 500) {
          throw new WechatPayError('INVALID_REQUEST', false, `Invalid request to WeChat Pay: ${message}`, error);
        }
        if (status && status >= 500) {
          throw new WechatPayError('WECHAT_SERVER_ERROR', true, `WeChat Pay server error: ${message}`, error);
        }
      }
      // For non-axios errors (e.g., network timeout, DNS), assume they are retryable.
      throw new WechatPayError('NETWORK_ERROR', true, `Network error during payment query: ${(error as Error).message}`, error);
    }
  }

  /**
   * Verify signature from WeChat Pay notification
   * @param request - Signature verification parameters
   * @returns true if signature is valid, false otherwise
   */
  verifySignature(request: VerifySignatureRequest): boolean {
    try {
      return this.payInstance.verifySign({
        timestamp: request.timestamp,
        nonce: request.nonce,
        body: request.body,
        signature: request.signature,
        serial: request.serial,
      });
    } catch (error) {
      // Log error but return false instead of throwing
      console.error('WeChat Pay signature verification failed:', error);
      return false;
    }
  }

  /**
   * Decrypt encrypted data from WeChat Pay notification
   * @param request - Decryption parameters
   * @returns Decrypted string data
   * @throws Error if decryption fails
   */
  decryptNotificationData(request: DecryptDataRequest): string {
    try {
      const result = this.payInstance.decipher_gcm(
        request.ciphertext,
        request.associated_data,
        request.nonce,
        request.apiv3Key
      );

      if (typeof result !== 'string') {
        throw new Error('Decryption result is not a string');
      }

      return result;
    } catch (error) {
      throw new Error(`Failed to decrypt notification data: ${(error as Error).message}`);
    }
  }

  /**
   * Generate RSA signature for WeChat Pay
   * @param request - Data to sign
   * @returns Signature string
   * @throws Error if signing fails
   */
  generateSignature(request: SignRequest): string {
    try {
      const signature = this.payInstance.sign(request.message);

      if (typeof signature !== 'string') {
        throw new Error('Signature generation returned non-string result');
      }

      return signature;
    } catch (error) {
      throw new Error(`Failed to generate signature: ${(error as Error).message}`);
    }
  }

  /**
   * Create a refund for a transaction
   * @param request - Refund details
   * @returns Promise with refund status
   * @throws WechatPayError with appropriate error classification
   */
  async createRefund(request: CreateRefundRequest): Promise<CreateRefundResponse> {
    try {
      // The SDK method name is typically plural, like 'refunds'
      const response = await this.payInstance.refunds(request);

      if (!response || !response.status) {
        throw new Error('Invalid response from WeChat Pay refund API: missing status');
      }

      return {
        status: response.status,
        refund_id: response.refund_id,
        out_refund_no: response.out_refund_no || request.out_refund_no,
        transaction_id: response.transaction_id,
        out_trade_no: response.out_trade_no || request.out_trade_no,
      };
    } catch (error) {
      if (isAxiosError(error)) {
        const status = error.response?.status;
        const message = error.response?.data?.message || error.message;

        if (status && status >= 400 && status < 500) {
          throw new WechatPayError('INVALID_REFUND_REQUEST', false, `Invalid refund request: ${message}`, error);
        }
        if (status && status >= 500) {
          throw new WechatPayError('WECHAT_SERVER_ERROR', true, `WeChat Pay server error during refund: ${message}`, error);
        }
      }
      throw new WechatPayError('NETWORK_ERROR', true, `Network error during refund creation: ${(error as Error).message}`, error);
    }
  }
}

// --- FACTORY FUNCTION FOR CLEAN INITIALIZATION ---

export function createWechatPayAdapter(config: WechatPayConfig): WechatPayAdapter {
  return new WechatPayAdapter(config);
}


================================================================================
### FILE: bookworm-backend\src\app-factory.ts
================================================================================

// src/app-factory.ts
// Factory function to create Fastify app with proper database setup for tests

// Override the DATABASE_URL for tests using test containers
export const setupTestDatabase = () => {
  if (process.env.NODE_ENV === 'test' && process.env.TEST_CONTAINERS) {
    const containers = JSON.parse(process.env.TEST_CONTAINERS);
    const workerId = parseInt(process.env.VITEST_WORKER_ID || '1', 10);
    const databaseUrl = containers[workerId] || containers['1'];

    if (databaseUrl) {
      // Override the DATABASE_URL for this process
      process.env.DATABASE_URL = databaseUrl;
      console.log(`✅ Test database URL set for worker ${workerId}: ${databaseUrl.substring(0, 30)}...`);
    }
  }
};

// Call this function before importing the main app to ensure the correct DATABASE_URL is used
export const createTestApp = async () => {
  setupTestDatabase();
  // Import after setting up the database URL
  const { buildApp } = await import('./index');
  return buildApp();
};


================================================================================
### FILE: bookworm-backend\src\config.ts
================================================================================

// src/config.ts
import { envSchema } from "env-schema";
import { Static, Type } from "@sinclair/typebox";


const schema = Type.Object({
  // Server
  PORT: Type.Number({ default: 8080 }),
  HOST: Type.String({ default: "127.0.0.1" }),
  NODE_ENV: Type.String({
    enum: ["development", "production", "test"],
    default: "development",
  }),
  LOG_LEVEL: Type.String({ default: "info" }),

  // Database
  DATABASE_URL: Type.String(),

  // JWT
  JWT_SECRET: Type.String(),
  JWT_EXPIRES_IN: Type.String({ default: "7d" }),

  // WeChat Mini Program
  WX_APP_ID: Type.String(),
  WX_APP_SECRET: Type.String(),

  // WeChat Pay (optional, can be empty strings in dev)
  WXPAY_MCHID: Type.String({ default: "" }),
  WXPAY_PRIVATE_KEY_PATH: Type.String({ default: "" }),
  WXPAY_CERT_SERIAL_NO: Type.String({ default: "" }),
  WXPAY_API_V3_KEY: Type.String({ default: "" }),
  WXPAY_NOTIFY_URL: Type.String({ default: "" }),

  // Tanshu API
  TANSHU_API_KEY: Type.String({ default: "" }),

  // Business Logic Constants ("Magic Numbers")
  ORDER_PAYMENT_TTL_MINUTES: Type.Number({ default: 15 }),
  ORDER_PICKUP_CODE_LENGTH: Type.Number({ default: 10 }),
  ORDER_PICKUP_CODE_BYTES: Type.Number({ default: 5 }),
  MAX_ITEMS_PER_ORDER: Type.Number({ default: 10 }),
  MAX_RESERVED_ITEMS_PER_USER: Type.Number({ default: 20 }),
  API_RATE_LIMIT_MAX: Type.Number({ default: 5 }),
  API_RATE_LIMIT_WINDOW_MINUTES: Type.Number({ default: 1 }),

  // Database Transaction Retry Configuration
  DB_TRANSACTION_RETRY_COUNT: Type.Number({ default: 3 }),
  DB_TRANSACTION_RETRY_BASE_DELAY_MS: Type.Number({ default: 20 }),
  DB_TRANSACTION_RETRY_JITTER_MS: Type.Number({ default: 40 }),
  PICKUP_CODE_RETRY_COUNT: Type.Number({ default: 5 }),

  // Payment Security
  PAYMENT_TIMESTAMP_TOLERANCE_SECONDS: Type.Number({ default: 300 }),

  // Scheduled Job Configuration
  CRON_ORDER_CLEANUP: Type.String({ default: "*/1 * * * *" }),
  CRON_INVENTORY_METRICS: Type.String({ default: "*/5 * * * *" }),
  CRON_WECHAT_CERT_REFRESH: Type.String({ default: "0 */10 * * *" }),
  CRON_REFUND_PROCESSOR: Type.String({ default: "*/10 * * * *" }),

  // API Rate Limiting
  API_LOGIN_RATE_LIMIT_MAX: Type.Number({ default: 10 }),
  API_FULFILL_RATE_LIMIT_MAX: Type.Number({ default: 30 }),
});

type Schema = Static<typeof schema>;

// The `dotenv: true` option will automatically load the .env file
const config = envSchema<Schema>({
  schema,
  dotenv: true,
});

// Production validation
if (config.NODE_ENV === "production") {
  if (!config.JWT_SECRET || config.JWT_SECRET === "default-secret-for-dev") {
    console.error(
      "FATAL: JWT_SECRET must be set to a strong secret in production.",
    );
    process.exit(1);
  }
  if (!config.DATABASE_URL) {
    console.error("FATAL: DATABASE_URL must be set in production.");
    process.exit(1);
  }
  // Add other critical production checks here
}

export default config;


================================================================================
### FILE: bookworm-backend\src\constants.ts
================================================================================

export const ORDER_STATUS = {
  PENDING_PAYMENT: 'PENDING_PAYMENT',
  PENDING_PICKUP: 'PENDING_PICKUP',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED'
} as const;

export const INVENTORY_STATUS = {
  IN_STOCK: 'in_stock',
  RESERVED: 'reserved',
  SOLD: 'sold'
} as const;

export const ERROR_CODES = {
  UNAUTHORIZED: 'UNAUTHORIZED',
  FORBIDDEN: 'FORBIDDEN',
  VALIDATION_ERROR: 'VALIDATION_ERROR',
  RATE_LIMIT_EXCEEDED: 'RATE_LIMIT_EXCEEDED',
  RECORD_NOT_FOUND: 'RECORD_NOT_FOUND',
  DUPLICATE_RECORD: 'DUPLICATE_RECORD',
  BAD_REQUEST: 'BAD_REQUEST',
  INTERNAL_ERROR: 'INTERNAL_ERROR',
  TX_RETRY_EXCEEDED: 'TX_RETRY_EXCEEDED',
  EMPTY_ITEMS: 'EMPTY_ITEMS',
  ORDER_SIZE_EXCEEDED: 'ORDER_SIZE_EXCEEDED',
  MAX_RESERVED_ITEMS_EXCEEDED: 'MAX_RESERVED_ITEMS_EXCEEDED',
  INSUFFICIENT_INVENTORY_PRECHECK: 'INSUFFICIENT_INVENTORY_PRECHECK',
  PICKUP_CODE_GEN_FAILED: 'PICKUP_CODE_GEN_FAILED',
  INVENTORY_RACE_CONDITION: 'INVENTORY_RACE_CONDITION',
  CONCURRENT_PENDING_ORDER: 'CONCURRENT_PENDING_ORDER'
} as const;

export const ERROR_MESSAGES = {
  AUTHENTICATION_REQUIRED: 'Authentication required',
  ACCESS_DENIED: 'Access denied',
  VALIDATION_FAILED: 'Request validation failed',
  RECORD_NOT_FOUND: 'Record not found',
  DUPLICATE_RECORD: 'A record with this data already exists',
  INTERNAL_ERROR: 'Internal server error',
  SYSTEM_BUSY: '系统繁忙，请稍后重试',
  NO_BOOKS_SELECTED: '没有选择任何书籍',
  BOOKS_UNAVAILABLE: '部分书籍已不可用，请刷新后重试',
  PICKUP_CODE_GENERATION_FAILED: '无法生成唯一订单取货码',
  INVENTORY_RACE: '手慢了，部分书籍已被抢购，请重新下单',
  CONCURRENT_ORDER: '您有一个正在付款的订单，请先完成付款或等待订单过期'
} as const;

export const HTTP_STATUS = {
  UNAUTHORIZED: 401,
  FORBIDDEN: 403
} as const;

export const WECHAT_CONSTANTS = {
  JSCODE2SESSION_URL: 'https://api.weixin.qq.com/sns/jscode2session',
  GRANT_TYPE: 'authorization_code',
  SUCCESS_CODE: 'SUCCESS',
  FAIL_CODE: 'FAIL',
  SUCCESS_MESSAGE: '成功',
  RETRY_MESSAGE: '请稍后重试',
  SIGN_TYPE: 'RSA'
} as const;

export const API_CONSTANTS = {
  TANSHU_BASE_URL: 'https://api.tanshuapi.com/api/isbn/v2/index'
} as const;

export const DEFAULT_VALUES = {
  EDITION: 'default',
  UNKNOWN_TITLE: '未知书名',
  UNKNOWN_AUTHOR: '未知作者',
  UNKNOWN_PUBLISHER: '未知出版社',
  NO_SUMMARY: '暂无简介',
  ORDER_NUMBER_PREFIX: 'BOOKWORM_'
} as const;

export const BUSINESS_LIMITS = {
  MAX_REFUND_ATTEMPTS: 5,
  REFUND_BATCH_SIZE: 50,
  TRANSACTION_TIMEOUT_MS: 15000,
  AMOUNT_TO_CENTS_MULTIPLIER: 100,
  MAX_AMOUNT_CENTS: 100000000,
  CLOCK_SKEW_TOLERANCE_SECONDS: 60,
  PAYMENT_QUERY_RETRY_ATTEMPTS: 3,
  PAYMENT_QUERY_RETRY_DELAY_MS: 200,
  ADVISORY_LOCK_TIMEOUT_MS: 5 * 60 * 1000,
  DEFAULT_RETRY_ATTEMPTS: 3,
  DEFAULT_RETRY_DELAY_MS: 100
} as const;

export const ENVIRONMENT_CHECKS = {
  NON_TEST_ENVIRONMENTS: ['production', 'development']
} as const;


================================================================================
### FILE: bookworm-backend\src\db.ts
================================================================================

// bookworm-backend/src/db.ts
import { PrismaClient } from '@prisma/client';

// Add prisma to the NodeJS global type
declare global {
  // eslint-disable-next-line no-var
  var prisma: PrismaClient | undefined;
}

const prisma = global.prisma || new PrismaClient({
  log: process.env.NODE_ENV === 'development' ? ['query', 'info', 'warn', 'error'] : ['warn', 'error'],
});

if (process.env.NODE_ENV !== 'production') {
  global.prisma = prisma;
}

// --- Graceful Shutdown Logic ---

async function gracefulShutdown(signal: string) {
  console.log(`[GRACEFUL SHUTDOWN] Received ${signal}. Shutting down gracefully...`);
  try {
    await prisma.$disconnect();
    console.log('[GRACEFUL SHUTDOWN] Prisma client disconnected successfully.');
  } catch (error) {
    console.error('[GRACEFUL SHUTDOWN] Error during Prisma disconnection:', error);
  }
  console.log('[GRACEFUL SHUTDOWN] Process exiting...');
  process.exit(0);
}

// `beforeExit` is a good fallback for when the event loop empties,
// but it's not called on explicit termination signals.
process.on('beforeExit', async () => {
  console.log('beforeExit event triggered. Disconnecting Prisma client...');
  await prisma.$disconnect();
});

// Listen for the signals that are actually used to terminate processes.
// SIGINT is for Ctrl+C.
// SIGTERM is the standard signal for graceful termination (e.g., from Docker/Kubernetes).
process.on('SIGINT', () => gracefulShutdown('SIGINT'));
process.on('SIGTERM', () => gracefulShutdown('SIGTERM'));

export default prisma;


================================================================================
### FILE: bookworm-backend\src\errors.ts
================================================================================

// src/errors.ts

export class ApiError extends Error {
  public statusCode: number;
  public code: string;

  constructor(statusCode: number, message: string, code: string) {
    super(message);
    this.name = "ApiError";
    this.statusCode = statusCode;
    this.code = code;

    Error.captureStackTrace(this, this.constructor);
  }
}

export class WechatPayError extends Error {
  constructor(
    public code: string, // e.g., 'ORDER_NOT_FOUND', 'SERVER_ERROR', 'INVALID_REQUEST'
    public isRetryable: boolean,
    message: string,
    public originalError?: unknown // Optional: store the original error for logging
  ) {
    super(message);
    this.name = 'WechatPayError';
  }
}

export class PaymentQueryError extends Error {
  constructor(
    public code: string,
    public originalError?: unknown
  ) {
    super(`Payment query failed: ${code}`);
    this.name = 'PaymentQueryError';
  }
}


================================================================================
### FILE: bookworm-backend\src\index.ts
================================================================================

// src/index.ts
import Fastify, { FastifyRequest, FastifyReply } from "fastify";
import { createWechatPayAdapter, WechatPayAdapter } from "./adapters/wechatPayAdapter";
import { Prisma } from "@prisma/client";
import { ApiError } from "./errors";
import config from "./config";
import { verifyDatabaseConstraints } from "./utils/dbVerifier";
import prisma from "./db";
import { ERROR_CODES, ERROR_MESSAGES, HTTP_STATUS } from "./constants";
import * as fs from "fs";
import {
  isFastifyHttpError,
  isFastifyValidationError,
  getErrorMessage
} from "./utils/typeGuards";

// Plugins and Routes
import { registerPlugins } from "./plugins";
import { startCronJobs } from "./jobs";
import authRoutes from "./routes/auth";
import healthRoutes from "./routes/health";
import booksRoutes from "./routes/books";
import inventoryRoutes from "./routes/inventory";
import contentRoutes from "./routes/content";
import ordersRoutes from "./routes/orders";
import paymentRoutes from "./routes/payment";

// --- Type Augmentation for Fastify ---
declare module "fastify" {
  interface FastifyRequest {
    user?: { userId: number; openid: string; role?: string };
    rawBody?: string | Buffer;
  }
  export interface FastifyInstance {
    authenticate: (
      request: FastifyRequest,
      reply: FastifyReply,
    ) => Promise<void>;
    requireRole: (
      role: "USER" | "STAFF",
    ) => (request: FastifyRequest, reply: FastifyReply) => Promise<void>;
  }
}

const fastify = Fastify({
  logger: {
    level: config.LOG_LEVEL,
    redact: ["headers.authorization", "req.headers.authorization"],
  },
  ajv: {
    customOptions: {
      coerceTypes: true,
      useDefaults: true,
    },
  },
});

// --- WeChat Pay Setup ---
let wechatPayAdapter: WechatPayAdapter | null = null;
try {
  if (
    config.WXPAY_MCHID &&
    config.WXPAY_PRIVATE_KEY_PATH &&
    fs.existsSync(config.WXPAY_PRIVATE_KEY_PATH) &&
    config.WXPAY_CERT_SERIAL_NO &&
    config.WXPAY_API_V3_KEY
  ) {
    wechatPayAdapter = createWechatPayAdapter({
      appid: config.WX_APP_ID,
      mchid: config.WXPAY_MCHID,
      privateKey: fs.readFileSync(config.WXPAY_PRIVATE_KEY_PATH),
      serial_no: config.WXPAY_CERT_SERIAL_NO,
      key: config.WXPAY_API_V3_KEY,
    });
    fastify.log.info("WeChat Pay SDK initialized successfully");
  } else {
    throw new Error(
      "WeChat Pay configuration is incomplete or certificate files are missing.",
    );
  }
} catch (error) {
  console.warn(
    `!!! WARNING: Failed to initialize WeChat Pay SDK. Payment features will be disabled. Reason: ${getErrorMessage(error)}`,
  );
}

// --- Global Error Handler ---
fastify.setErrorHandler(
  async (error: unknown, request: FastifyRequest, reply: FastifyReply) => {
    request.log.error(
      { err: error, req: request },
      "An error occurred during the request",
    );

    // Layer 1: Authentication/Authorization errors (401/403)
    if (isFastifyHttpError(error) && (error.statusCode === 401 || error.statusCode === 403)) {
      return reply.code(error.statusCode).send({
        code:
          error.code ||
          (error.statusCode === 401 ? ERROR_CODES.UNAUTHORIZED : ERROR_CODES.FORBIDDEN),
        message:
          error.message ||
          (error.statusCode === 401
            ? ERROR_MESSAGES.AUTHENTICATION_REQUIRED
            : ERROR_MESSAGES.ACCESS_DENIED),
      });
    }

    // Layer 2: Request validation errors (400)
    if (isFastifyValidationError(error)) {
      return reply.code(400).send({
        code: ERROR_CODES.VALIDATION_ERROR,
        message: ERROR_MESSAGES.VALIDATION_FAILED,
        details: error.validation,
      });
    }

    // Layer 3: Rate limiting errors (429)
    if (isFastifyHttpError(error) && error.statusCode === 429) {
      return reply.code(429).send({
        code: ERROR_CODES.RATE_LIMIT_EXCEEDED,
        message: error.message || "Too many requests, please try again later",
      });
    }

    // Layer 4: Our business logic errors (ApiError)
    if (error instanceof ApiError) {
      return reply.code(error.statusCode).send({
        code: error.code,
        message: error.message,
      });
    }

    // Layer 5: Prisma database errors
    if (error instanceof Prisma.PrismaClientKnownRequestError) {
      if (error.code === "P2025") {
        return reply.code(404).send({
          code: ERROR_CODES.RECORD_NOT_FOUND,
          message: ERROR_MESSAGES.RECORD_NOT_FOUND,
        });
      }
      if (error.code === "P2002") {
        return reply.code(409).send({
          code: ERROR_CODES.DUPLICATE_RECORD,
          message: ERROR_MESSAGES.DUPLICATE_RECORD,
        });
      }
    }

    // Layer 6: Generic schema validation errors (from Fastify)
    if (isFastifyHttpError(error) && error.statusCode === 400) {
      return reply.code(400).send({
        code: ERROR_CODES.BAD_REQUEST,
        message: error.message || "Invalid request format",
      });
    }

    // Layer 7: Catch-all for unknown errors (500)
    request.log.fatal({ err: error }, "Unhandled error in application");
    reply.code(500).send({
      code: ERROR_CODES.INTERNAL_ERROR,
      message: ERROR_MESSAGES.INTERNAL_ERROR,
    });
  },
);

// Production configuration validation
const validateProductionConfig = () => {
  if (process.env.NODE_ENV !== "production") {
    return; // Only validate in production
  }

  const criticalMissingConfigs: string[] = [];

  // JWT Secret validation
  if (config.JWT_SECRET === "default-secret-for-dev" || !config.JWT_SECRET) {
    criticalMissingConfigs.push("JWT_SECRET");
  }

  // WeChat App validation
  if (config.WX_APP_ID === "YOUR_APP_ID" || !config.WX_APP_ID) {
    criticalMissingConfigs.push("WX_APP_ID");
  }
  if (config.WX_APP_SECRET === "YOUR_APP_SECRET" || !config.WX_APP_SECRET) {
    criticalMissingConfigs.push("WX_APP_SECRET");
  }

  // Database URL validation
  if (!process.env.DATABASE_URL) {
    criticalMissingConfigs.push("DATABASE_URL");
  }

  if (criticalMissingConfigs.length > 0) {
    console.error("");
    console.error(
      "🚨 FATAL ERROR: Critical configuration missing in production environment!",
    );
    console.error("❌ Missing required environment variables:");
    criticalMissingConfigs.forEach((config) => {
      console.error(`   - ${config}`);
    });
    console.error("");
    console.error(
      "📋 Please set these environment variables and restart the application.",
    );
    console.error(
      "🛑 Shutting down to prevent production deployment with insecure configuration.",
    );
    console.error("");
    process.exit(1);
  }

  console.log("✅ Production configuration validation passed");
};

const setupApplication = async () => {
  // Register all plugins
  await registerPlugins(fastify);

  // Register all routes
  await fastify.register(healthRoutes);
  await fastify.register(authRoutes);
  await fastify.register(booksRoutes);
  await fastify.register(inventoryRoutes);
  await fastify.register(contentRoutes);
  await fastify.register(ordersRoutes);
  await fastify.register(paymentRoutes, { wechatPayAdapter });
};

// Export function to build app for testing
export const buildApp = async () => {
  await setupApplication();
  return fastify;
};

const start = async () => {
  try {
    validateProductionConfig();
    await verifyDatabaseConstraints(prisma);

    await setupApplication();

    await fastify.listen({ port: config.PORT, host: config.HOST });

    // Start cron jobs after server is running
    startCronJobs(fastify);
  } catch (err) {
    fastify.log.error(err);
    process.exit(1);
  }
};

// Only start the server if this file is executed directly (not imported)
if (require.main === module) {
  start();
}


================================================================================
### FILE: bookworm-backend\src\jobs.ts
================================================================================

// src/jobs.ts
import { FastifyInstance } from "fastify";
import * as cron from "node-cron";
import { withAdvisoryLock } from "./utils/dbLock";
import { cancelExpiredOrders } from "./services/orderService";
import { metrics } from "./plugins/metrics";
import { processRefundQueue } from "./jobs/refundProcessor";
import config from "./config";
import prisma from "./db";

export function startCronJobs(fastify: FastifyInstance): void {
  // --- START OF FIX: 添加订单清理定时任务 ---

  // 注意：'*/1 * * * *' (每分钟执行) 适用于开发和测试。
  // 在生产环境中，应通过 config.ts 配置为更合理的频率，例如 '*/5 * * * *' (每5分钟)。
  cron.schedule(config.CRON_ORDER_CLEANUP, async () => {
    await withAdvisoryLock(prisma, "job:cancel_expired_orders", async () => {
      fastify.log.info("Running scheduled job: CancelExpiredOrders");
      try {
        // 在一个 try...catch 块中安全地调用它
        const result = await prisma.$transaction(async (tx) => {
          return cancelExpiredOrders(tx);
        });

        // 记录有意义的日志
        if (result.cancelledCount > 0) {
          fastify.log.info(
            `CancelExpiredOrders job finished: ${result.cancelledCount} order(s) cancelled`,
          );
        } else {
          fastify.log.info(
            "CancelExpiredOrders job finished: No expired orders found",
          );
        }
      } catch (error) {
        // 捕获并记录任何潜在的错误，防止搞垮主进程
        console.error(
          'CRITICAL: The "CancelExpiredOrders" job failed:',
          error,
        );
      }
    });
  });

  // --- END OF FIX ---

  // Schedule a job to update inventory gauge metrics every 5 minutes.
  cron.schedule(config.CRON_INVENTORY_METRICS, async () => {
    await withAdvisoryLock(
      prisma,
      "job:update_inventory_metrics",
      async () => {
        fastify.log.info("Running scheduled job to update inventory metrics");
        try {
          const inventoryCounts = await prisma.inventoryItem.groupBy({
            by: ["status"],
            _count: {
              id: true,
            },
          });
          inventoryCounts.forEach((item) => {
            metrics.inventoryStatus.labels(item.status).set(item._count.id);
          });
        } catch (error) {
          console.error(
            'CRITICAL: The "updateInventoryMetrics" job failed:',
            error,
          );
        }
      },
    );
  });

  // Schedule refund processing job every 10 minutes
  cron.schedule(config.CRON_REFUND_PROCESSOR, async () => {
    await withAdvisoryLock(
      prisma,
      "job:process_refunds",
      async () => {
        fastify.log.info("Running scheduled job to process pending refunds");
        try {
          await processRefundQueue();
        } catch (error) {
          console.error(
            'CRITICAL: The "processRefunds" job failed:',
            error,
          );
        }
      },
    );
  });
}


================================================================================
### FILE: bookworm-backend\src\jobs\cancelExpiredOrders.ts
================================================================================

import { Prisma } from "@prisma/client";
import { cancelExpiredOrders } from "../services/orderService";
import prisma from "../db";

const LOCK_NAMESPACE_JOBS = 100;
const LOCK_JOB_CANCEL_EXPIRED = 1;

async function main() {
  console.log("Starting cancelExpiredOrders job with advisory lock...");

  try {
    const result = await prisma.$transaction(async (tx) => {
      const [lockResult] = await tx.$queryRaw<[{ pg_try_advisory_xact_lock: boolean }]>(
        Prisma.sql`SELECT pg_try_advisory_xact_lock(${LOCK_NAMESPACE_JOBS}, ${LOCK_JOB_CANCEL_EXPIRED})`,
      );

      if (!lockResult.pg_try_advisory_xact_lock) {
        console.log("Another instance is already running the job. Skipping.");
        return null;
      }

      console.log("Lock acquired. Running cancelExpiredOrders job...");
      return await cancelExpiredOrders(tx);
    });

    if (result && result.cancelledCount > 0) {
      console.log(`Job completed successfully. Cancelled ${result.cancelledCount} expired orders.`);
    } else if (result) {
      console.log("Job completed successfully. No expired orders found.");
    }

  } catch (error) {
    console.error("Job failed:", error);
    process.exit(1);
  } finally {
    await prisma.$disconnect();
    process.exit(0);
  }
}

main();


================================================================================
### FILE: bookworm-backend\src\jobs\refundProcessor.ts
================================================================================

// src/jobs/refundProcessor.ts
import db from '../db';
import config from '../config';
import { processPendingRefunds } from '../services/refundService';
import { createWechatPayAdapter } from '../adapters/wechatPayAdapter';
import * as fs from 'fs';
import * as path from 'path';

/**
 * Background job to process pending refunds
 * This job runs periodically to handle refunds for cancelled orders
 */
export async function processRefundQueue(): Promise<void> {
  try {
    console.log('Starting refund processing job...');

    // Skip if WeChat Pay is not configured
    if (!config.WXPAY_MCHID || !config.WXPAY_PRIVATE_KEY_PATH) {
      console.log('WeChat Pay not configured, skipping refund processing');
      return;
    }

    // Initialize WeChat Pay adapter
    let privateKeyBuffer: Buffer;
    try {
      const keyPath = path.resolve(config.WXPAY_PRIVATE_KEY_PATH);
      privateKeyBuffer = fs.readFileSync(keyPath);
    } catch (error) {
      console.error('Failed to read WeChat Pay private key file:', error);
      return;
    }

    const wechatPayAdapter = createWechatPayAdapter({
      appid: config.WX_APP_ID,
      mchid: config.WXPAY_MCHID,
      privateKey: privateKeyBuffer,
      serial_no: config.WXPAY_CERT_SERIAL_NO,
      key: config.WXPAY_API_V3_KEY,
    });

    // Process refunds
    const result = await processPendingRefunds(db, wechatPayAdapter);

    console.log(`Refund processing completed: ` +
      `Processed ${result.processedCount} records, ` +
      `${result.successCount} successful, ` +
      `${result.failureCount} failed`);

    if (result.failureCount > 0) {
      console.warn(`${result.failureCount} refunds failed. Reasons:`, result.failures);
    }

  } catch (error) {
    console.error('Refund processing job failed:', error);
    // Don't re-throw to prevent job scheduler from crashing
  }
}


================================================================================
### FILE: bookworm-backend\src\plugins.ts
================================================================================

// src/plugins.ts
import { FastifyInstance } from "fastify";
import * as path from "path";
import fastifyStatic from "@fastify/static";
import authPlugin from "./plugins/auth";
import metricsPlugin from "./plugins/metrics";
import fastifyRawBody from "fastify-raw-body";
import rateLimit from "@fastify/rate-limit";

export async function registerPlugins(fastify: FastifyInstance): Promise<void> {
  // Register plugins first - MUST be awaited in correct order
  await fastify.register(fastifyStatic, {
    root: path.join(__dirname, "..", "public"),
    prefix: "/admin/",
  });
  await fastify.register(authPlugin);
  await fastify.register(metricsPlugin);
  await fastify.register(fastifyRawBody, {
    field: "rawBody",
    global: false, // 只在需要的路由上启用
    encoding: "utf8",
    runFirst: true,
  });
  await fastify.register(rateLimit, {
    global: false, // 我们按路由单独配置
  });
}


================================================================================
### FILE: bookworm-backend\src\plugins\auth.ts
================================================================================

import fp from 'fastify-plugin';
import { createVerifier } from 'fast-jwt';
import config from '../config';
import { FastifyRequest, FastifyReply } from 'fastify';

export default fp(async (fastify) => {
  const verifier = createVerifier({ key: config.JWT_SECRET });

  fastify.decorate('authenticate', async (req: FastifyRequest, reply: FastifyReply) => {
    try {
      if (!req.headers.authorization) {
        return reply.code(401).send({ code: 'UNAUTHORIZED', message: 'Missing authorization header' });
      }

      const token = req.headers.authorization.replace('Bearer ', '');
      const payload = await verifier(token);
      req.user = {
        userId: payload.userId,
        openid: payload.openid,
        role: payload.role // 从JWT payload直接获取role
      };
    } catch (err: unknown) {
      fastify.log.warn({ err }, 'Authentication failed');
      return reply.code(401).send({ code: 'UNAUTHORIZED', message: 'Invalid token' });
    }
  });

  fastify.decorate('requireRole', (role: 'USER' | 'STAFF') => {
    return async (req: FastifyRequest, reply: FastifyReply) => {
      if (!req.user) return reply.code(401).send({ code: 'UNAUTHORIZED', message: 'Unauthorized' });

      // 从JWT payload中直接验证角色，无需查询数据库
      if (!req.user.role || req.user.role !== role) {
        return reply.code(403).send({ code: 'FORBIDDEN', message: 'Forbidden' });
      }

      // Debug logging for tests
      if (process.env.NODE_ENV === 'test') {
        fastify.log.info({
          userId: req.user.userId,
          userRole: req.user.role,
          requiredRole: role,
          source: 'jwt_payload'
        }, 'Role check debug');
      }
    };
  });
}, {
  name: 'auth-plugin',
  fastify: '4.x'
});


================================================================================
### FILE: bookworm-backend\src\plugins\metrics.ts
================================================================================

// src/plugins/metrics.ts
import { FastifyInstance } from "fastify";
import fp from "fastify-plugin";
import client from "prom-client";

// 启用默认的 Node.js 指标 (CPU, memory, etc.)
// 只在非测试环境中收集默认指标，避免重复注册错误
if (process.env.NODE_ENV !== 'test') {
  client.collectDefaultMetrics();
}

// --- 定义我们的核心业务指标 ---

// Singleton mock objects for testing - reuse instead of creating new objects
const mockIncrementer = { inc: () => {} };
const mockSetter = { set: () => {} };

// Only create metrics in non-test environments to avoid conflicts
export const metrics = process.env.NODE_ENV !== 'test' ? {
  ordersCreated: new client.Counter({
    name: "bookworm_orders_created_total",
    help: "Total number of orders created",
  }),
  ordersCompleted: new client.Counter({
    name: "bookworm_orders_completed_total",
    help: "Total number of orders successfully fulfilled (picked up)",
  }),
  ordersCancelled: new client.Counter({
    name: "bookworm_orders_cancelled_total",
    help: "Total number of orders cancelled due to expiration",
  }),
  paymentsProcessed: new client.Counter({
    name: "bookworm_payments_processed_total",
    help: "Total number of payment notifications processed",
    labelNames: ["status"], // 'success', 'refund_required', 'failure'
  }),
  dbTransactionRetries: new client.Counter({
    name: "bookworm_db_transaction_retries_total",
    help: "Total number of database transaction retries due to serialization conflicts",
  }),
  inventoryStatus: new client.Gauge({
    name: "bookworm_inventory_items_count",
    help: "Current number of inventory items by status",
    labelNames: ["status"], // 'in_stock', 'reserved', 'sold', etc.
  }),
  usersLoggedInTotal: new client.Gauge({
    name: "bookworm_users_logged_in_total",
    help: "Total number of unique users who have logged in",
  }),
  orderFulfillmentDurationSeconds: new client.Histogram({
    name: "bookworm_order_fulfillment_duration_seconds",
    help: "Histogram of the time taken from payment to fulfillment for an order",
    buckets: [60, 300, 900, 1800, 3600, 7200, 86400], // 1min, 5min, 15min, 30min, 1hr, 2hr, 1day
  }),
} : {
  // Mock metrics for testing - reuse singleton objects
  ordersCreated: { labels: () => mockIncrementer, inc: () => {} },
  ordersCompleted: { labels: () => mockIncrementer, inc: () => {} },
  ordersCancelled: { labels: () => mockIncrementer, inc: () => {} },
  paymentsProcessed: { labels: () => mockIncrementer, inc: () => {} },
  dbTransactionRetries: { labels: () => mockIncrementer, inc: () => {} },
  inventoryStatus: { labels: () => mockSetter },
  usersLoggedInTotal: { set: () => {}, inc: () => {} },
  orderFulfillmentDurationSeconds: { observe: () => {} },
};

async function metricsPlugin(fastify: FastifyInstance) {
  fastify.get("/metrics", async (request, reply) => {
    reply.header("Content-Type", client.register.contentType);
    reply.send(await client.register.metrics());
  });
  console.log("Metrics endpoint registered at /metrics");
}

export default fp(metricsPlugin);


================================================================================
### FILE: bookworm-backend\src\routes\auth.ts
================================================================================

// src/routes/auth.ts
import { FastifyPluginAsync } from "fastify";
import { Type, Static } from "@sinclair/typebox";
import { generateJwtToken, persistWeChatUser, requestWxSession } from "../services/authService";
import config from "../config";
import prisma from "../db";

const LoginBodySchema = Type.Object({
  code: Type.String({ minLength: 1 }),
});

const authRoutes: FastifyPluginAsync = async function (fastify) {
  fastify.post<{ Body: Static<typeof LoginBodySchema> }>(
    "/api/auth/login",
    {
      config: {
        rateLimit: {
          max: config.API_LOGIN_RATE_LIMIT_MAX,
          timeWindow: "1 minute",
        },
      },
      schema: {
        body: LoginBodySchema,
      },
    },
    async (request, reply) => {
      const { code } = request.body;
      const session = await requestWxSession(code);
      const user = await prisma.$transaction((tx) => persistWeChatUser(tx, session));
      const token = generateJwtToken(user);
      reply.send({ token, userId: user.id });
    },
  );
};

export default authRoutes;


================================================================================
### FILE: bookworm-backend\src\routes\books.ts
================================================================================

// src/routes/books.ts
import { FastifyPluginAsync } from "fastify";
import { Type, Static } from "@sinclair/typebox";
import { getBookMetadata } from "../services/bookMetadataService";
import { ApiError } from "../errors";

const BookMetaQuerySchema = Type.Object({
  isbn: Type.String({ minLength: 10, maxLength: 13 }),
});

const booksRoutes: FastifyPluginAsync = async function (fastify) {
  // Books metadata
  fastify.get<{ Querystring: Static<typeof BookMetaQuerySchema> }>(
    "/api/books/meta",
    {
      schema: {
        querystring: BookMetaQuerySchema,
      },
    },
    async (request, reply) => {
      const { isbn } = request.query;

      const metadata = await getBookMetadata(isbn);
      if (!metadata) {
        throw new ApiError(
          404,
          "Book metadata not found.",
          "BOOK_METADATA_NOT_FOUND",
        );
      }

      reply.send(metadata);
    }
  );
};

export default booksRoutes;


================================================================================
### FILE: bookworm-backend\src\routes\content.ts
================================================================================

// src/routes/content.ts
import { FastifyPluginAsync } from "fastify";
import { Type, Static } from "@sinclair/typebox";
import { getContentBySlug } from "../services/contentService";
import prisma from "../db";

const ContentParamsSchema = Type.Object({
  slug: Type.String({ minLength: 1 }),
});

const contentRoutes: FastifyPluginAsync = async function (fastify) {
  // Content Management
  fastify.get<{ Params: Static<typeof ContentParamsSchema> }>(
    "/api/content/:slug",
    {
      schema: {
        params: ContentParamsSchema,
      },
    },
    async (request, reply) => {
      const { slug } = request.params;
      const content = await getContentBySlug(prisma, slug);
      reply.send(content);
    }
  );
};

export default contentRoutes;


================================================================================
### FILE: bookworm-backend\src\routes\health.ts
================================================================================

// src/routes/health.ts
import { FastifyPluginAsync } from "fastify";
import prisma from "../db";

const healthRoutes: FastifyPluginAsync = async function (fastify) {
  // Health Check Endpoint
  fastify.get("/api/health", async (request, reply) => {
    const checks: { [key: string]: string } = {};
    let allHealthy = true;

    // Database connectivity check
    try {
      await prisma.$queryRaw`SELECT 1`;
      checks.database = "ok";
    } catch (error) {
      request.log.error(error, "Database health check failed");
      checks.database = "failed";
      allHealthy = false;
    }

    if (allHealthy) {
      reply.send({
        status: "ok",
        timestamp: new Date().toISOString(),
        checks,
      });
    } else {
      reply.code(503).send({
        status: "error",
        timestamp: new Date().toISOString(),
        checks,
      });
    }
  });
};

export default healthRoutes;


================================================================================
### FILE: bookworm-backend\src\routes\inventory.ts
================================================================================

// src/routes/inventory.ts
import { FastifyPluginAsync } from "fastify";
import { Type, Static } from "@sinclair/typebox";
import {
  getAvailableBooks,
  getBookById,
  persistInventoryItem,
} from "../services/inventoryService";
import { getBookMetadata } from "../services/bookMetadataService";
import { ApiError } from "../errors";
import config from "../config";
import prisma from "../db";

const ListAvailableQuery = Type.Object({
  search: Type.Optional(Type.String({ minLength: 1, maxLength: 50 })),
  page: Type.Optional(Type.Number({ minimum: 1, maximum: 100, default: 1 })),
  limit: Type.Optional(Type.Number({ minimum: 1, maximum: 100, default: 20 })),
});

const GetItemParamsSchema = Type.Object({
  id: Type.Number(),
});

const AddBookBody = Type.Object({
  isbn13: Type.String({ minLength: 10, maxLength: 13 }),
  title: Type.String({ minLength: 1 }),
  author: Type.Optional(Type.String()),
  edition: Type.Optional(Type.String()),
  condition: Type.Union([Type.Literal("NEW"), Type.Literal("GOOD"), Type.Literal("ACCEPTABLE")]),
  cost: Type.Number({ minimum: 0 }),
  selling_price: Type.Number({ minimum: 0 }),
});

const inventoryRoutes: FastifyPluginAsync = async function (fastify) {
  fastify.get<{ Querystring: Static<typeof ListAvailableQuery> }>(
    "/api/inventory/available",
    { schema: { querystring: ListAvailableQuery } },
    async (request, reply) => {
      const { search, page, limit } = request.query;
      const books = await getAvailableBooks(prisma, { searchTerm: search, page, limit });
      reply.send(books);
    }
  );

  fastify.get<{ Params: Static<typeof GetItemParamsSchema> }>(
    "/api/inventory/item/:id",
    {
      schema: {
        params: GetItemParamsSchema,
      },
    },
    async (request, reply) => {
      const id = request.params.id;
      const book = await getBookById(prisma, id);
      if (!book) {
        throw new ApiError(404, "Book not found.", "BOOK_NOT_FOUND");
      }
      reply.send(book);
    },
  );

  fastify.post<{ Body: Static<typeof AddBookBody> }>(
    "/api/inventory/add",
    { preHandler: [fastify.authenticate, fastify.requireRole("STAFF")], schema: { body: AddBookBody } },
    async (request, reply) => {
      let metadata = null;
      try {
        metadata = await getBookMetadata(request.body.isbn13);
      } catch (error) {
        request.log.warn({ err: error }, "获取图书元数据失败，使用用户输入补全");
      }

      const newItem = await prisma.$transaction((tx) =>
        persistInventoryItem(tx, request.body, metadata),
      );
      reply.code(201).send(newItem);
    },
  );
};

export default inventoryRoutes;


================================================================================
### FILE: bookworm-backend\src\routes\orders.ts
================================================================================

// src/routes/orders.ts
import { FastifyPluginAsync } from "fastify";
import { Type, Static } from "@sinclair/typebox";
import {
  createOrder,
  getOrdersByUserId,
  getOrderById,
  fulfillOrder,
  getPendingPickupOrders,
  updateOrderStatus,
} from "../services/orderService";
import { ApiError } from "../errors";
import config from "../config";
import prisma from "../db";

const CreateOrderBodySchema = Type.Object({
  inventoryItemIds: Type.Array(Type.Number(), { minItems: 1 }),
});

const FulfillOrderBodySchema = Type.Object({
  pickupCode: Type.String({ minLength: 1 }),
});

const UpdateOrderStatusBodySchema = Type.Object({
  status: Type.Union([Type.Literal("COMPLETED"), Type.Literal("CANCELLED")]),
});

const OrderIdParamsSchema = Type.Object({
  id: Type.Number(),
});

const UserIdParamsSchema = Type.Object({
  userId: Type.Number(),
});

const OrderListQuerySchema = Type.Object({
  cursor: Type.Optional(Type.String()),
  limit: Type.Optional(Type.Integer({ minimum: 1, maximum: 50 })),
});

const ordersRoutes: FastifyPluginAsync = async function (fastify) {
  fastify.post<{ Body: Static<typeof CreateOrderBodySchema> }>(
    "/api/orders/create",
    {
      preHandler: [fastify.authenticate],
      config: {
        rateLimit: {
          max: config.API_RATE_LIMIT_MAX,
          timeWindow: `${config.API_RATE_LIMIT_WINDOW_MINUTES} minute`,
          keyGenerator: (req) => req.user?.userId.toString() || req.ip,
        },
      },
      schema: {
        body: CreateOrderBodySchema,
      },
    },
    async (request, reply) => {
      const { inventoryItemIds } = request.body;
      const order = await createOrder(prisma, {
        userId: request.user!.userId,
        inventoryItemIds,
      });
      reply.code(201).send(order);
    },
  );

  fastify.get<{ Params: Static<typeof OrderIdParamsSchema> }>(
    "/api/orders/:id",
    {
      preHandler: [fastify.authenticate],
      schema: {
        params: OrderIdParamsSchema,
      },
    },
    async (request, reply) => {
      const orderId = request.params.id;

      const order = await getOrderById(prisma, orderId, request.user!.userId);
      reply.send(order);
    },
  );

  fastify.get<{
    Params: Static<typeof UserIdParamsSchema>;
    Querystring: Static<typeof OrderListQuerySchema>;
  }>(
    "/api/orders/user/:userId",
    {
      preHandler: [fastify.authenticate],
      schema: {
        params: UserIdParamsSchema,
        querystring: OrderListQuerySchema,
      },
    },
    async (request, reply) => {
      if (request.params.userId !== request.user!.userId) {
        throw new ApiError(403, "Forbidden", "USER_ACCESS_DENIED");
      }
      const { cursor, limit } = request.query;

      const orders = await getOrdersByUserId(prisma, request.user!.userId, {
        cursor: cursor ?? undefined,
        limit: limit ?? undefined,
      });
      reply.send({
        data: orders.data,
        meta: {
          nextCursor: orders.nextCursor,
        },
      });
    },
  );

  fastify.post<{ Body: Static<typeof FulfillOrderBodySchema> }>(
    "/api/orders/fulfill",
    {
      preHandler: [fastify.authenticate, fastify.requireRole("STAFF")],
      config: {
        rateLimit: {
          max: config.API_FULFILL_RATE_LIMIT_MAX,
          timeWindow: "1 minute",
          keyGenerator: (req) => req.user?.userId.toString() || req.ip,
        },
      },
      schema: {
        body: FulfillOrderBodySchema,
      },
    },
    async (request, reply) => {
      const { pickupCode } = request.body;
      const order = await fulfillOrder(prisma, pickupCode.toUpperCase());
      reply.send(order);
    },
  );

  fastify.get(
    "/api/orders/pending-pickup",
    { preHandler: [fastify.authenticate, fastify.requireRole("STAFF")] },
    async (request, reply) => {
      const orders = await getPendingPickupOrders(prisma);
      reply.send(orders);
    },
  );

  // Update order status (STAFF only)
  fastify.patch<{
    Params: Static<typeof OrderIdParamsSchema>;
    Body: Static<typeof UpdateOrderStatusBodySchema>;
  }>(
    "/api/orders/:id/status",
    {
      preHandler: [fastify.authenticate, fastify.requireRole("STAFF")],
      config: {
        rateLimit: {
          max: config.API_RATE_LIMIT_MAX,
          timeWindow: `${config.API_RATE_LIMIT_WINDOW_MINUTES} minute`,
        },
      },
      schema: {
        params: OrderIdParamsSchema,
        body: UpdateOrderStatusBodySchema,
      },
    },
    async (request, reply) => {
      const orderId = request.params.id;
      const { status } = request.body;

      const updatedOrder = await updateOrderStatus(prisma, orderId, status, {
        userId: request.user!.userId,
        role: request.user!.role!,
      });
      reply.send(updatedOrder);
    },
  );
};

export default ordersRoutes;


================================================================================
### FILE: bookworm-backend\src\routes\payment.ts
================================================================================

// bookworm-backend/src/routes/payment.ts
import { FastifyPluginAsync, FastifyRequest } from "fastify";
import { Type, Static } from "@sinclair/typebox";
import { WechatPayAdapter } from "../adapters/wechatPayAdapter";
import {
  buildClientPaymentSignature,
  buildWechatPaymentRequest,
  preparePaymentIntent,
  processPaymentNotification,
} from "../services/orderService";
import { ApiError, PaymentQueryError } from "../errors";
import config from "../config";
import prisma from "../db";
import { WECHAT_CONSTANTS } from "../constants";

interface PaymentRoutesOptions {
  wechatPayAdapter: WechatPayAdapter | null;
}

const OrderIdParamsSchema = Type.Object({
  orderId: Type.Number(),
});

const PaymentNotifySchema = Type.Object({
  headers: Type.Object({
    'wechatpay-timestamp': Type.String({ minLength: 1 }),
    'wechatpay-nonce': Type.String({ minLength: 1 }),
    'wechatpay-signature': Type.String({ minLength: 1 }),
    'wechatpay-serial': Type.String({ minLength: 1 }),
  }),
  body: Type.Object({
    resource: Type.Object({
      ciphertext: Type.String(),
      associated_data: Type.String(),
      nonce: Type.String(),
    }),
  }),
});


const paymentRoutes: FastifyPluginAsync<PaymentRoutesOptions> = async function (fastify, opts) {
  const { wechatPayAdapter } = opts;

  // ... (the /api/orders/:orderId/pay route remains the same, no need to change it)
  fastify.post<{ Params: Static<typeof OrderIdParamsSchema> }>(
    "/api/orders/:orderId/pay",
    {
      preHandler: [fastify.authenticate],
      schema: {
        params: OrderIdParamsSchema,
      },
    },
    async (request, reply) => {
      if (!wechatPayAdapter) throw new ApiError(503, "Payment service is not configured.", "PAYMENT_SERVICE_UNAVAILABLE");
      const { orderId } = request.params;
      const intent = await preparePaymentIntent(prisma, orderId, request.user!.userId);
      const { prepay_id } = await wechatPayAdapter.createPaymentOrder(
        buildWechatPaymentRequest(intent),
      );
      const paymentParams = buildClientPaymentSignature(intent, prepay_id, wechatPayAdapter);
      reply.send(paymentParams);
    },
  );

  // Payment callback - COMPLETELY REWRITTEN
  fastify.post<{ Headers: Static<typeof PaymentNotifySchema>['headers']; Body: Static<typeof PaymentNotifySchema>['body'] }>(
    "/api/payment/notify",
    {
      config: { rawBody: true },
      schema: {
        headers: PaymentNotifySchema.properties.headers,
        body: PaymentNotifySchema.properties.body,
      },
    },
    async (request, reply) => {
    if (!wechatPayAdapter) {
      request.log.error("WeChat Pay adapter is not configured. Cannot process notification.");
      // Return 503 to signal a temporary failure, prompting WeChat to retry.
      return reply.code(503).send({ code: "FAIL", message: "服务暂时不可用" });
    }

    try {
      // 1. Extract validated headers (TypeBox has already validated them)
      const {
        'wechatpay-timestamp': timestamp,
        'wechatpay-nonce': nonce,
        'wechatpay-signature': signature,
        'wechatpay-serial': serial,
      } = request.headers;

      const rawBody = request.rawBody;
      if (!rawBody) {
        throw new ApiError(400, "Missing raw body for payment notification", "MISSING_BODY");
      }

      // 2. Decrypt notification and pass to service layer
      // TypeBox has already validated that body contains a resource object
      const resource = request.body.resource;
      let notificationData;
      try {
        const decryptedDataStr = wechatPayAdapter.decryptNotificationData({
          ciphertext: resource.ciphertext,
          associated_data: resource.associated_data,
          nonce: resource.nonce,
          apiv3Key: config.WXPAY_API_V3_KEY,
        });
        notificationData = JSON.parse(decryptedDataStr);
      } catch (decryptError) {
        request.log.warn({ err: decryptError, resource }, "Payment notification decryption failed. This is a permanent error for this request.");
        // Return 200 OK to acknowledge receipt and prevent WeChat from retrying a malformed request.
        return reply.code(200).send({ code: WECHAT_CONSTANTS.SUCCESS_CODE, message: WECHAT_CONSTANTS.SUCCESS_MESSAGE });
      }

      // 3. Hand off to the robust service layer function with security context
      await processPaymentNotification(prisma, wechatPayAdapter, {
        ...notificationData,
        timestamp,
        nonce,
        signature,
        serial,
        body: rawBody.toString(),
      });

      // 4. Signal success to WeChat
      reply.code(200).send({ code: WECHAT_CONSTANTS.SUCCESS_CODE, message: WECHAT_CONSTANTS.SUCCESS_MESSAGE });

    } catch (error) {
      request.log.error({ err: error }, "Payment notification processing failed.");

      // Specific handling for transient errors where we want WeChat to retry
      if (error instanceof ApiError && error.code === 'PAY_TRANSIENT_STATE') {
        return reply.code(503).send({ code: WECHAT_CONSTANTS.FAIL_CODE, message: WECHAT_CONSTANTS.RETRY_MESSAGE });
      }
      if (error instanceof PaymentQueryError && error.code === 'WECHAT_QUERY_FAILED_TRANSIENT') {
        return reply.code(503).send({ code: WECHAT_CONSTANTS.FAIL_CODE, message: WECHAT_CONSTANTS.RETRY_MESSAGE });
      }

      // For all other errors (e.g., bad signature, permanent API errors), we tell WeChat we're "done" to prevent endless retries.
      reply.code(200).send({ code: WECHAT_CONSTANTS.SUCCESS_CODE, message: WECHAT_CONSTANTS.SUCCESS_MESSAGE });
    }
  });
};

export default paymentRoutes;


================================================================================
### FILE: bookworm-backend\src\services\authService.ts
================================================================================

// src/services/authService.ts
import axios from "axios";
import { createSigner } from "fast-jwt";
import { PrismaClient, Prisma } from "@prisma/client";
import config from "../config";
import { metrics } from "../plugins/metrics";
import { WECHAT_CONSTANTS } from "../constants";

type DbCtx = PrismaClient | Prisma.TransactionClient;

interface WxSession {
  openid: string;
  unionid?: string;
}

// Helper functions for user management - each with single responsibility

async function findUserByUnionId(dbCtx: DbCtx, unionid: string) {
  return await dbCtx.user.findUnique({ where: { unionid } });
}

async function findUserByOpenId(dbCtx: DbCtx, openid: string) {
  return await dbCtx.user.findUnique({ where: { openid } });
}

async function updateUserOpenId(dbCtx: DbCtx, userId: number, openid: string) {
  return await dbCtx.user.update({
    where: { id: userId },
    data: { openid },
  });
}

async function updateUserUnionId(dbCtx: DbCtx, userId: number, unionid: string) {
  return await dbCtx.user.update({
    where: { id: userId },
    data: { unionid },
  });
}

async function createUser(dbCtx: DbCtx, openid: string, unionid?: string) {
  const user = await dbCtx.user.create({
    data: { openid, unionid },
  });

  metrics.usersLoggedInTotal.inc();

  return user;
}

async function ensureUserWithUnionId(dbCtx: DbCtx, openid: string, unionid: string) {
  // Try to find by unionid first (most reliable identifier)
  const userByUnionId = await findUserByUnionId(dbCtx, unionid);
  if (userByUnionId) {
    // Update openid if it changed
    if (userByUnionId.openid !== openid) {
      return await updateUserOpenId(dbCtx, userByUnionId.id, openid);
    }
    return userByUnionId;
  }

  // No user with this unionid, try to find by openid
  const userByOpenId = await findUserByOpenId(dbCtx, openid);
  if (userByOpenId) {
    // Update existing user with unionid
    return await updateUserUnionId(dbCtx, userByOpenId.id, unionid);
  }

  // No existing user, create new one
  return await createUser(dbCtx, openid, unionid);
}

async function ensureUserWithOpenIdOnly(dbCtx: DbCtx, openid: string) {
  const existingUser = await findUserByOpenId(dbCtx, openid);
  if (existingUser) {
    return existingUser;
  }

  // No existing user, create new one
  return await createUser(dbCtx, openid);
}

export function generateJwtToken(user: { id: number; openid: string; role: string }) {
  const signer = createSigner({
    key: config.JWT_SECRET,
    expiresIn: config.JWT_EXPIRES_IN,
  });

  return signer({
    userId: user.id,
    openid: user.openid,
    role: user.role // 将角色包含在JWT中，避免每次请求查数据库
  });
}

export async function requestWxSession(code: string): Promise<WxSession> {
  const url = `${WECHAT_CONSTANTS.JSCODE2SESSION_URL}?appid=${config.WX_APP_ID}&secret=${config.WX_APP_SECRET}&js_code=${code}&grant_type=${WECHAT_CONSTANTS.GRANT_TYPE}`;
  const { data } = await axios.get(url);

  if (data.errcode) {
    throw new Error(`WeChat API Error: ${data.errmsg}`);
  }

  return data as WxSession;
}

export async function persistWeChatUser(dbCtx: DbCtx, { openid, unionid }: WxSession) {
  return unionid
    ? ensureUserWithUnionId(dbCtx, openid, unionid)
    : ensureUserWithOpenIdOnly(dbCtx, openid);
}

export async function wxLogin(prisma: PrismaClient, code: string) {
  const session = await requestWxSession(code);

  const user = await prisma.$transaction(async (tx) => {
    return persistWeChatUser(tx, session);
  });

  const token = await generateJwtToken(user);

  return { token, user };
}


================================================================================
### FILE: bookworm-backend\src\services\bookMetadataService.ts
================================================================================

// bookworm-backend/src/services/bookMetadataService.ts
import axios from "axios";

import config from "../config";
import { ApiError } from "../errors";
import { API_CONSTANTS, DEFAULT_VALUES } from "../constants";

interface TanshuBookData {
  title: string;
  img: string;
  author: string;
  isbn: string;
  publisher: string;
  pubdate: string;
  price: string;
  summary: string;
  // ... other fields from Tanshu API
}

interface TanshuApiResponse {
  code: number;
  msg: string;
  data: TanshuBookData;
}

interface BookMetadata {
  isbn13: string;
  title: string;
  author: string;
  publisher: string;
  summary: string;
  original_price: number;
  cover_image_url: string;
}

/**
 * Fetches book metadata from Tanshu API using ISBN.
 * @param isbn The ISBN-13 of the book.
 * @returns Parsed metadata or null if not found or service unavailable.
 * @throws ApiError with code METADATA_SERVICE_UNAVAILABLE on network errors.
 */
export async function getBookMetadata(
  isbn: string,
): Promise<BookMetadata | null> {
  if (!config.TANSHU_API_KEY) {
    console.warn(
      "!!! WARNING: TANSHU_API_KEY is not configured in .env. Book metadata feature is disabled.",
    );
    return null;
  }

  const url = `${API_CONSTANTS.TANSHU_BASE_URL}?key=${config.TANSHU_API_KEY}&isbn=${isbn}`;

  try {
    const response = await axios.get<TanshuApiResponse>(url, {
      validateStatus: () => true, // 接受所有状态码，自己处理
    });

    if (response.status !== 200 || response.data.code !== 1) {
      console.error(
        `Tanshu API Error for ISBN ${isbn}: Status ${response.status}, code: ${response.data.code}, msg: ${response.data.msg}`,
      );
      return null;
    }

    const data = response.data.data;

    let priceValue = 0;
    if (data.price) {
      try {
        const priceMatch = data.price.match(/(\d+\.?\d*)/);
        if (priceMatch) {
          priceValue = parseFloat(priceMatch[1]);
        }
      } catch (error) {
        console.warn(`Could not parse price for ${data.title}: ${data.price}`, error);
      }
    }

    return {
      isbn13: data.isbn,
      title: data.title || DEFAULT_VALUES.UNKNOWN_TITLE,
      author: data.author || DEFAULT_VALUES.UNKNOWN_AUTHOR,
      publisher: data.publisher || DEFAULT_VALUES.UNKNOWN_PUBLISHER,
      summary: data.summary || DEFAULT_VALUES.NO_SUMMARY,
      original_price: priceValue,
      cover_image_url: data.img || "",
    };
  } catch (error) {
    const errorMessage = (error as Error).message;
    console.error(
      `Network error calling Tanshu API for ISBN ${isbn}:`,
      errorMessage,
    );
    throw new ApiError(
      503,
      `Metadata service unavailable: ${errorMessage}`,
      "METADATA_SERVICE_UNAVAILABLE"
    );
  }
}


================================================================================
### FILE: bookworm-backend\src\services\contentService.ts
================================================================================

// src/services/contentService.ts
import { PrismaClient } from "@prisma/client";
import { Prisma } from "@prisma/client";

export async function getContentBySlug(dbCtx: PrismaClient | Prisma.TransactionClient, slug: string) {
  return await dbCtx.content.findUniqueOrThrow({
    where: { slug },
  });
}


================================================================================
### FILE: bookworm-backend\src\services\inventoryService.ts
================================================================================

// src/services/inventoryService.ts (fully replaced)
import { Prisma, PrismaClient, book_condition } from "@prisma/client";
import { getBookMetadata } from "./bookMetadataService";
import { DEFAULT_VALUES, INVENTORY_STATUS } from "../constants";

type DbCtx = PrismaClient | Prisma.TransactionClient;
type BookMetadata = Awaited<ReturnType<typeof getBookMetadata>>;

interface AddBookInput {
  isbn13: string;
  title: string;
  author?: string;
  edition?: string;
  condition: book_condition;
  cost: number;
  selling_price: number;
}

export async function persistInventoryItem(dbCtx: DbCtx, input: AddBookInput, metadata: BookMetadata | null) {
  const bookMaster = await dbCtx.bookMaster.upsert({
    where: { isbn13: input.isbn13 },
    update: {
      ...(metadata && {
        title: metadata.title,
        author: metadata.author,
        publisher: metadata.publisher,
        original_price: metadata.original_price,
      }),
    },
    create: {
      isbn13: input.isbn13,
      title: metadata?.title || input.title,
      author: metadata?.author || input.author,
      publisher: metadata?.publisher,
      original_price: metadata?.original_price,
    },
  });

  const bookSku = await dbCtx.bookSku.upsert({
    where: {
      master_id_edition: {
        master_id: bookMaster.id,
        edition: input.edition || DEFAULT_VALUES.EDITION,
      },
    },
    update: {
      ...(metadata && {
        cover_image_url: metadata.cover_image_url,
      }),
    },
    create: {
      master_id: bookMaster.id,
      edition: input.edition || DEFAULT_VALUES.EDITION,
      cover_image_url: metadata?.cover_image_url,
    },
  });

  return dbCtx.inventoryItem.create({
    data: {
      sku_id: bookSku.id,
      condition: input.condition,
      cost: input.cost,
      selling_price: input.selling_price,
      status: INVENTORY_STATUS.IN_STOCK,
    },
  });
}

export async function addBookToInventory(prisma: PrismaClient, input: AddBookInput, metadata?: BookMetadata | null) {
  let resolvedMetadata: BookMetadata | null = null;
  if (metadata !== undefined) {
    resolvedMetadata = metadata;
  } else {
    resolvedMetadata = await getBookMetadata(input.isbn13).catch(() => null);
  }

  return prisma.$transaction((tx) => persistInventoryItem(tx, input, resolvedMetadata));
}

// FIXED: getAvailableBooks using Prisma.sql template tags for safe parameterization
export async function getAvailableBooks(
  prisma: PrismaClient,
  options: { searchTerm?: string; page?: number; limit?: number } = {},
) {
  const { searchTerm, page = 1, limit = 20 } = options;
  const skip = (page - 1) * limit;

  // --- Base query parts, safe from injection ---
  const selectClause = Prisma.sql`
    SELECT
      i.id, i.condition, i.selling_price, i.status,
      json_build_object(
        'id', s.id,
        'edition', s.edition,
        'cover_image_url', s.cover_image_url,
        'bookmaster', json_build_object(
          'id', m.id,
          'isbn13', m.isbn13,
          'title', m.title,
          'author', m.author,
          'publisher', m.publisher,
          'original_price', m.original_price
        )
      ) as booksku
    FROM "inventoryitem" i
    JOIN "booksku" s ON i.sku_id = s.id
    JOIN "bookmaster" m ON s.master_id = m.id
  `;
  const fromAndJoinClause = Prisma.sql`
    FROM "inventoryitem" i
    JOIN "booksku" s ON i.sku_id = s.id
    JOIN "bookmaster" m ON s.master_id = m.id
  `;

  // --- Dynamic WHERE and ORDER BY clauses ---
  const whereConditions: Prisma.Sql[] = [Prisma.sql`i.status = 'in_stock'`];
  let orderByClause = Prisma.sql`ORDER BY i.created_at DESC`;

  if (searchTerm && searchTerm.trim()) {
    const trimmedSearchTerm = searchTerm.trim();
    // Prisma.sql automatically handles parameterization
    whereConditions.push(Prisma.sql`(m.title ILIKE ${'%' + trimmedSearchTerm + '%'} OR m.author ILIKE ${'%' + trimmedSearchTerm + '%'})`);
    orderByClause = Prisma.sql`ORDER BY i.created_at DESC`;
  }

  const whereClause = Prisma.join(whereConditions, ' AND ');

  // --- Build and execute the queries ---
  const countQuery = Prisma.sql`SELECT COUNT(i.id) as "count" ${fromAndJoinClause} WHERE ${whereClause}`;
  const dataQuery = Prisma.sql`${selectClause} WHERE ${whereClause} ${orderByClause} LIMIT ${limit} OFFSET ${skip}`;

  const [totalResult, items] = await Promise.all([
    prisma.$queryRaw<{ count: bigint }[]>(countQuery),
    prisma.$queryRaw<any[]>(dataQuery),
  ]);

  const totalItems = (totalResult && totalResult.length > 0) ? Number(totalResult[0].count) : 0;

  return {
    data: items || [],
    meta: {
      totalItems,
      totalPages: Math.ceil(totalItems / limit),
      currentPage: page,
      itemsPerPage: limit,
    },
  };
}

// NEW: Function to get a single book by its inventory item ID
export async function getBookById(prisma: PrismaClient | Prisma.TransactionClient, id: number) {
  return prisma.inventoryItem.findUnique({
    where: { id },
    select: {
      id: true,
      condition: true,
      selling_price: true,
      status: true,
      bookSku: {
        select: {
          id: true,
          edition: true,
          cover_image_url: true,
          bookMaster: {
            select: {
              id: true,
              isbn13: true,
              title: true,
              author: true,
              publisher: true,
              original_price: true,
            },
          },
        },
      },
    },
  });
}


================================================================================
### FILE: bookworm-backend\src\services\orderService.ts
================================================================================

// src/services/orderService.ts (fully replaced)
import { Prisma, PrismaClient } from "@prisma/client";

import { WechatPayAdapter } from "../adapters/wechatPayAdapter";

import * as crypto from "crypto";
import config from "../config";
import { ApiError, WechatPayError, PaymentQueryError } from "../errors";
import { metrics } from "../plugins/metrics";
import { retryAsync } from "../utils/retry";
import {
  isPrismaSerializationError,
  isPrismaKnownError,
  isPickupCodeConstraintError
} from "../utils/typeGuards";
import {
  ORDER_STATUS,
  INVENTORY_STATUS,
  ERROR_CODES,
  ERROR_MESSAGES,
  DEFAULT_VALUES,
  BUSINESS_LIMITS,
  WECHAT_CONSTANTS
} from "../constants";

// 通用的事务重试辅助函数
async function withTxRetry<T>(fn: () => Promise<T>): Promise<T> {
  for (let i = 0; i < config.DB_TRANSACTION_RETRY_COUNT; i++) {
    try {
      return await fn();
    } catch (e: unknown) {
      // 检查是否为 Prisma 的序列化失败
      if (isPrismaSerializationError(e)) {
        if (i < config.DB_TRANSACTION_RETRY_COUNT - 1) {
          // Only increment on actual retries, not the final failure
          metrics.dbTransactionRetries.inc();
        }
        // 指数退避+抖动等待
        await new Promise((r) =>
          setTimeout(
            r,
            config.DB_TRANSACTION_RETRY_BASE_DELAY_MS * Math.pow(2, i) +
              Math.random() * config.DB_TRANSACTION_RETRY_JITTER_MS,
          ),
        );
        continue;
      }
      // 非可重试错误，立即抛出
      throw e;
    }
  }
  // 重试后仍失败
  throw new ApiError(409, "系统繁忙，请稍后重试", "TX_RETRY_EXCEEDED");
}

// Helper functions for createOrderImpl - each with single responsibility

async function validateOrderInput(input: { userId: number; inventoryItemIds: number[] }) {
  const itemIds = Array.from(new Set(input.inventoryItemIds));
  if (itemIds.length === 0) {
    throw new ApiError(400, "没有选择任何书籍", "EMPTY_ITEMS");
  }
  if (itemIds.length > config.MAX_ITEMS_PER_ORDER) {
    throw new ApiError(400, `单笔订单最多 ${config.MAX_ITEMS_PER_ORDER} 件`, "ORDER_SIZE_EXCEEDED");
  }
  return itemIds;
}

async function acquireOrderLocks(tx: Prisma.TransactionClient, userId: number, itemIds: number[]) {
  // Step 1: User-level lock first (consistent ordering to prevent deadlocks)
  await tx.$executeRawUnsafe(
    'SELECT pg_advisory_xact_lock($1::int4, $2::int4)',
    1,
    userId,
  );

  // Step 2: Acquire item-level advisory locks to prevent concurrent reservation
  // This prevents race conditions when multiple users try to purchase the same book
  // Lock items in sorted order to prevent deadlocks
  const sortedItemIds = [...itemIds].sort((a, b) => a - b);
  for (const itemId of sortedItemIds) {
    await tx.$executeRawUnsafe(
      'SELECT pg_advisory_xact_lock($1::int4, $2::int4)',
      2,
      itemId,
    );
  }
}

async function validateInventoryAndReservations(tx: Prisma.TransactionClient, userId: number, itemIds: number[]) {
  // Check for total reserved items (now safe from race conditions)
  const existingReservedItems = await tx.order.findMany({
    where: { user_id: userId, status: "PENDING_PAYMENT" },
    include: { _count: { select: { orderItem: true } } },
  });
  const totalReservedCount = existingReservedItems.reduce(
    (sum, order) => sum + order._count.orderItem, 0,
  );
  if (totalReservedCount + itemIds.length > config.MAX_RESERVED_ITEMS_PER_USER) {
    throw new ApiError(403, `您预留的商品总数已达上限(${config.MAX_RESERVED_ITEMS_PER_USER}件)，请先完成或取消部分订单`, "MAX_RESERVED_ITEMS_EXCEEDED");
  }

  // Verify items are still available (with locks held)
  const itemsToReserve = await tx.inventoryItem.findMany({
    where: { id: { in: itemIds }, status: INVENTORY_STATUS.IN_STOCK },
  });

  if (itemsToReserve.length !== itemIds.length) {
    throw new ApiError(409, "部分书籍已不可用，请刷新后重试", "INSUFFICIENT_INVENTORY_PRECHECK");
  }

  const totalAmount = itemsToReserve.reduce(
    (sum, item) => sum.add(item.selling_price), new Prisma.Decimal(0),
  );

  return { itemsToReserve, totalAmount };
}

async function generateUniquePickupCode() {
  return crypto
    .randomBytes(config.ORDER_PICKUP_CODE_BYTES)
    .toString("hex")
    .toUpperCase()
    .substring(0, config.ORDER_PICKUP_CODE_LENGTH);
}

async function createOrderRecord(tx: Prisma.TransactionClient, userId: number, totalAmount: Prisma.Decimal) {
  // Create order with pickup_code retry logic
  for (let attempt = 0; attempt < config.PICKUP_CODE_RETRY_COUNT; attempt++) {
    const pickup_code = await generateUniquePickupCode();

    try {
      return await tx.order.create({
        data: {
          user_id: userId,
          status: "PENDING_PAYMENT",
          total_amount: totalAmount,
          pickup_code,
          paymentExpiresAt: new Date(
            Date.now() + config.ORDER_PAYMENT_TTL_MINUTES * 60 * 1000,
          ),
        },
      });
    } catch (e: unknown) {
      if (isPickupCodeConstraintError(e)) {
        continue;
      }
      throw e;
    }
  }

  throw new ApiError(500, "无法生成唯一订单取货码", "PICKUP_CODE_GEN_FAILED");
}

async function reserveInventoryItems(
  tx: Prisma.TransactionClient,
  orderId: number,
  itemIds: number[],
) {
  const updateResult = await tx.inventoryItem.updateMany({
    where: { id: { in: itemIds }, status: INVENTORY_STATUS.IN_STOCK },
    data: { status: INVENTORY_STATUS.RESERVED },
  });

  if (updateResult.count !== itemIds.length) {
    throw new ApiError(409, "部分书籍已经被其他订单锁定，请刷新后重试", "INVENTORY_RACE_CONDITION");
  }

  await tx.inventoryReservation.createMany({
    data: itemIds.map((itemId) => ({
      inventory_item_id: itemId,
      order_id: orderId,
    })),
    skipDuplicates: true,
  });
}

async function createOrderItems(
  tx: Prisma.TransactionClient,
  orderId: number,
  items: Array<{ id: number; selling_price: Prisma.Decimal }>,
) {
  await tx.orderItem.createMany({
    data: items.map((item) => ({
      order_id: orderId,
      inventory_item_id: item.id,
      price: item.selling_price,
    })),
  });
}

async function createOrderImpl(tx: Prisma.TransactionClient, input: {
  userId: number;
  inventoryItemIds: number[];
}) {
  // Step 1: Validate input and normalize item IDs
  const itemIds = await validateOrderInput(input);

  // Step 2: Acquire all necessary locks
  await acquireOrderLocks(tx, input.userId, itemIds);

  // Step 3: Validate inventory availability and user reservations
  const { itemsToReserve, totalAmount } = await validateInventoryAndReservations(tx, input.userId, itemIds);

  // Step 4: Create order record with unique pickup code
  const order = await createOrderRecord(tx, input.userId, totalAmount);

  // Step 5: Reserve inventory and create order items
  await reserveInventoryItems(tx, order.id, itemIds);
  await createOrderItems(tx, order.id, itemsToReserve);

  // Step 6: Update metrics and return
  metrics.ordersCreated.inc();
  return order;
}

export async function createOrder(dbCtx: PrismaClient | Prisma.TransactionClient, input: {
  userId: number;
  inventoryItemIds: number[];
}) {
  try {
    // Check if dbCtx is PrismaClient by checking for $connect method (TransactionClient doesn't have this)
    if ('$connect' in dbCtx) {
      // dbCtx is PrismaClient, create a new transaction with retry logic
      return await withTxRetry(async () => {
        return await (dbCtx as PrismaClient).$transaction(async (tx) => {
          return createOrderImpl(tx, input);
        }, {
          timeout: 15000
        });
      });
    } else {
      // dbCtx is already a TransactionClient, use it directly
      return await createOrderImpl(dbCtx as Prisma.TransactionClient, input);
    }
  } catch (e: unknown) {
    if (e instanceof Prisma.PrismaClientKnownRequestError) {
      if (e.code === "P2002") {
        throw new ApiError(409, "您有一个正在付款的订单，请先完成付款或等待订单过期", "CONCURRENT_PENDING_ORDER");
      }
      if (e.code === "P2010" && typeof e.meta?.message === "string" && e.meta.message.includes("MAX_RESERVED_ITEMS_PER_USER")) {
        throw new ApiError(403, `您预留的商品总数已达上限(${config.MAX_RESERVED_ITEMS_PER_USER}件)，请先完成或取消部分订单`, "MAX_RESERVED_ITEMS_EXCEEDED");
      }
      if (typeof e.message === "string" && e.message.includes("MAX_RESERVED_ITEMS_PER_USER")) {
        throw new ApiError(403, `您预留的商品总数已达上限(${config.MAX_RESERVED_ITEMS_PER_USER}件)，请先完成或取消部分订单`, "MAX_RESERVED_ITEMS_EXCEEDED");
      }
    }
    throw e;
  }
}

export async function getOrdersByUserId(
  dbCtx: PrismaClient | Prisma.TransactionClient,
  userId: number,
  options: { limit?: number; cursor?: string } = {},
) {
  const { limit = 10, cursor } = options;
  const rawLimit = typeof limit === "number" ? limit : Number(limit);
  const parsedLimit = Number.isFinite(rawLimit) ? Math.floor(rawLimit) : 10;
  const normalizedLimit = Math.max(1, Math.min(parsedLimit, 50));

  let cursorDate: Date | null = null;
  let cursorId: number | null = null;

  if (cursor) {
    const [cursorDatePart, cursorIdPart] = cursor.split("_");
    if (cursorDatePart && cursorIdPart) {
      const parsedDate = new Date(cursorDatePart);
      const parsedId = Number(cursorIdPart);

      if (!Number.isNaN(parsedDate.getTime()) && Number.isInteger(parsedId) && parsedId > 0) {
        cursorDate = parsedDate;
        cursorId = parsedId;
      }
    }
  }

  const where: Prisma.OrderWhereInput = {
    user_id: userId,
  };

  if (cursorDate && cursorId !== null) {
    where.OR = [
      { createdAt: { lt: cursorDate } },
      {
        createdAt: cursorDate,
        id: { lt: cursorId },
      },
    ];
  }

  const orders = await dbCtx.order.findMany({
    where,
    select: {
      id: true,
      user_id: true,
      status: true,
      total_amount: true,
      pickup_code: true,
      paymentExpiresAt: true,
      paid_at: true,
      cancelled_at: true,
      createdAt: true,
      orderItem: {
        select: {
          id: true,
          order_id: true,
          inventory_item_id: true,
          inventoryItem: {
            select: {
              id: true,
              condition: true,
              selling_price: true,
              bookSku: {
                select: {
                  id: true,
                  edition: true,
                  cover_image_url: true,
                  bookMaster: {
                    select: {
                      id: true,
                      isbn13: true,
                      title: true,
                      author: true,
                      publisher: true,
                      original_price: true,
                    },
                  },
                },
              },
            },
          },
        },
      },
    },
    orderBy: [
      { createdAt: "desc" },
      { id: "desc" },
    ],
    take: normalizedLimit + 1,
  });

  const hasMore = orders.length > normalizedLimit;
  const pageData = hasMore ? orders.slice(0, normalizedLimit) : orders;
  const nextCursor = hasMore && pageData.length > 0
    ? `${pageData[pageData.length - 1].createdAt.toISOString()}_${pageData[pageData.length - 1].id}`
    : null;

  return {
    data: pageData,
    nextCursor,
  };
}

// NEW: Function to fulfill an order
async function fulfillOrderImpl(dbCtx: Prisma.TransactionClient, pickupCode: string) {
  // ATOMIC CONDITIONAL UPDATE: Only proceed if order exists and is in PENDING_PICKUP state
  const updatedOrder = await dbCtx.order.updateMany({
    where: {
      pickup_code: pickupCode,
      status: "PENDING_PICKUP"
    },
    data: {
      status: "COMPLETED",
      completed_at: new Date(),
    },
  });

  // Check if the atomic update was successful
  if (updatedOrder.count !== 1) {
    // Either order doesn't exist or is not in PENDING_PICKUP state
    const order = await dbCtx.order.findUnique({
      where: { pickup_code: pickupCode },
      select: { id: true, status: true },
    });

    if (!order) {
      throw new ApiError(
        404,
        `取货码 "${pickupCode}" 无效`,
        "INVALID_PICKUP_CODE",
      );
    } else {
      throw new ApiError(
        409,
        `此订单状态为 "${order.status}"，无法核销。订单必须已支付才能核销。`,
        "ORDER_STATE_INVALID",
      );
    }
  }

  // Get order items for inventory update
  const orderItems = await dbCtx.orderItem.findMany({
    where: {
      Order: { pickup_code: pickupCode }
    },
    select: { inventory_item_id: true },
  });

  const inventoryItemIds = orderItems.map(item => item.inventory_item_id);

  // Update inventory items to sold status and clear reservation pointer
  await dbCtx.inventoryItem.updateMany({
    where: { id: { in: inventoryItemIds } },
    data: {
      status: INVENTORY_STATUS.SOLD,
    },
  });

  // Only increment metrics after successful atomic update
  metrics.ordersCompleted.inc();

  // Return the updated order data
  const completedOrder = await dbCtx.order.findUnique({
    where: { pickup_code: pickupCode },
    include: { orderItem: true },
  });

  // Track fulfillment duration if both timestamps exist
  if (completedOrder && completedOrder.paid_at && completedOrder.completed_at) {
    const fulfillmentDurationSeconds =
      (completedOrder.completed_at.getTime() - completedOrder.paid_at.getTime()) / 1000;
    metrics.orderFulfillmentDurationSeconds.observe(fulfillmentDurationSeconds);
  }

  return completedOrder!;
}

export async function fulfillOrder(dbCtx: PrismaClient | Prisma.TransactionClient, pickupCode: string) {
  if ("$connect" in dbCtx) {
    return (dbCtx as PrismaClient).$transaction((tx) => fulfillOrderImpl(tx, pickupCode));
  }

  return fulfillOrderImpl(dbCtx as Prisma.TransactionClient, pickupCode);
}

export interface PaymentIntentContext {
  outTradeNo: string;
  amountTotal: number;
  description: string;
  timeExpireIso: string;
  openid: string;
}

export async function preparePaymentIntent(
  prisma: PrismaClient,
  orderId: number,
  userId: number,
): Promise<PaymentIntentContext> {
  return prisma.$transaction(async (tx) => {
    const order = await tx.order.findUniqueOrThrow({ where: { id: orderId } });
    if (order.user_id !== userId) {
      throw new ApiError(403, "无权支付此订单", "FORBIDDEN");
    }
    if (order.status !== "PENDING_PAYMENT") {
      throw new ApiError(409, "订单状态不正确", "ORDER_STATE_INVALID");
    }

    const user = await tx.user.findUniqueOrThrow({
      where: { id: userId },
      select: { openid: true },
    });

    const orderItems = await tx.orderItem.findMany({
      where: { order_id: orderId },
      select: {
        price: true,
        inventoryItem: {
          select: {
            bookSku: {
              select: {
                bookMaster: {
                  select: {
                    title: true,
                  },
                },
              },
            },
          },
        },
      },
    });

    const calculatedTotal = orderItems.reduce(
      (sum, item) => sum.add(item.price),
      new Prisma.Decimal(0),
    );

    if (calculatedTotal.comparedTo(order.total_amount) !== 0) {
      console.error(`CRITICAL: Amount mismatch for order ${orderId}. Stored: ${order.total_amount}, Calculated: ${calculatedTotal}`);
      throw new ApiError(400, "订单金额异常，请联系客服", "AMOUNT_MISMATCH");
    }

    const amountTotal = Math.round(parseFloat(order.total_amount.toString()) * 100);
    if (amountTotal <= 0 || amountTotal > 100000000) {
      throw new ApiError(400, "订单金额异常", "INVALID_AMOUNT");
    }

    const outTradeNo = `BOOKWORM_${order.id}`;

    await tx.paymentRecord.upsert({
      where: { out_trade_no: outTradeNo },
      create: {
        out_trade_no: outTradeNo,
        order_id: order.id,
        status: "PENDING",
        amount_total: amountTotal,
        appid: config.WX_APP_ID,
        mchid: config.WXPAY_MCHID,
      },
      update: {
        amount_total: amountTotal,
      },
    });

    const titles = orderItems.map((i) => i.inventoryItem.bookSku.bookMaster.title);
    const description =
      titles.slice(0, 3).join("、") +
      (titles.length > 3 ? `等${titles.length}本书籍` : "");

    return {
      outTradeNo,
      amountTotal,
      description,
      timeExpireIso: new Date(order.paymentExpiresAt).toISOString(),
      openid: user.openid,
    };
  });
}

export function buildWechatPaymentRequest(intent: PaymentIntentContext) {
  return {
    appid: config.WX_APP_ID,
    mchid: config.WXPAY_MCHID,
    description: intent.description,
    out_trade_no: intent.outTradeNo,
    notify_url: config.WXPAY_NOTIFY_URL,
    time_expire: intent.timeExpireIso,
    amount: { total: intent.amountTotal, currency: "CNY" as const },
    payer: { openid: intent.openid },
  };
}

export function buildClientPaymentSignature(
  intent: PaymentIntentContext,
  prepayId: string,
  wechatPayAdapter: WechatPayAdapter,
) {
  const timeStamp = Math.floor(Date.now() / 1000).toString();
  const nonceStr = crypto.randomBytes(16).toString("hex");
  const pkg = `prepay_id=${prepayId}`;
  const toSign = `${config.WX_APP_ID}\n${timeStamp}\n${nonceStr}\n${pkg}\n`;

  const paySign = wechatPayAdapter.generateSignature({ message: toSign });

  return { timeStamp, nonceStr, package: pkg, signType: "RSA" as const, paySign };
}

export async function generatePaymentParams(
  prisma: PrismaClient,
  wechatPayAdapter: WechatPayAdapter,
  orderId: number,
  userId: number,
) {
  const intent = await preparePaymentIntent(prisma, orderId, userId);
  const { prepay_id } = await wechatPayAdapter.createPaymentOrder(
    buildWechatPaymentRequest(intent),
  );

  return buildClientPaymentSignature(intent, prepay_id, wechatPayAdapter);
}

// Payment notification data with security validation requirements
interface PaymentNotificationData {
  timestamp: string;    // WeChat timestamp for replay protection
  nonce: string;        // Random string for replay protection
  signature: string;    // WeChat signature for authenticity
  serial: string;       // Certificate serial number
  body: string;         // Original notification body
  out_trade_no: string; // Business order number
}

export async function processPaymentNotification(
  dbCtx: PrismaClient | Prisma.TransactionClient,
  wechatPayAdapter: WechatPayAdapter,
  notificationData: PaymentNotificationData,
) {
  const { out_trade_no, timestamp, nonce, signature, serial, body } = notificationData;

  // === Phase 0: Security Validation (Zero Trust) ===

  // 1. Timestamp validation to prevent replay attacks
  const notificationTimestamp = parseInt(timestamp, 10);
  const currentTimestamp = Math.floor(Date.now() / 1000);

  // 拒绝未来时间戳，但允许合理的时钟偏差
  const CLOCK_SKEW_TOLERANCE = 60; // 允许60秒时钟偏差
  if (notificationTimestamp > currentTimestamp + CLOCK_SKEW_TOLERANCE) {
    console.warn(`Payment notification with future timestamp rejected for ${out_trade_no}. Notification: ${notificationTimestamp}, Current: ${currentTimestamp}, Tolerance: ${CLOCK_SKEW_TOLERANCE}s`);
    throw new ApiError(400, "Invalid future timestamp", "TIMESTAMP_INVALID");
  }

  // 检查过期（只允许合理的过去时间）
  if (currentTimestamp - notificationTimestamp > config.PAYMENT_TIMESTAMP_TOLERANCE_SECONDS) {
    console.warn(`Payment notification timestamp validation failed for ${out_trade_no}. Age: ${currentTimestamp - notificationTimestamp}s`);
    throw new ApiError(400, "Payment notification expired", "TIMESTAMP_EXPIRED");
  }

  // 2. Signature validation to ensure authenticity
  const isSignatureValid = wechatPayAdapter.verifySignature({
    timestamp,
    nonce,
    body,
    signature,
    serial,
  });

  if (!isSignatureValid) {
    console.error(`Payment notification signature validation failed for ${out_trade_no}`);
    throw new ApiError(400, "Invalid payment notification signature", "SIGNATURE_INVALID");
  }

  // === Phase 1: Pre-checks and Network I/O (Outside Transaction) ===

  // 1. Idempotency Check: See if we've already processed this.
  const initialPaymentRecord = await dbCtx.paymentRecord.findUnique({
    where: { out_trade_no },
  });

  if (!initialPaymentRecord) {
    console.warn(`Payment notification for unknown out_trade_no ${out_trade_no} received. Ignoring.`);
    return;
  }

  if (initialPaymentRecord.status !== 'PENDING') {
    console.log(`Payment notification for ${out_trade_no} already processed (status: ${initialPaymentRecord.status}). Skipping.`);
    return;
  }

  const executeInTransaction = async (fn: (tx: Prisma.TransactionClient) => Promise<void>) => {
    if ("$transaction" in dbCtx) {
      return await (dbCtx as PrismaClient).$transaction(fn);
    }

    return await fn(dbCtx as Prisma.TransactionClient);
  };

  const markPaymentAsFailed = async (
    updateData: Prisma.PaymentRecordUpdateManyMutationInput = {},
    logMessage?: string,
  ) => {
    const failed = await dbCtx.paymentRecord.updateMany({
      where: {
        out_trade_no,
        status: "PENDING",
      },
      data: {
        status: "FAILED",
        notified_at: new Date(),
        ...updateData,
      },
    });

    if (failed.count > 0) {
      if (logMessage) {
        console.warn(logMessage);
      }
      metrics.paymentsProcessed.labels({ status: "failed" }).inc();
    } else if (logMessage) {
      console.warn(
        `${logMessage} (skipped because payment record was already processed for ${out_trade_no}).`,
      );
    }
  };

  // 2. Active Query (Zero Trust Principle): Get the truth from WeChat's servers.
  let queriedTxData;
  try {
    queriedTxData = await retryAsync(
      () => wechatPayAdapter.queryPaymentStatus({ out_trade_no, mchid: config.WXPAY_MCHID }),
      3, // attempts
      200 // initial delay ms
    );
  } catch (queryError) {
    console.error(`Failed to query transaction ${out_trade_no} from WeChat Pay API after retries.`, queryError);

    // Business layer error handling - no HTTP status codes
    if (queryError instanceof WechatPayError && !queryError.isRetryable) {
      await markPaymentAsFailed({}, `Permanent error for ${out_trade_no}: ${queryError.message}. Marked as FAILED.`);
      return; // Stop processing.
    }

    // For all other errors (retryable WechatPayError or unknown errors), throw business exception
    throw new PaymentQueryError("WECHAT_QUERY_FAILED_TRANSIENT", queryError);
  }

  // 3. Validate the Truth
  const { trade_state, amount, payer, mchid, appid, transaction_id } = queriedTxData;

  if (trade_state !== 'SUCCESS') {
    const finalFailureStates = new Set(['CLOSED', 'REVOKED', 'PAYERROR']);
    if (finalFailureStates.has(trade_state)) {
      await markPaymentAsFailed(
        {
          transaction_id,
          payer_openid: payer?.openid,
        },
        `Payment for ${out_trade_no} is in a final failure state (${trade_state}). Marked as FAILED.`,
      );
    } else {
      // For transient states like USERPAYING, we want WeChat to retry later.
      console.log(`Payment for ${out_trade_no} is in transient state (${trade_state}). Requesting retry.`);
      throw new ApiError(503, `Payment in transient state: ${trade_state}`, "PAY_TRANSIENT_STATE");
    }
    return;
  }

  if (mchid !== config.WXPAY_MCHID || appid !== config.WX_APP_ID || amount.total !== initialPaymentRecord.amount_total) {
    console.error(`CRITICAL: Payment data mismatch for ${out_trade_no}. Marking as FAILED.`, {
        expected: { mchid: config.WXPAY_MCHID, appid: config.WX_APP_ID, total: initialPaymentRecord.amount_total },
        received: { mchid, appid, total: amount.total }
    });
    await markPaymentAsFailed({
      transaction_id,
      payer_openid: payer?.openid,
    });
    return;
  }

  // === Phase 2: Atomic State Update (Inside Transaction) ===
  await executeInTransaction(async (tx) => {
    // Re-fetch payment record to ensure it's still PENDING before we start.
    // This is an additional safeguard.
    const paymentRecord = await tx.paymentRecord.findUnique({
      where: { out_trade_no },
    });

    // Another process might have handled it. If so, we're done.
    if (!paymentRecord || paymentRecord.status !== 'PENDING') {
      console.log(`Payment ${out_trade_no} was processed by a concurrent request. Skipping.`);
      return;
    }

    // THE CRITICAL FIX: ATOMIC CONDITIONAL UPDATE
    // Attempt to transition the order from PENDING_PAYMENT to PENDING_PICKUP.
    // This will only succeed if the status is still PENDING_PAYMENT.
    const updatedOrder = await tx.order.updateMany({
      where: {
        id: paymentRecord.order_id,
        status: 'PENDING_PAYMENT',
      },
      data: {
        status: 'PENDING_PICKUP',
        paid_at: new Date(),
      },
    });

    // Check if the atomic update was successful.
    if (updatedOrder.count === 1) {
      // SUCCESS: We won the race. The order is now PENDING_PICKUP.
      // Finalize the payment record.
      await tx.paymentRecord.update({
        where: { out_trade_no },
        data: {
          status: 'SUCCESS',
          transaction_id,
          payer_openid: payer?.openid,
          notified_at: new Date(),
        },
      });
      console.log(`Order ${paymentRecord.order_id} successfully updated to PENDING_PICKUP.`);
      metrics.paymentsProcessed.labels({ status: "success" }).inc();
    } else {
      // FAILURE: We lost the race. The order was likely cancelled before payment was confirmed.
      // Mark the payment for refund.
      await tx.paymentRecord.update({
        where: { out_trade_no },
        data: {
          status: 'REFUND_REQUIRED',
          transaction_id,
          payer_openid: payer?.openid,
          notified_at: new Date(),
        },
      });
      console.error(`CRITICAL: Payment succeeded for an order (${paymentRecord.order_id}) that was not PENDING_PAYMENT (likely cancelled). Marked for refund.`);
      metrics.paymentsProcessed.labels({ status: "refund_required" }).inc();
    }
  });
}

export async function getPendingPickupOrders(dbCtx: PrismaClient | Prisma.TransactionClient) {
  // Linus式方案：分离查询，手动聚合，消除N+1

  // 1. 获取所有待取货订单及其orderItem（一层include）
  const ordersWithItems = await dbCtx.order.findMany({
    where: { status: "PENDING_PICKUP" },
    include: {
      orderItem: true, // 只include一层，避免深层嵌套
    },
    orderBy: { paid_at: "asc" },
  });

  // 2. 提取所有inventory_item_id
  const inventoryItemIds = ordersWithItems.flatMap((o) =>
    o.orderItem.map((item) => item.inventory_item_id),
  );

  // 如果没有订单，直接返回空数组
  if (inventoryItemIds.length === 0) {
    return [];
  }

  // 3. 一次性查询所有相关的inventory数据
  const inventoryItems = await dbCtx.inventoryItem.findMany({
    where: {
      id: { in: inventoryItemIds },
    },
    select: {
      id: true,
      condition: true,
      selling_price: true,
      status: true,
      bookSku: {
        select: {
          id: true,
          edition: true,
          cover_image_url: true,
          bookMaster: {
            select: {
              id: true,
              isbn13: true,
              title: true,
              author: true,
              publisher: true,
              original_price: true,
            },
          },
        },
      },
    },
  });

  // 4. 创建inventory数据的快速查找Map
  const inventoryMap = new Map(inventoryItems.map((item) => [item.id, item]));

  // 5. 手动聚合数据：将完整的inventory信息附加到每个orderItem上
  const enrichedOrders = ordersWithItems.map((order) => ({
    ...order,
    orderItem: order.orderItem.map((item) => ({
      ...item,
      inventoryItem: inventoryMap.get(item.inventory_item_id)!,
    })),
  }));

  return enrichedOrders;
}

export async function cancelExpiredOrders(dbCtx: Prisma.TransactionClient | PrismaClient) {
  // This single CTE query performs both actions atomically.
  // 1. `cancelled_orders` CTE finds and updates expired orders, returning their IDs.
  // 2. `released_items` CTE uses the IDs from the first CTE to find and release the associated inventory items.
  // 3. The final SELECT aggregates the counts from both CTEs.
  const query = Prisma.sql`
    WITH cancelled_orders AS (
      UPDATE "Order"
      SET status = 'CANCELLED', cancelled_at = NOW()
      WHERE id IN (
        SELECT id FROM "Order"
        WHERE status = 'PENDING_PAYMENT' AND "paymentExpiresAt" < NOW()
        ORDER BY "paymentExpiresAt" ASC
        LIMIT 1000
        FOR UPDATE SKIP LOCKED
      )
      RETURNING id
    ),
    released_items AS (
      UPDATE "inventoryitem" i
      SET status = 'in_stock', updated_at = NOW()
      FROM inventory_reservation ir
      WHERE ir.inventory_item_id = i.id
        AND ir.order_id IN (SELECT id FROM cancelled_orders)
      RETURNING i.id
    ),
    deleted_reservations AS (
      DELETE FROM inventory_reservation ir
      USING cancelled_orders co
      WHERE ir.order_id = co.id
      RETURNING ir.inventory_item_id
    )
    SELECT
      (SELECT COUNT(*) FROM cancelled_orders) as "cancelledCount",
      (SELECT COUNT(*) FROM released_items) as "releasedCount";
  `;

  const result = await (dbCtx as PrismaClient).$queryRaw<
    { cancelledCount: bigint; releasedCount: bigint }[]
  >(query);

  const cancelledCount = Number(result[0]?.cancelledCount || 0);
  const releasedCount = Number(result[0]?.releasedCount || 0);

  if (cancelledCount > 0) {
    console.log(
      `Atomically cancelled ${cancelledCount} orders and released ${releasedCount} items back to stock.`
    );
    metrics.ordersCancelled.inc(cancelledCount);
  }

  // The function signature remains the same, returning only the cancelled order count.
  return { cancelledCount };
}

export async function getOrderById(
  dbCtx: PrismaClient | Prisma.TransactionClient,
  orderId: number,
  userId: number,
) {
  // Get user role for authorization
  const userWithRole = await dbCtx.user.findUnique({
    where: { id: userId },
    select: { role: true },
  });
  if (!userWithRole) {
    throw new ApiError(403, "User not found", "USER_NOT_FOUND");
  }

  const selectFields = {
    id: true,
    user_id: true,
    status: true,
    total_amount: true,
    pickup_code: true,
    paymentExpiresAt: true,
    paid_at: true,
    cancelled_at: true,
    createdAt: true,
    orderItem: {
      select: {
        id: true,
        order_id: true,
        inventory_item_id: true,
        inventoryItem: {
          select: {
            id: true,
            condition: true,
            selling_price: true,
            bookSku: {
              select: {
                id: true,
                edition: true,
                cover_image_url: true,
                bookMaster: {
                  select: {
                    id: true,
                    isbn13: true,
                    title: true,
                    author: true,
                    publisher: true,
                    original_price: true,
                  },
                },
              },
            },
          },
        },
      },
    },
  };

  let order;

  if (userWithRole.role === "STAFF") {
    // STAFF can access any order
    order = await dbCtx.order.findUnique({
      where: { id: orderId },
      select: selectFields,
    });
  } else {
    // USER can only access their own orders - use findFirst with compound conditions
    order = await dbCtx.order.findFirst({
      where: {
        id: orderId,
        user_id: userId,
      },
      select: selectFields,
    });
  }

  if (!order) {
    throw new ApiError(404, "Order not found", "ORDER_NOT_FOUND");
  }

  return order;
}

async function updateOrderStatusImpl(
  dbCtx: Prisma.TransactionClient,
  orderId: number,
  newStatus: "COMPLETED" | "CANCELLED",
  user: { userId: number; role: string },
) {
  // Only STAFF can update order status
  if (user.role !== "STAFF") {
    throw new ApiError(
      403,
      "只有工作人员可以更新订单状态",
      "INSUFFICIENT_PERMISSIONS",
    );
  }

  // Get current order with items
  const currentOrder = await dbCtx.order.findUnique({
    where: { id: orderId },
    include: {
      orderItem: {
        include: {
          inventoryItem: true,
        },
      },
    },
  });

  if (!currentOrder) {
    throw new ApiError(404, "订单不存在", "ORDER_NOT_FOUND");
  }

  // Check if status transition is valid
  const validTransitions: Record<string, string[]> = {
    PENDING_PAYMENT: ["CANCELLED"],
    PENDING_PICKUP: ["COMPLETED", "CANCELLED"],
    COMPLETED: [],
    CANCELLED: [],
  };

  const allowedTransitions = validTransitions[currentOrder.status];
  if (!allowedTransitions?.includes(newStatus)) {
    throw new ApiError(
      400,
      `无法将订单从 ${currentOrder.status} 更新为 ${newStatus}`,
      "INVALID_STATUS_TRANSITION",
    );
  }

  // Update order status
  const updatedOrder = await dbCtx.order.update({
    where: { id: orderId },
    data: {
      status: newStatus,
      ...(newStatus === "COMPLETED" && { completed_at: new Date() }),
      ...(newStatus === "CANCELLED" && { cancelled_at: new Date() }),
    },
  });

  // Update inventory items based on new status
  if (newStatus === "COMPLETED") {
    // Mark all items as sold and clear reservation pointer
    await dbCtx.inventoryItem.updateMany({
      where: {
        id: {
          in: currentOrder.orderItem.map((item) => item.inventory_item_id),
        },
      },
      data: {
        status: INVENTORY_STATUS.SOLD,
      },
    });
    metrics.ordersCompleted.inc();
  } else if (newStatus === "CANCELLED") {
    // Release inventory back to stock
    await dbCtx.inventoryItem.updateMany({
      where: {
        id: {
          in: currentOrder.orderItem.map((item) => item.inventory_item_id),
        },
      },
      data: {
        status: INVENTORY_STATUS.IN_STOCK,
      },
    });

    // If cancelling a paid order, mark payment for refund
    if (currentOrder.status === "PENDING_PICKUP") {
      await dbCtx.paymentRecord.updateMany({
        where: { order_id: orderId, status: 'SUCCESS' },
        data: { status: 'REFUND_REQUIRED' }
      });
    }

    metrics.ordersCancelled.inc();
  }

  return updatedOrder;
}

export async function updateOrderStatus(
  dbCtx: PrismaClient | Prisma.TransactionClient,
  orderId: number,
  newStatus: "COMPLETED" | "CANCELLED",
  user: { userId: number; role: string },
) {
  if ("$connect" in dbCtx) {
    return (dbCtx as PrismaClient).$transaction((tx) => updateOrderStatusImpl(tx, orderId, newStatus, user));
  }

  return updateOrderStatusImpl(dbCtx as Prisma.TransactionClient, orderId, newStatus, user);
}


================================================================================
### FILE: bookworm-backend\src\services\refundService.ts
================================================================================

import { PrismaClient, Prisma } from "@prisma/client";
import { WechatPayAdapter } from "../adapters/wechatPayAdapter";
import * as crypto from "crypto";
import { BUSINESS_LIMITS } from "../constants";

export async function processPendingRefunds(
  dbCtx: PrismaClient, // This job should use the global client
  wechatPayAdapter: WechatPayAdapter
) {
  const thirtyMinutesAgo = new Date(Date.now() - 30 * 60 * 1000);

  const recordsToProcess = await dbCtx.paymentRecord.findMany({
    where: {
      refund_attempts: { lt: BUSINESS_LIMITS.MAX_REFUND_ATTEMPTS },
      OR: [
        { status: 'REFUND_REQUIRED' },
        {
          status: 'REFUND_PROCESSING',
          updatedAt: { lt: thirtyMinutesAgo },
        },
      ],
    },
    take: BUSINESS_LIMITS.REFUND_BATCH_SIZE,
  });

  if (recordsToProcess.length === 0) {
    return { processedCount: 0, successCount: 0, failureCount: 0 };
  }

  let successCount = 0;
  let failureCount = 0;
  const failures: { id: number; outTradeNo: string; reason: string }[] = [];

  type LockedPaymentRecord = {
    id: number;
    out_trade_no: string;
    amount_total: number;
    refund_attempts: number;
  };

  const lockedRecords: LockedPaymentRecord[] = [];

  for (const record of recordsToProcess) {
    const locked = await dbCtx.paymentRecord.updateMany({
      where: {
        id: record.id,
        status: record.status,
        updatedAt: record.updatedAt,
      },
      data: {
        status: "REFUND_PROCESSING",
        refund_attempts: { increment: 1 },
      },
    });

    if (locked.count === 0) {
      console.log(`Refund record ${record.id} changed state before locking. Skipping.`);
      continue;
    }

    const refreshedRecord = await dbCtx.paymentRecord.findUnique({
      where: { id: record.id },
      select: {
        id: true,
        out_trade_no: true,
        amount_total: true,
        refund_attempts: true,
      },
    });

    if (!refreshedRecord) {
      console.warn(`Refund record ${record.id} missing after lock acquisition. Skipping.`);
      continue;
    }

    lockedRecords.push({
      id: refreshedRecord.id,
      out_trade_no: refreshedRecord.out_trade_no,
      amount_total: refreshedRecord.amount_total,
      refund_attempts: refreshedRecord.refund_attempts,
    });
  }

  for (const lockedRecord of lockedRecords) {
    try {
      const refundIdHash = crypto
        .createHash('md5')
        .update(`${lockedRecord.out_trade_no}_${lockedRecord.id}`)
        .digest('hex')
        .slice(0, 8);
      const out_refund_no = `RF_${lockedRecord.out_trade_no}_${refundIdHash}`;

      await wechatPayAdapter.createRefund({
        out_trade_no: lockedRecord.out_trade_no,
        out_refund_no,
        amount: {
          refund: lockedRecord.amount_total,
          total: lockedRecord.amount_total,
          currency: 'CNY',
        },
        reason: '订单取消后支付成功',
      });

      await dbCtx.paymentRecord.update({
        where: { id: lockedRecord.id },
        data: {
          status: 'REFUNDED',
          refunded_at: new Date(),
          refund_id: out_refund_no,
        },
      });
      successCount++;
    } catch (error) {
      const outTradeNo = lockedRecord.out_trade_no;
      console.error(`Failed to process refund for out_trade_no: ${outTradeNo}`, error);
      failureCount++;
      const failureReason = error instanceof Error ? error.message : 'Unknown refund failure';
      failures.push({ id: lockedRecord.id, outTradeNo, reason: failureReason });

      const attempts = lockedRecord.refund_attempts;
      const reachedLimit = attempts >= BUSINESS_LIMITS.MAX_REFUND_ATTEMPTS;
      try {
        await dbCtx.paymentRecord.update({
          where: { id: lockedRecord.id },
          data: {
            status: reachedLimit ? 'FAILED' : 'REFUND_REQUIRED',
          },
        });
        if (reachedLimit) {
          console.error(
            `Refund permanently failed after ${BUSINESS_LIMITS.MAX_REFUND_ATTEMPTS} attempts for out_trade_no: ${outTradeNo}`,
          );
        }
      } catch (updateError) {
        console.error(
          `Failed to update status after refund failure for out_trade_no: ${outTradeNo}`,
          updateError,
        );
        throw updateError;
      }
    }
  }

  return {
    processedCount: recordsToProcess.length,
    successCount,
    failureCount,
    failures,
  };
}

export async function markPaymentForRefund(
  dbCtx: PrismaClient | Prisma.TransactionClient,
  outTradeNo: string,
): Promise<void> {
  const updated = await dbCtx.paymentRecord.updateMany({
    where: {
      out_trade_no: outTradeNo,
      status: 'SUCCESS', // Only refund payments that are currently marked as SUCCESS
    },
    data: {
      status: 'REFUND_REQUIRED',
    },
  });

  if (updated.count === 0) {
    console.warn(`No successful payment record found for out_trade_no: ${outTradeNo} - it may have already been refunded or is not in SUCCESS state`);
    // Don't throw error - this is expected behavior for idempotent refund requests
  }
}


================================================================================
### FILE: bookworm-backend\src\tests\database-integration-setup.ts
================================================================================

// src/tests/database-integration-setup.ts
// Setup for tests that need real database connections (like order expiration tests)
import "dotenv/config";
import { beforeAll, afterAll, beforeEach, afterEach } from "vitest";
import { PrismaClient } from "@prisma/client";
import { FastifyInstance } from "fastify";
import { buildApp } from "../index";
import * as dotenv from "dotenv";

// Load test environment variables
dotenv.config({ path: ".env.test" });

let prisma: PrismaClient;

beforeAll(async () => {
  console.log("Setting up database integration test environment...");

  // Use SQLite in-memory database for testing if PostgreSQL test DB is not available
  const testDatabaseUrl =
    process.env.DATABASE_URL ||
    "file:./test.db?connection_limit=1&pool_timeout=20";

  // Create a fresh Prisma client for testing
  prisma = new PrismaClient({
    datasources: {
      db: {
        url: testDatabaseUrl,
      },
    },
  });

  // Connect to test database
  await prisma.$connect();
  console.log(
    `Connected to test database: ${testDatabaseUrl.includes("file:") ? "SQLite in-memory" : "PostgreSQL"}`,
  );

  // Run database migrations for SQLite if needed
  if (testDatabaseUrl.includes("file:")) {
    console.log(
      "Using SQLite for testing - schema will be auto-created by Prisma",
    );
  }

  // Basic connectivity test
  try {
    await prisma.$executeRaw`SELECT 1`;
  } catch (error) {
    console.error("Database connection failed:", error);
    throw new Error("Test database is not accessible");
  }
});

afterAll(async () => {
  console.log("Cleaning up database integration test environment...");

  if (prisma) {
    await prisma.$disconnect();
  }
});

// Export helper functions for use in individual tests
export async function setupTestEnv() {
  // Clean all test data at the start of each test
  await cleanupTestData();
}

export async function cleanupTestEnv() {
  // Clean all test data at the end of each test
  await cleanupTestData();
}

async function cleanupTestData() {
  if (!prisma) return;

  try {
    // Use TRUNCATE to efficiently delete all data from tables and reset sequences,
    // respecting foreign key dependencies via CASCADE.
    await prisma.$executeRawUnsafe(`
      TRUNCATE TABLE
        "User",
        "bookMaster",
        "bookSku",
        "inventoryItem",
        "Order",
        "orderitem",
        "Content",
        "PaymentRecord"
      RESTART IDENTITY CASCADE;
    `);
  } catch (error) {
    console.warn("Cleanup error (may be expected):", error);
  }
}

export async function createTestUser(
  role: "USER" | "STAFF" = "USER",
): Promise<{ userId: number; token: string }> {
  const { createSigner } = await import("fast-jwt");
  const config = await import("../config").then((m) => m.default);

  const openid = `test-${role.toLowerCase()}-${Date.now()}-${Math.random()}`;

  const user = await prisma.user.create({
    data: {
      openid,
      nickname: `Test ${role} User`,
      role,
    },
  });

  // Create JWT token
  const signer = createSigner({
    key: config.JWT_SECRET,
    expiresIn: "1h",
  });

  const userPayload = {
    userId: user.id,
    openid,
    role: user.role // 包含role字段以支持新的JWT验证逻辑
  };
  const token = await signer(userPayload);

  return { userId: user.id, token };
}

export async function createTestInventoryItems(
  count: number,
): Promise<number[]> {
  // Create a test book master with unique ISBN using timestamp + random
  const uniqueIsbn =
    `978${Date.now()}${Math.floor(Math.random() * 1000)}`.slice(0, 13);
  const bookMaster = await prisma.bookMaster.create({
    data: {
      isbn13: uniqueIsbn,
      title: "Test Book",
      author: "Test Author",
      publisher: "Test Publisher",
      original_price: 100.0,
    },
  });

  // Create a test book SKU
  const bookSku = await prisma.bookSku.create({
    data: {
      master_id: bookMaster.id,
      edition: "1st Edition",
      cover_image_url: "https://example.com/cover.jpg",
    },
  });

  // Create multiple inventory items
  const inventoryItems = [];
  for (let i = 0; i < count; i++) {
    const item = await prisma.inventoryItem.create({
      data: {
        sku_id: bookSku.id,
        condition: "GOOD",
        cost: 60.0,
        selling_price: 80.0,
        status: "in_stock",
      },
    });
    inventoryItems.push(item.id);
  }

  return inventoryItems;
}

export function setupIsolatedTestEnvironment() {
  let app: FastifyInstance;

  // This will run before all tests in a file that uses this setup.
  beforeAll(async () => {
    // 1. Build a fresh, new Fastify app instance.
    app = await buildApp();
    await app.ready(); // Ensure all plugins are loaded
  });

  // This will run after all tests in the file.
  afterAll(async () => {
    // 2. Close the app instance to release resources.
    await app.close();
  });

  // This will run after each individual test.
  afterEach(async () => {
    // 3. Clean the database to ensure the next test starts with a clean slate.
    await cleanupTestEnv(); // Assuming cleanupTestEnv is your robust cleanup function
  });

  // Return the app instance so tests can use it.
  return {
    getApp: () => app,
  };
}


================================================================================
### FILE: bookworm-backend\src\tests\globalSetup.ts
================================================================================

import { PostgreSqlContainer, type StartedPostgreSqlContainer } from '@testcontainers/postgresql';
import { exec } from 'node:child_process';
import { promisify } from 'node:util';
import path from 'path';
import { PrismaClient } from '@prisma/client';

const execAsync = promisify(exec);

const prismaBinary = path.join(__dirname, '..', '..', 'node_modules', '.bin', 'prisma');

// This object will hold a mapping from worker ID to its dedicated container instance.
const containers: Record<number, StartedPostgreSqlContainer> = {};
const prismaClients: Record<number, PrismaClient> = {};

declare global {
  // eslint-disable-next-line no-var
  var __BOOKWORM_TRUNCATE__: ((workerId?: number) => Promise<void>) | undefined;
}

export async function setup(config: any) {
  const workers = config.workers || 1; // Get the number of parallel workers, default to 1

  for (let i = 1; i <= workers; i++) {
    console.log(`[Worker ${i}] Starting a dedicated PostgreSQL container...`);
    const container = await new PostgreSqlContainer('postgres:15').start();
    containers[i] = container;

    const databaseUrl = container.getConnectionUri();

    console.log(`[Worker ${i}] Container started. Applying migrations...`);
    await execAsync(`${prismaBinary} migrate deploy`, {
      env: { ...process.env, DATABASE_URL: databaseUrl },
    });
    console.log(`[Worker ${i}] Migrations applied.`);

    // Store a Prisma Client instance for this worker
    prismaClients[i] = new PrismaClient({
      datasources: {
        db: {
          url: databaseUrl,
        },
      },
    });

    await truncateAllTables(prismaClients[i]);
  }

  // Pass the container details to the test environment
  process.env.TEST_CONTAINERS = JSON.stringify(
    Object.fromEntries(
      Object.entries(containers).map(([workerId, container]) => [
        workerId,
        container.getConnectionUri(),
      ])
    )
  );

  globalThis.__BOOKWORM_TRUNCATE__ = async (workerId?: number) => {
    const resolvedWorkerId = workerId ?? parseInt(process.env.VITEST_WORKER_ID || '1', 10);
    const client = prismaClients[resolvedWorkerId] ?? getPrismaClientForWorker();
    await truncateAllTables(client);
  };
}

export async function teardown() {
  console.log('Tearing down all test containers...');
  await Promise.all(Object.values(containers).map(container => container.stop()));
  console.log('All containers stopped.');
}

// Helper to get the Prisma Client for the current worker
export function getPrismaClientForWorker(): PrismaClient {
  const workerId = parseInt(process.env.VITEST_WORKER_ID || '1', 10);

  // Try to get the stored client first
  let client = prismaClients[workerId];

  // If not found, try to create a new client using the container URL from environment
  if (!client) {
    const testContainers = process.env.TEST_CONTAINERS;
    if (testContainers) {
      const containers = JSON.parse(testContainers);
      const databaseUrl = containers[workerId] || containers['1']; // Fallback to worker 1 if current worker not found

      if (databaseUrl) {
        console.log(`Creating new Prisma client for worker ${workerId} with URL: ${databaseUrl.substring(0, 30)}...`);
        client = new PrismaClient({
          datasources: {
            db: {
              url: databaseUrl,
            },
          },
        });

        // Store it for future use
        prismaClients[workerId] = client;
      }
    }
  }

  if (!client) {
    throw new Error(`No Prisma client available for worker ${workerId}. Available workers: ${Object.keys(prismaClients).join(', ')}, TEST_CONTAINERS: ${process.env.TEST_CONTAINERS}`);
  }
  return client;
}

async function truncateAllTables(prisma: PrismaClient) {
  await prisma.$executeRawUnsafe(`
    TRUNCATE TABLE
      "PaymentRecord",
      "orderitem",
      "inventory_reservation",
      "inventoryitem",
      "pending_payment_order",
      "Order",
      "booksku",
      "bookmaster",
      "Content",
      "User"
    RESTART IDENTITY CASCADE;
  `);
}

// Helper functions that use the worker's Prisma client
export async function createTestUser(
  role: "USER" | "STAFF" = "USER",
): Promise<{ userId: number; token: string }> {
  const prisma = getPrismaClientForWorker();
  const { createSigner } = await import("fast-jwt");
  const config = await import("../config").then((m) => m.default);

  const openid = `test-${role.toLowerCase()}-${Date.now()}-${Math.random()}`;

  const user = await prisma.user.create({
    data: {
      openid,
      nickname: `Test ${role} User`,
      role,
    },
  });

  // Create JWT token
  const signer = createSigner({
    key: config.JWT_SECRET,
    expiresIn: "1h",
  });

  const userPayload = {
    userId: user.id,
    openid,
    role: user.role // 包含role字段以支持新的JWT验证逻辑
  };
  const token = await signer(userPayload);

  return { userId: user.id, token };
}

let testBookCounter = 0;

export async function createTestInventoryItems(
  count: number,
): Promise<number[]> {
  const prisma = getPrismaClientForWorker();

  // Generate a truly unique ISBN using multiple entropy sources
  const workerId = parseInt(process.env.VITEST_WORKER_ID || '1', 10);
  const timestamp = Date.now();
  const randomNum = Math.floor(Math.random() * 100000);
  testBookCounter++;

  // Use upsert to handle potential conflicts gracefully
  const uniqueIsbn = `978${workerId}${testBookCounter}${randomNum}`.slice(0, 13).padEnd(13, '0');

  const bookMaster = await prisma.bookMaster.upsert({
    where: { isbn13: uniqueIsbn },
    update: {},
    create: {
      isbn13: uniqueIsbn,
      title: `Test Book ${timestamp}-${testBookCounter}`,
      author: "Test Author",
      publisher: "Test Publisher",
      original_price: 100.0,
    },
  });

  // Create a test book SKU
  const bookSku = await prisma.bookSku.create({
    data: {
      master_id: bookMaster.id,
      edition: "1st Edition",
      cover_image_url: "https://example.com/cover.jpg",
    },
  });

  // Create multiple inventory items
  const inventoryItems = [];
  for (let i = 0; i < count; i++) {
    const item = await prisma.inventoryItem.create({
      data: {
        sku_id: bookSku.id,
        condition: "GOOD",
        cost: 60.0,
        selling_price: 80.0,
        status: "in_stock",
      },
    });
    inventoryItems.push(item.id);
  }

  return inventoryItems;
}


================================================================================
### FILE: bookworm-backend\src\tests\integrationSetup.ts
================================================================================

import { beforeEach, afterEach } from "vitest";

declare global {
  // eslint-disable-next-line no-var
  var __BOOKWORM_TRUNCATE__: ((workerId?: number) => Promise<void>) | undefined;
}

async function resetDatabase() {
  if (typeof globalThis.__BOOKWORM_TRUNCATE__ === "function") {
    await globalThis.__BOOKWORM_TRUNCATE__();
  }
}

beforeEach(async () => {
  await resetDatabase();
});

afterEach(async () => {
  await resetDatabase();
});


================================================================================
### FILE: bookworm-backend\src\tests\setup.ts
================================================================================

// src/tests/setup.ts
import { vi } from "vitest";
import { PrismaClient } from "@prisma/client";

// Create a mock Prisma client
const prismaMock = {
  bookMaster: {
    upsert: vi.fn(),
    findUnique: vi.fn(),
    findMany: vi.fn(),
  },
  bookSku: {
    upsert: vi.fn(),
    findUnique: vi.fn(),
    findMany: vi.fn(),
  },
  inventoryItem: {
    create: vi.fn(),
    findMany: vi.fn(),
    findUnique: vi.fn(),
    update: vi.fn(),
    updateMany: vi.fn(),
    count: vi.fn(),
  },
  user: {
    upsert: vi.fn(),
    findUnique: vi.fn(),
    findUniqueOrThrow: vi.fn(),
  },
  order: {
    create: vi.fn(),
    findMany: vi.fn(),
    findUnique: vi.fn(),
    findUniqueOrThrow: vi.fn(),
    update: vi.fn(),
  },
  orderItem: {
    create: vi.fn(),
    createMany: vi.fn(),
    findMany: vi.fn(),
  },
  paymentRecord: {
    create: vi.fn(),
    upsert: vi.fn(),
    deleteMany: vi.fn(),
    findMany: vi.fn(),
  },
  $transaction: vi.fn(),
  $queryRawUnsafe: vi.fn(),
} as unknown as PrismaClient;

vi.mock("../db", () => ({
  __esModule: true,
  default: prismaMock,
}));

beforeEach(() => {
  vi.clearAllMocks();
  (prismaMock.$transaction as unknown as any).mockImplementation(async (fn: any) => fn(prismaMock));
});

export { prismaMock };


================================================================================
### FILE: bookworm-backend\src\tests\test-helpers\errorHelpers.ts
================================================================================

// src/tests/test-helpers/errorHelpers.ts
// Helper functions to create properly typed test errors without 'as any'

import { Prisma } from "@prisma/client";

/**
 * Create a Prisma unique constraint error for testing
 */
export function createPrismaUniqueConstraintError(
  target: string | string[] = [],
  message = "Unique constraint failed"
): Prisma.PrismaClientKnownRequestError {
  const error = new Prisma.PrismaClientKnownRequestError(
    message,
    {
      code: "P2002",
      clientVersion: "test",
      meta: { target: Array.isArray(target) ? target : [target] }
    }
  );
  return error;
}

/**
 * Create a Prisma serialization error for testing
 */
export function createPrismaSerializationError(
  message = "could not serialize access due to concurrent update"
): Prisma.PrismaClientKnownRequestError {
  const error = new Prisma.PrismaClientKnownRequestError(
    message,
    {
      code: "P2034",
      clientVersion: "test",
    }
  );
  return error;
}

/**
 * Create a pickup code constraint error for testing
 */
export function createPickupCodeConstraintError(): Prisma.PrismaClientKnownRequestError {
  return createPrismaUniqueConstraintError("pickup_code", "Unique constraint failed");
}


================================================================================
### FILE: bookworm-backend\src\tests\test-helpers\orderService.helper.ts
================================================================================

// src/tests/test-helpers/orderService.helper.ts
import { mockDeep } from "vitest-mock-extended";
import { PrismaClient, Prisma } from "@prisma/client";
import { vi } from "vitest";

/**
 * Sets up default mocks for successful createOrder operations
 * This eliminates repetitive mock setup across test cases
 */
export function setupDefaultCreateOrderMocks(
  prismaMock: ReturnType<typeof mockDeep<PrismaClient>>,
) {
  // Mock前置检查通过
  prismaMock.order.count.mockResolvedValue(0);

  // Add $connect method to make it recognizable as PrismaClient
  (prismaMock as any).$connect = vi.fn().mockResolvedValue(undefined);

  // Mock事务成功路径的默认行为
  prismaMock.$transaction.mockImplementation(async (callback) => {
    // Mock现有预留商品检查的两次查询
    // 第一次：检查重复项目（返回空，无冲突）
    prismaMock.order.findMany.mockResolvedValueOnce([]);
    // 第二次：检查总数限制（返回空，无已预留商品）
    prismaMock.order.findMany.mockResolvedValueOnce([]);

    // Mock库存更新成功
    prismaMock.inventoryItem.updateMany.mockResolvedValue({ count: 1 });

    // Mock订单项创建成功
    prismaMock.orderItem.createMany.mockResolvedValue({ count: 1 });

    return callback(prismaMock);
  });
}

/**
 * Creates mock inventory items with consistent structure
 */
export function createMockInventoryItems(
  items: Array<{ id: number; price: string; status?: string }>,
) {
  return items.map((item) => ({
    id: item.id,
    selling_price: new Prisma.Decimal(item.price),
    status: item.status || "in_stock",
  })) as any;
}

/**
 * Creates a mock order with consistent structure
 */
export function createMockOrder(overrides: {
  id?: number;
  user_id: number;
  total_amount: string;
  pickup_code?: string;
  status?: string;
}) {
  return {
    id: overrides.id || 1,
    user_id: overrides.user_id,
    total_amount: new Prisma.Decimal(overrides.total_amount),
    pickup_code: overrides.pickup_code || "ABCD1234",
    status: overrides.status || "PENDING_PAYMENT",
  } as any;
}


================================================================================
### FILE: bookworm-backend\src\tests\test-helpers\testServices.ts
================================================================================

import { PrismaClient, book_condition, Prisma } from "@prisma/client";

interface AddBookInput {
  isbn13: string;
  title: string;
  author?: string;
  edition?: string;
  condition: book_condition;
  cost: number;
  selling_price: number;
}

// Test version of addBookToInventory that accepts a Prisma client
export async function addBookToInventoryTest(prisma: PrismaClient, input: AddBookInput) {
  return prisma.$transaction(async (tx) => {
    // Step 1: Find or create the master book record (based on ISBN).
    const bookMaster = await tx.bookMaster.upsert({
      where: { isbn13: input.isbn13 },
      update: {
        title: input.title,
        author: input.author || null,
      },
      create: {
        isbn13: input.isbn13,
        title: input.title,
        author: input.author || null,
        publisher: null,
        
      },
    });

    // Step 2: Find or create the SKU (edition/format combination)
    const bookSku = await tx.bookSku.upsert({
      where: {
        master_id_edition: {
          master_id: bookMaster.id,
          edition: input.edition || "未知版本",
        },
      },
      update: {},
      create: {
        master_id: bookMaster.id,
        edition: input.edition || "未知版本",
      },
    });

    // Step 3: Create the inventory item
    const inventoryItem = await tx.inventoryItem.create({
      data: {
        sku_id: bookSku.id,
        condition: input.condition,
        cost: input.cost,
        selling_price: input.selling_price,
        status: "in_stock",
      },
      include: {
        bookSku: {
          include: {
            bookMaster: true,
          },
        },
      },
    });

    return inventoryItem;
  });
}

// Test version of createOrder that accepts a Prisma client
export async function createOrderTest(
  prisma: PrismaClient,
  userId: number,
  itemIds: number[]
) {
  return prisma.$transaction(
    async (tx) => {
      // Find and reserve inventory items
      const itemsToReserve = await tx.inventoryItem.findMany({
        where: {
          id: { in: itemIds },
          status: "in_stock",
        },
      });

      if (itemsToReserve.length !== itemIds.length) {
        throw new Error("部分书籍已不可用，请刷新后重试");
      }

      // Calculate total amount
      const totalAmount = itemsToReserve.reduce((sum, item) => sum + Number(item.selling_price), 0);

      // Create the order first
      const order = await tx.Order.create({
        data: {
          user_id: userId,
          status: "PENDING_PAYMENT",
          total_amount: totalAmount,
          pickup_code: Math.random().toString(36).substring(2, 16).toUpperCase(),
          paymentExpiresAt: new Date(Date.now() + 15 * 60 * 1000), // 15 minutes from now
          orderItem: {
            create: itemIds.map((itemId) => {
              const item = itemsToReserve.find(i => i.id === itemId)!;
              return {
                inventory_item_id: itemId,
                price: item.selling_price,
              };
            }),
          },
        },
        include: {
          orderItem: {
            include: {
              inventoryItem: {
                include: {
                  bookSku: {
                    include: {
                      bookMaster: true,
                    },
                  },
                },
              },
            },
          },
        },
      });

      // Now reserve the items with the order ID (satisfies the constraint)
      await tx.inventoryItem.updateMany({
        where: {
          id: { in: itemIds },
          status: "in_stock",
        },
        data: {
          status: "reserved",
          reserved_by_order_id: order.id,
        },
      });

      return order;
    },
    {
      isolationLevel: Prisma.TransactionIsolationLevel.Serializable,
    }
  );
}

// Test version of fulfillOrder that accepts a Prisma client
export async function fulfillOrderTest(
  prisma: PrismaClient,
  pickupCode: string
) {
  return prisma.$transaction(
    async (tx) => {
      // Find the order by pickup code
      const order = await tx.Order.findFirst({
        where: {
          pickup_code: pickupCode,
          status: "PENDING_PICKUP",
        },
        include: {
          orderItem: {
            include: {
              inventoryItem: true,
            },
          },
        },
      });

      if (!order) {
        throw new Error("订单不存在或状态错误");
      }

      // Mark inventory as sold and clear reservation
      const itemIds = order.orderItem.map((item) => item.inventory_item_id);
      await tx.inventoryItem.updateMany({
        where: { id: { in: itemIds } },
        data: {
          status: "sold",
          reserved_by_order_id: null,
        },
      });

      // Complete the order
      const completedOrder = await tx.Order.update({
        where: { id: order.id },
        data: {
          status: "COMPLETED",
          completed_at: new Date(),
        },
        include: {
          orderItem: {
            include: {
              inventoryItem: {
                include: {
                  bookSku: {
                    include: {
                      bookMaster: true,
                    },
                  },
                },
              },
            },
          },
        },
      });

      return completedOrder;
    },
    {
      isolationLevel: Prisma.TransactionIsolationLevel.Serializable,
    }
  );
}


================================================================================
### FILE: bookworm-backend\src\types\wechatpay.d.ts
================================================================================

// src/types/wechatpay.d.ts

// Since the 'wechatpay-node-v3' library doesn't export proper types,
// we define our own interface for the parts of the API we actually use.
// This is infinitely better than using 'any'.
export interface IWechatPayV3 {
  transactions_jsapi(params: any): Promise<any>;
  transactions_out_trade_no(params: { out_trade_no: string; mchid: string }): Promise<any>;
  verifySign(params: any): boolean;
  decipher_gcm(ciphertext: string, associated_data: string, nonce: string, apiv3Key: string): string;
  sign(message: string): string;
  // Add other methods here if you use them
}


================================================================================
### FILE: bookworm-backend\src\utils\dbLock.ts
================================================================================

// src/utils/dbLock.ts

import { Prisma, PrismaClient } from "@prisma/client";
import crypto from "crypto";

import { BUSINESS_LIMITS } from "../constants";

/**
 * Executes a task while holding a PostgreSQL advisory lock.
 * Ensures that only one instance of the application can run the task at the same time.
 *
 * IMPORTANT: Advisory locks are session-scoped. This function uses a transaction
 * to guarantee that all raw queries run on the same database connection.
 *
 * @param prisma The PrismaClient instance.
 * @param lockName A unique name for the lock, e.g., 'job:cancel_expired_orders'.
 * @param task The async function to execute if the lock is acquired.
 * @returns The result of the task if the lock was acquired, otherwise null.
 */
function deriveLockKeys(lockName: string): [number, number] {
  const digest = crypto.createHash("sha256").update(lockName).digest();
  const key1 = digest.readInt32BE(0);
  const key2 = digest.readInt32BE(4);
  return [key1, key2];
}

export async function withAdvisoryLock<T>(
  prisma: PrismaClient,
  lockName: string,
  task: () => Promise<T>,
): Promise<T | null> {
  return prisma.$transaction(
    async (tx) => {
      const [key1, key2] = deriveLockKeys(lockName);
      const result = await tx.$queryRaw<{ pg_try_advisory_lock: boolean }[]>(
        Prisma.sql`SELECT pg_try_advisory_lock(${key1}, ${key2})`,
      );

      const lockAcquired = result[0]?.pg_try_advisory_lock;

      if (!lockAcquired) {
        console.log(
          `[AdvisoryLock] Could not acquire lock for "${lockName}". Another instance is likely running.`,
        );
        return null;
      }

      console.log(
        `[AdvisoryLock] Lock acquired for "${lockName}". Running task.`,
      );
      try {
        return await task();
      } finally {
        await tx.$queryRaw(Prisma.sql`SELECT pg_advisory_unlock(${key1}, ${key2})`);
        console.log(`[AdvisoryLock] Lock released for "${lockName}".`);
      }
    },
    {
      timeout: BUSINESS_LIMITS.ADVISORY_LOCK_TIMEOUT_MS,
    },
  );
}


================================================================================
### FILE: bookworm-backend\src\utils\dbVerifier.ts
================================================================================

import { PrismaClient } from "@prisma/client";

interface CriticalConstraint {
  name: string;
  query: (db: PrismaClient) => Promise<boolean>;
  errorMessage: string;
}

// Define all critical constraints that cannot be expressed in schema.prisma
const CRITICAL_CONSTRAINTS: CriticalConstraint[] = [
  {
    name: "Pending payment guard table",
    query: async (db: PrismaClient) => {
      const result = await db.$queryRaw<[{ exists: boolean }]>`
        SELECT EXISTS (
          SELECT 1
          FROM information_schema.tables
          WHERE table_name = 'pending_payment_order'
        );
      `;
      return result[0]?.exists === true;
    },
    errorMessage: "Pending payment guard table missing. Run database migrations before starting the service.",
  },
  {
    name: "Unique constraint uniq_order_pending_per_user",
    query: async (db: PrismaClient) => {
      const result = await db.$queryRaw<[{ exists: boolean }]>`
        SELECT EXISTS (
          SELECT 1
          FROM pg_constraint
          WHERE conname = 'uniq_order_pending_per_user'
        );
      `;
      return result[0]?.exists === true;
    },
    errorMessage: "Unique constraint 'uniq_order_pending_per_user' is missing. Duplicate pending orders would slip through.",
  },
  {
    name: "Trigger order_sync_pending_payment_insert",
    query: async (db: PrismaClient) => {
      const result = await db.$queryRaw<[{ exists: boolean }]>`
        SELECT EXISTS (
          SELECT 1 FROM pg_trigger
          WHERE tgname = 'order_sync_pending_payment_insert'
            AND tgrelid = '"Order"'::regclass
        );
      `;
      return result[0]?.exists === true;
    },
    errorMessage: "Trigger 'order_sync_pending_payment_insert' missing. Pending guard table will drift.",
  },
  {
    name: "Trigger inventory_reservation_enforce_cap",
    query: async (db: PrismaClient) => {
      const result = await db.$queryRaw<[{ exists: boolean }]>`
        SELECT EXISTS (
          SELECT 1 FROM pg_trigger
          WHERE tgname = 'inventory_reservation_enforce_cap'
            AND tgrelid = 'inventory_reservation'::regclass
        );
      `;
      return result[0]?.exists === true;
    },
    errorMessage: "Trigger 'inventory_reservation_enforce_cap' missing. User reservation cap is unenforced.",
  },
  {
    name: "Constraint trigger inventoryitem_validate_reservation",
    query: async (db: PrismaClient) => {
      const result = await db.$queryRaw<[{ exists: boolean }]>`
        SELECT EXISTS (
          SELECT 1 FROM pg_trigger
          WHERE tgname = 'inventoryitem_validate_reservation'
            AND tgrelid = 'inventoryitem'::regclass
        );
      `;
      return result[0]?.exists === true;
    },
    errorMessage: "Constraint trigger 'inventoryitem_validate_reservation' missing. Inventory state consistency is not guarded.",
  },
];

/**
 * Verifies that all critical, manually-defined database constraints exist.
 * If a constraint is missing, it logs a fatal error and exits the process.
 * @param db The PrismaClient instance.
 */
export async function verifyDatabaseConstraints(db: PrismaClient): Promise<void> {
  console.log("Verifying critical database constraints...");
  let allOk = true;

  for (const constraint of CRITICAL_CONSTRAINTS) {
    const exists = await constraint.query(db);
    if (exists) {
      console.log(`  ✅ [OK] ${constraint.name}`);
    } else {
      console.error(`  ❌ [FATAL] ${constraint.name}: ${constraint.errorMessage}`);
      allOk = false;
    }
  }

  if (!allOk) {
    console.error("\nDatabase constraint verification failed. The application cannot start in an inconsistent state.");
    process.exit(1);
  }

  console.log("All critical database constraints verified successfully.");
}


================================================================================
### FILE: bookworm-backend\src\utils\retry.ts
================================================================================

import { BUSINESS_LIMITS } from "../constants";

/**
 * A simple utility to retry an async function with exponential backoff.
 * @param fn The async function to retry.
 * @param attempts The maximum number of attempts.
 * @param delay The initial delay in ms.
 * @returns The result of the async function if it succeeds.
 * @throws The error of the last attempt if all attempts fail.
 */
export async function retryAsync<T>(
  fn: () => Promise<T>,
  attempts: number = BUSINESS_LIMITS.DEFAULT_RETRY_ATTEMPTS,
  delay: number = BUSINESS_LIMITS.DEFAULT_RETRY_DELAY_MS,
): Promise<T> {
  for (let i = 0; i < attempts; i++) {
    try {
      return await fn();
    } catch (error) {
      if (i === attempts - 1) {
        // This was the last attempt, re-throw the error.
        throw error;
      }
      // Wait for an exponentially increasing amount of time.
      const backoffDelay = delay * Math.pow(2, i);
      console.log(
        `Attempt ${i + 1}/${attempts} failed. Retrying in ${backoffDelay}ms...`,
      );
      await new Promise((res) => setTimeout(res, backoffDelay));
    }
  }
  // This line should theoretically be unreachable.
  throw new Error("Retry logic failed unexpectedly.");
}


================================================================================
### FILE: bookworm-backend\src\utils\typeGuards.ts
================================================================================

// src/utils/typeGuards.ts
// Type guards for safe error handling without 'as any'

import { Prisma } from "@prisma/client";
import { ApiError } from "../errors";

/**
 * Type guard for Fastify HTTP errors with statusCode
 */
export interface FastifyHttpError {
  statusCode: number;
  code?: string;
  message?: string;
  validation?: any[];
}

export function isFastifyHttpError(error: unknown): error is FastifyHttpError {
  return (
    typeof error === 'object' &&
    error !== null &&
    typeof (error as any).statusCode === 'number'
  );
}

/**
 * Type guard for Fastify validation errors
 */
export interface FastifyValidationError extends FastifyHttpError {
  statusCode: 400;
  validation: any[];
}

export function isFastifyValidationError(error: unknown): error is FastifyValidationError {
  return (
    isFastifyHttpError(error) &&
    error.statusCode === 400 &&
    Array.isArray((error as any).validation)
  );
}

/**
 * Type guard for Prisma known request errors
 */
export function isPrismaKnownError(error: unknown): error is Prisma.PrismaClientKnownRequestError {
  return error instanceof Prisma.PrismaClientKnownRequestError;
}

/**
 * Type guard for Prisma serialization errors
 */
export function isPrismaSerializationError(error: unknown): boolean {
  return (
    isPrismaKnownError(error) &&
    (error.code === "P2034" || error.message?.includes("could not serialize"))
  );
}

/**
 * Type guard for Prisma unique constraint errors
 */
export function isPrismaUniqueConstraintError(error: unknown): error is Prisma.PrismaClientKnownRequestError & { code: "P2002" } {
  return isPrismaKnownError(error) && error.code === "P2002";
}

/**
 * Check if a Prisma unique constraint error is specifically for pickup_code
 */
export function isPickupCodeConstraintError(error: unknown): boolean {
  if (!isPrismaUniqueConstraintError(error)) return false;

  const meta = error.meta as { target?: string[] } | undefined;
  return meta?.target?.includes("pickup_code") === true;
}

/**
 * Type guard for API errors
 */
export function isApiError(error: unknown): error is ApiError {
  return error instanceof ApiError;
}

/**
 * Type guard for standard Error objects
 */
export function isError(error: unknown): error is Error {
  return error instanceof Error;
}

/**
 * Type guard for Axios errors
 */
export interface AxiosError {
  isAxiosError: true;
  response?: {
    status: number;
    data?: any;
  };
  message: string;
}

export function isAxiosError(error: unknown): error is AxiosError {
  return (
    typeof error === 'object' &&
    error !== null &&
    (error as any).isAxiosError === true &&
    typeof (error as any).message === 'string'
  );
}

/**
 * Safe error message extraction
 */
export function getErrorMessage(error: unknown): string {
  if (isError(error)) {
    return error.message;
  }
  if (typeof error === 'string') {
    return error;
  }
  if (typeof error === 'object' && error !== null && 'message' in error) {
    return String((error as any).message);
  }
  return 'Unknown error';
}


================================================================================
### FILE: bookworm-backend\tsconfig.json
================================================================================

{
  "compilerOptions": {
    "target": "es2020",
    "module": "commonjs",
    "rootDir": "./",
    "outDir": "./dist",
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true,
    "strict": true,

    // Production-ready options
    "sourceMap": false, // Do not generate source maps for production
    "skipLibCheck": true,
    "resolveJsonModule": true,
    "types": ["node", "vitest/globals"]
  },
  "ts-node": {
    "esm": false
  },
  "include": ["src/**/*.ts", "prisma/seed.ts", "src/jobs/cancelExpiredOrders.ts"],
  "exclude": ["node_modules", "**/*.spec.ts", "src/tests/**/*"],
  "typeRoots": ["node_modules/@types", "src/types"]
}


================================================================================
### FILE: docker-compose.monitoring.yml
================================================================================

# docker-compose.monitoring.yml
version: '3.8'

services:
  prometheus:
    image: prom/prometheus:v2.47.2
    container_name: bookworm_prometheus
    volumes:
      - ./bookworm-backend/prometheus.yml:/etc/prometheus/prometheus.yml
    ports:
      - "9090:9090"
    command:
      - '--config.file=/etc/prometheus/prometheus.yml'
    restart: unless-stopped

  grafana:
    image: grafana/grafana-oss:10.2.2
    container_name: bookworm_grafana
    ports:
      - "4000:3000" # 将Grafana的3000端口映射到宿主机的4000，避免和应用冲突
    restart: unless-stopped


================================================================================
### FILE: fix_transactions.py
================================================================================

#!/usr/bin/env python3
"""
Script to remove $transaction wrappers from service functions
since they now receive transaction clients directly from route handlers.
"""

import re

def fix_orderservice():
    with open('bookworm-backend/src/services/orderService.ts', 'r', encoding='utf-8') as f:
        content = f.read()

    # Remove transaction wrappers but preserve the function content
    # Pattern: return dbCtx.$transaction(async (tx) => {
    content = re.sub(r'return dbCtx\.\$transaction\(async \(tx\) => \{', '', content)

    # Pattern: dbCtx.$transaction(async (tx) => {
    content = re.sub(r'dbCtx\.\$transaction\(async \(tx\) => \{', '', content)

    # Remove orphaned closing brackets and parentheses at function ends
    # This is tricky, so we'll need to be careful

    with open('bookworm-backend/src/services/orderService.ts', 'w', encoding='utf-8') as f:
        f.write(content)

if __name__ == '__main__':
    fix_orderservice()
    print("Fixed orderService.ts transaction wrappers")


================================================================================
### FILE: miniprogram\app.js
================================================================================

// miniprogram/app.js
const auth = require('./utils/auth');
const tokenUtil = require('./utils/token');

App({
  onLaunch() {
    auth.login()
      .then(res => {
        console.log('Login successful', res);
        tokenUtil.setToken(res.token);
        tokenUtil.setUserId(res.userId);
        this.checkTermsAgreement();
      })
      .catch(err => {
        console.error('Login failed on launch', err);
      });
  },

  checkTermsAgreement() {
    const hasAgreed = wx.getStorageSync('hasAgreedToTerms');
    if (!hasAgreed) {
      wx.showModal({
        title: '服务协议与隐私政策',
        content: '欢迎使用！为了保障您的权益，请在使用前仔细阅读并同意我们的《用户服务协议》与《隐私政策》。您可以在"我的-设置"中随时查看。',
        confirmText: '同意',
        cancelText: '拒绝',
        success: (res) => {
          if (res.confirm) {
            wx.setStorageSync('hasAgreedToTerms', true);
          } else if (res.cancel) {
            // 用户拒绝，可以引导退出或提示无法使用
            wx.showToast({
              title: '您需要同意协议才能使用本服务',
              icon: 'none',
              duration: 3000
            });
            // 简单处理，可以让用户无法进行核心操作
          }
        }
      });
    }
  },

  // 增加一个全局方法，方便其他页面调用
  showTerms() {
    wx.showModal({
      title: '服务协议与隐私政策',
      content: '这里是完整的《用户服务协议》与《隐私政策》内容...（此处应从服务器获取或本地预置长文本）',
      showCancel: false,
      confirmText: '我已知晓',
    });
  }
});


================================================================================
### FILE: miniprogram\app.json
================================================================================

{
  "lazyCodeLoading": "requiredComponents",
  "pages": [
    "pages/market/index",
    "pages/orders/index",
    "pages/profile/index",
    "pages/book-detail/index",
    "pages/order-confirm/index",
    "pages/order-detail/index",
    "pages/webview/index",
    "pages/customer-service/index"
  ],
  "window": {
    "backgroundTextStyle": "light",
    "navigationBarBackgroundColor": "#2c5f2d",
    "navigationBarTitleText": "校园书",
    "navigationBarTextStyle": "white"
  },
  "tabBar": {
    "color": "#6b6b6b",
    "selectedColor": "#2c5f2d",
    "backgroundColor": "#ffffff",
    "borderStyle": "white",
    "list": [
      {
        "pagePath": "pages/market/index",
        "text": "市场",
        "iconPath": "images/tabs/marketplace.png",
        "selectedIconPath": "images/tabs/marketplace-active.png"
      },
      {
        "pagePath": "pages/orders/index",
        "text": "订单",
        "iconPath": "images/tabs/orders.png",
        "selectedIconPath": "images/tabs/orders-active.png"
      },
      {
        "pagePath": "pages/profile/index",
        "text": "我的",
        "iconPath": "images/tabs/profile.png",
        "selectedIconPath": "images/tabs/profile-active.png"
      }
    ]
  },
  "style": "v2",
  "sitemapLocation": "sitemap.json"
}


================================================================================
### FILE: miniprogram\components\skeleton\skeleton.js
================================================================================

// components/skeleton/skeleton.js
Component({
  properties: {
    type: {
      type: String,
      value: 'grid' // 'grid', 'detail', 'list'
    },
    count: {
      type: Number,
      value: 4
    }
  }
});


================================================================================
### FILE: miniprogram\components\skeleton\skeleton.json
================================================================================

{
  "component": true,
  "componentPlaceholder": {
    "skeleton": "view"
  }
}


================================================================================
### FILE: miniprogram\config.js
================================================================================

// miniprogram/config.js
const config = {
  // 当前网络配置 - WLAN IP: 172.20.10.4
  // 如果使用模拟器开发，可改为 'http://localhost:3000/api'
  // 如果使用真机调试，使用当前的内网IP
  apiBaseUrl: 'http://172.20.10.4:3000/api'
};

module.exports = config;


================================================================================
### FILE: miniprogram\pages\book-detail\index.js
================================================================================

// pages/book-detail/index.js
const { request } = require('../../utils/api');
const ui = require('../../utils/ui');
const { safeCreateOrderAndPay } = require('../../utils/payment');
const { extractErrorMessage } = require('../../utils/error');

Page({
  data: {
    bookDetail: null,
    isLoading: true,
    error: null,
    isSubmitting: false,
  },

  onLoad(options) {
    this.hasShownOnce = false;
    if (options.id) {
      this.currentId = options.id;
      this.fetchBookDetails(options.id);
    } else {
      this.setData({ error: '无效的书籍ID', isLoading: false });
    }
  },

  onShow() {
    if (!this.currentId) {
      return;
    }
    if (this.hasShownOnce) {
      this.fetchBookDetails(this.currentId, { preserveData: true });
    } else {
      this.hasShownOnce = true;
    }
  },

  async fetchBookDetails(id, { preserveData = false } = {}) {
    if (!preserveData) {
      this.setData({ isLoading: true, error: null });
    } else {
      this.setData({ error: null });
    }
    try {
      const data = await request({
        url: `/inventory/item/${id}`,
        method: 'GET'
      });
      if (!data) {
        this.setData({ error: '书籍信息不存在' });
      } else {
        this.setData({ bookDetail: data });
      }
    } catch (error) {
      console.error('API request failed', error);
      const errorMsg = extractErrorMessage(error, '加载失败');
      this.setData({ error: errorMsg });
      ui.showError(errorMsg);
    } finally {
      this.setData({ isLoading: false });
    }
  },

  async handleBuyNow() {
    // 在函数开始时获取本地常量，确保数据访问的稳定性
    const { bookDetail } = this.data;
    if (this.data.isSubmitting || !bookDetail) return;

    // 显示购买确认对话框
    const confirmResult = await new Promise((resolve) => {
      wx.showModal({
        title: '确认购买',
        content: `确定要购买《${bookDetail.bookSku.bookMaster.title}》吗？\n支付金额：¥${bookDetail.selling_price}`,
        confirmText: '立即支付',
        cancelText: '再看看',
        success: (res) => resolve(res.confirm),
        fail: () => resolve(false)
      });
    });

    if (!confirmResult) {
      return; // 用户取消购买
    }

    this.setData({ isSubmitting: true });
    const result = await safeCreateOrderAndPay([bookDetail.id]);

    this.setData({ isSubmitting: false });

    if (result.success) {
      setTimeout(() => {
        wx.switchTab({ url: '/pages/orders/index' });
      }, 1500);
    }
  }
});


================================================================================
### FILE: miniprogram\pages\book-detail\index.json
================================================================================

{
  "navigationBarTitleText": "书籍详情",
  "usingComponents": {
    "skeleton": "../../components/skeleton/skeleton"
  }
}


================================================================================
### FILE: miniprogram\pages\customer-service\index.js
================================================================================

Page({
  data: {
    customerServiceWechat: 'bookworm_service'
  },

  onLoad() {
    wx.setNavigationBarTitle({
      title: '联系客服与帮助'
    });
  },

  // 复制微信号
  copyWechatId() {
    wx.setClipboardData({
      data: this.data.customerServiceWechat,
      success: () => {
        wx.showToast({
          title: '已复制',
          icon: 'success',
          duration: 2000
        });
      },
      fail: () => {
        wx.showToast({
          title: '复制失败',
          icon: 'none',
          duration: 2000
        });
      }
    });
  }
});


================================================================================
### FILE: miniprogram\pages\customer-service\index.json
================================================================================

{
  "navigationBarTitleText": "客服与帮助"
}


================================================================================
### FILE: miniprogram\pages\market\index.js
================================================================================

// pages/market/index.js
const { request } = require('../../utils/api');
const ui = require('../../utils/ui');
const { extractErrorMessage } = require('../../utils/error');

Page({
  data: {
    state: {
      status: 'loading', // 'loading', 'success', 'error'
      data: [],
      error: null
    },
    searchTerm: '',
    searchPerformed: false, // To show different empty state messages
    pageInfo: null // For pagination metadata
  },

  onLoad() {
    this.hasShownOnce = false;
  },

  onShow() {
    if (this.hasShownOnce) {
      this.fetchAvailableBooks({ preserveData: true });
    } else {
      this.hasShownOnce = true;
      this.fetchAvailableBooks();
    }
  },

  async fetchAvailableBooks({ preserveData = false } = {}) {
    if (!preserveData) {
      this.setData({
        state: {
          status: 'loading',
          data: [],
          error: null,
        },
      });
    } else {
      this.setData({ 'state.error': null });
    }
    let url = `/inventory/available`;
    if (this.data.searchTerm) {
      url += `?search=${encodeURIComponent(this.data.searchTerm)}`;
    }

    try {
      const data = await request({
        url: url,
        method: 'GET'
      });
      this.setData({
        state: {
          status: 'success',
          data: data.data,
          error: null
        },
        pageInfo: data.meta
      });
    } catch (error) {
      console.error('API request failed', error);
      const errorMsg = extractErrorMessage(error, '加载失败');
      this.setData({
        state: {
          status: 'error',
          data: [],
          error: errorMsg
        }
      });
      ui.showError(errorMsg);
    }
  },

  // NEW: Handle input change
  handleInput(e) {
    this.setData({
      searchTerm: e.detail.value
    });
  },

  // NEW: Handle search button tap or keyboard confirm
  handleSearch() {
    this.setData({ searchPerformed: true });
    this.fetchAvailableBooks();
  },

  // Pull down refresh
  async onPullDownRefresh() {
    await this.fetchAvailableBooks({ preserveData: true });
    wx.stopPullDownRefresh();
  }
});


================================================================================
### FILE: miniprogram\pages\market\index.json
================================================================================

{
  "navigationBarTitleText": "书市",
  "enablePullDownRefresh": true,
  "usingComponents": {
    "skeleton": "../../components/skeleton/skeleton"
  }
}


================================================================================
### FILE: miniprogram\pages\order-confirm\index.js
================================================================================

// pages/order-confirm/index.js
const api = require('../../utils/api');
const ui = require('../../utils/ui');
const { safeCreateOrderAndPay } = require('../../utils/payment');
const { extractErrorMessage } = require('../../utils/error');

Page({
  data: {
    book: null,
    isLoading: true,
    error: null,
    isSubmitting: false
  },
  
  onLoad(options) {
    this.hasShownOnce = false;
    if (options.id) {
      this.currentId = options.id;
      this.fetchBookDetails(options.id);
    } else {
      this.setData({ isLoading: false, error: '无效的商品ID' });
    }
  },

  onShow() {
    if (!this.currentId) {
      return;
    }
    if (this.hasShownOnce) {
      this.fetchBookDetails(this.currentId, { preserveData: true });
    } else {
      this.hasShownOnce = true;
    }
  },

  async fetchBookDetails(id, { preserveData = false } = {}) {
    if (!preserveData) {
      this.setData({ isLoading: true, error: null });
    } else {
      this.setData({ error: null });
    }

    try {
      const data = await api.request({
        url: `/inventory/item/${id}`,
        method: 'GET'
      });
      
      if (data.status === 'in_stock') {
        this.setData({ book: data });
      } else {
        this.setData({ error: '该书籍已售出或不可用' });
      }
    } catch (error) {
      const errorMsg = extractErrorMessage(error, '网络请求失败，无法获取书籍信息');
      this.setData({ error: errorMsg });
      ui.showError(errorMsg);
    } finally {
      this.setData({ isLoading: false });
    }
  },
  
  async handlePayment() {
    // 在函数开始时获取本地常量，确保数据访问的稳定性
    const { book } = this.data;
    if (this.data.isSubmitting || !book) return;

    // 显示支付确认对话框
    const confirmResult = await new Promise((resolve) => {
      wx.showModal({
        title: '确认支付',
        content: `确定要购买《${book.bookSku.bookMaster.title}》吗？\n支付金额：¥${book.selling_price}`,
        confirmText: '确认支付',
        cancelText: '再想想',
        success: (res) => resolve(res.confirm),
        fail: () => resolve(false)
      });
    });

    if (!confirmResult) {
      return; // 用户取消支付
    }

    this.setData({ isSubmitting: true });
    const result = await safeCreateOrderAndPay([book.id]);
    this.setData({ isSubmitting: false });

    if (result.success) {
      setTimeout(() => {
        wx.switchTab({ url: '/pages/orders/index' });
      }, 1500);
    }
  }
});


================================================================================
### FILE: miniprogram\pages\order-confirm\index.json
================================================================================

{
  "navigationBarTitleText": "确认订单"
}


================================================================================
### FILE: miniprogram\pages\order-detail\index.js
================================================================================

// pages/order-detail/index.js
const { request } = require('../../utils/api');
const { extractErrorMessage } = require('../../utils/error');

Page({
  data: {
    order: null,
    isLoading: true,
    error: null
  },

  onLoad(options) {
    this.hasShownOnce = false;
    if (options.id) {
      this.currentId = options.id;
      this.fetchOrderDetail(options.id);
    } else {
      this.setData({ 
        isLoading: false, 
        error: '无效的订单ID' 
      });
    }
  },

  onShow() {
    if (!this.currentId) {
      return;
    }
    if (this.hasShownOnce) {
      this.fetchOrderDetail(this.currentId, { preserveData: true });
    } else {
      this.hasShownOnce = true;
    }
  },

  async fetchOrderDetail(orderId, { preserveData = false } = {}) {
    if (!preserveData) {
      this.setData({ isLoading: true, error: null });
    } else {
      this.setData({ error: null });
    }

    try {
      const data = await request({
        url: `/orders/${orderId}`,
        method: 'GET'
      });
      this.setData({ 
        order: data,
        isLoading: false 
      });
    } catch (error) {
      const errorMsg = extractErrorMessage(error, '获取订单详情失败');
      this.setData({ 
        error: errorMsg,
        isLoading: false 
      });
    }
  },

  formatDate(dateString) {
    if (!dateString) return '';
    const date = new Date(dateString);
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const day = String(date.getDate()).padStart(2, '0');
    const hours = String(date.getHours()).padStart(2, '0');
    const minutes = String(date.getMinutes()).padStart(2, '0');
    return `${year}-${month}-${day} ${hours}:${minutes}`;
  },

  getStatusText(status) {
    const statusMap = {
      'PENDING_PAYMENT': '待支付',
      'PENDING_PICKUP': '待取货', 
      'COMPLETED': '已完成',
      'CANCELLED': '已取消'
    };
    return statusMap[status] || status;
  },

  getConditionText(condition) {
    const conditionMap = {
      'NEW': '全新',
      'GOOD': '良好',
      'ACCEPTABLE': '可用'
    };
    return conditionMap[condition] || condition;
  },

  onRefresh() {
    const pages = getCurrentPages();
    const currentPage = pages[pages.length - 1];
    const orderId = currentPage.options.id;
    if (orderId) {
      this.fetchOrderDetail(orderId, { preserveData: true });
    }
  },

  copyPickupCode(e) {
    const code = e.target.dataset.code || e.currentTarget.dataset.code;
    if (code) {
      wx.setClipboardData({
        data: code,
        success: () => {
          wx.showToast({
            title: '取货码已复制',
            icon: 'success'
          });
        }
      });
    }
  }
});


================================================================================
### FILE: miniprogram\pages\order-detail\index.json
================================================================================

{
  "navigationBarTitleText": "订单详情"
}


================================================================================
### FILE: miniprogram\pages\orders\index.js
================================================================================

// pages/orders/index.js
const auth = require('../../utils/auth');
const { request } = require('../../utils/api');
const { ORDER_STATUS } = require('../../utils/constants');
const tokenUtil = require('../../utils/token');
const ui = require('../../utils/ui');
const { extractErrorMessage } = require('../../utils/error');

Page({
  data: {
    state: {
      status: 'loading', // 'loading', 'success', 'error'
      data: [],
      error: null
    },
    statusMap: ORDER_STATUS,
    pageInfo: null // For pagination metadata
  },
  onShow() { this.fetchUserOrders(); },
  navigateToDetail(event) {
    const orderId = event.currentTarget.dataset.orderId;
    if (orderId) {
      wx.navigateTo({
        url: `/pages/order-detail/index?id=${orderId}`
      });
    }
  },
  async fetchUserOrders({ preserveData = false } = {}) {
    const userId = tokenUtil.getUserId();
    if (!userId) { return; }
    if (!preserveData) {
      this.setData({
        state: {
          status: 'loading',
          data: [],
          error: null,
        },
      });
    } else {
      this.setData({ 'state.error': null });
    }

    try {
      const data = await request({
        url: `/orders/user/${userId}`,
        method: 'GET'
      });
      this.setData({
        state: {
          status: 'success',
          data: data.data,
          error: null
        },
        pageInfo: data.meta
      });
    } catch (error) {
      const errorMsg = extractErrorMessage(error, '加载订单失败。');
      this.setData({
        state: {
          status: 'error',
          data: [],
          error: errorMsg
        }
      });
      ui.showError(errorMsg);
    }
  },

  // Pull down refresh
  async onPullDownRefresh() {
    await this.fetchUserOrders({ preserveData: true });
    wx.stopPullDownRefresh();
  }
});


================================================================================
### FILE: miniprogram\pages\orders\index.json
================================================================================

{
  "navigationBarTitleText": "我的订单",
  "enablePullDownRefresh": true
}


================================================================================
### FILE: miniprogram\pages\profile\index.js
================================================================================

// miniprogram/pages/profile/index.js
const app = getApp(); // 获取App实例

Page({
  data: {
    userInfo: { nickName: '微信用户' },
    serviceInfo: {
      wechatId: 'your_service_wechat_id',
      time: '工作日 9:00 - 18:00'
    }
  },
  copyWechatId() {
    wx.setClipboardData({
      data: this.data.serviceInfo.wechatId,
      success: () => { wx.showToast({ title: '已复制' }); }
    });
  },

  showTerms() {
    wx.navigateTo({
      url: '/pages/webview/index?slug=terms-of-service'
    });
  },

  showPrivacy() {
    wx.navigateTo({
      url: '/pages/webview/index?slug=privacy-policy'
    });
  },

  goToCustomerService() {
    wx.navigateTo({
      url: '/pages/customer-service/index'
    });
  },

  onShareAppMessage() {
    return {
      title: '超值的二手教材，快来看看吧！',
      path: '/pages/market/index',
    }
  }
});


================================================================================
### FILE: miniprogram\pages\profile\index.json
================================================================================

{
  "navigationBarTitleText": "我的"
}


================================================================================
### FILE: miniprogram\pages\webview\index.js
================================================================================

const { request } = require('../../utils/api');
const { extractErrorMessage } = require('../../utils/error');

Page({
  data: {
    content: null,
    isLoading: true,
    errorMsg: ''
  },

  onLoad(options) {
    const { slug } = options;
    this.hasShownOnce = false;
    this.currentSlug = slug || '';

    if (!slug) {
      this.setData({
        isLoading: false,
        errorMsg: '页面参数缺失'
      });
      return;
    }

    this.loadContent(slug);
  },

  onShow() {
    if (!this.currentSlug) {
      return;
    }

    if (this.hasShownOnce) {
      this.loadContent(this.currentSlug, { preserveData: true });
    } else {
      this.hasShownOnce = true;
    }
  },

  async loadContent(slug, { preserveData = false } = {}) {
    if (!preserveData) {
      this.setData({ isLoading: true, errorMsg: '' });
    } else {
      this.setData({ errorMsg: '' });
    }

    try {
      const data = await request({
        url: '/content/' + slug,
        method: 'GET'
      });
      const { title, body } = data;
      wx.setNavigationBarTitle({ title });
      this.setData({
        content: { title, body },
        isLoading: false
      });
    } catch (error) {
      console.error('Content load failed', error);
      this.setData({
        isLoading: false,
        errorMsg: extractErrorMessage(error, '内容加载失败')
      });
    }
  }
});


================================================================================
### FILE: miniprogram\pages\webview\index.json
================================================================================

{
  "navigationBarTitleText": "详情",
  "usingComponents": {
    "skeleton": "../../components/skeleton/skeleton"
  }
}


================================================================================
### FILE: miniprogram\utils\api.js
================================================================================

// miniprogram/utils/api.js - 统一的API请求工具
const config = require('../config');
const tokenUtil = require('./token');
const auth = require('./auth');

/**
 * 统一的API请求函数
 * @param {Object} options - 请求参数
 * @param {string} options.url - 请求地址（相对路径，会自动拼接baseURL）
 * @param {string} options.method - 请求方法（GET, POST等）
 * @param {Object} options.data - 请求数据
 * @param {Object} options.header - 请求头
 * @returns {Promise} - 返回Promise对象
 */
let ongoingLoginPromise = null;

const request = ({ url, method = 'GET', data = {}, retry = true }) => new Promise((resolve, reject) => {
  const token = tokenUtil.getToken();
  wx.request({
    url: `${config.apiBaseUrl}${url}`,
    method,
    data,
    timeout: 10000,
    header: {
      'Content-Type': 'application/json',
      Authorization: token ? `Bearer ${token}` : '',
    },
    success: async (res) => {
      if (res.statusCode >= 200 && res.statusCode < 300) {
        return resolve(res.data);
      }

      if (res.statusCode === 401 && retry) {
        tokenUtil.clearToken();
        try {
          if (!ongoingLoginPromise) {
            ongoingLoginPromise = auth
              .ensureLoggedIn()
              .finally(() => {
                ongoingLoginPromise = null;
              });
          }
          await ongoingLoginPromise;
          const retryResult = await request({ url, method, data, retry: false });
          return resolve(retryResult);
        } catch (loginError) {
          ongoingLoginPromise = null;
          return reject(loginError);
        }
      }

      const errorPayload = res.data && typeof res.data === 'object' ? res.data : { message: `Request failed with status ${res.statusCode}` };
      return reject(errorPayload);
    },
    fail: () => reject({ message: '网络请求失败', errorCode: 'NETWORK_ERROR' }),
  });
});

module.exports = {
  request
};


================================================================================
### FILE: miniprogram\utils\auth.js
================================================================================

const config = require('../config');
const tokenUtil = require('./token');
const ui = require('./ui');

function callWxLogin() {
  return new Promise((resolve, reject) => {
    wx.login({
      success: (res) => {
        if (res.code) resolve(res.code);
        else reject(new Error('wx.login 未返回 code'));
      },
      fail: reject,
    });
  });
}

function exchangeCodeForToken(code) {
  return new Promise((resolve, reject) => {
    wx.request({
      url: config.apiBaseUrl + '/auth/login',
      method: 'POST',
      data: { code },
      header: {
        'Content-Type': 'application/json',
      },
      success: (res) => {
        if (res.statusCode >= 200 && res.statusCode < 300 && res.data && res.data.token) {
          resolve(res.data);
        } else {
          reject(new Error((res.data && res.data.message) || '登录失败'));
        }
      },
      fail: () => reject(new Error('登录请求失败')),
    });
  });
}

async function login() {
  const code = await callWxLogin();
  const data = await exchangeCodeForToken(code);
  tokenUtil.setToken(data.token);
  if (data.userId) {
    tokenUtil.setUserId(data.userId);
  }
  return data;
}

async function ensureLoggedIn() {
  const token = tokenUtil.getToken();
  if (token) {
    return { token, userId: tokenUtil.getUserId() };
  }
  try {
    return await login();
  } catch (error) {
    ui.showError(error.message || '登录失败');
    throw error;
  }
}

module.exports = {
  login,
  ensureLoggedIn,
};


================================================================================
### FILE: miniprogram\utils\constants.js
================================================================================

// miniprogram/utils/constants.js
const ORDER_STATUS = {
  PENDING_PAYMENT: '待支付',
  PENDING_PICKUP: '待取货',
  COMPLETED: '已完成',
  CANCELLED: '已取消',
};

module.exports = {
  ORDER_STATUS,
};


================================================================================
### FILE: miniprogram\utils\error.js
================================================================================

function extractErrorMessage(error, fallback = '发生未知错误') {
  if (!error) {
    return fallback;
  }
  if (typeof error === 'string') {
    return error;
  }

  const message =
    error.message ||
    (error.data && error.data.message) ||
    error.error ||
    fallback;

  return typeof message === 'string' && message.trim() ? message : fallback;
}

module.exports = {
  extractErrorMessage,
};


================================================================================
### FILE: miniprogram\utils\payment.js
================================================================================

const { request } = require('./api');
const ui = require('./ui');
const { extractErrorMessage } = require('./error');

function requestPayment(params) {
  return new Promise((resolve, reject) => {
    wx.requestPayment({
      ...params,
      success: resolve,
      fail: reject,
    });
  });
}

async function createOrderAndPay(inventoryItemIds) {
  wx.showLoading({ title: '正在创建订单...' });
  const order = await request({
    url: '/orders/create',
    method: 'POST',
    data: { inventoryItemIds },
  });

  wx.showLoading({ title: '获取支付参数...' });
  const payParams = await request({
    url: '/orders/' + order.id + '/pay',
    method: 'POST',
  });

  wx.hideLoading();
  await requestPayment(payParams);
  return order;
}

async function safeCreateOrderAndPay(inventoryItemIds) {
  try {
    const order = await createOrderAndPay(inventoryItemIds);
    wx.showToast({ title: '支付成功', icon: 'success' });
    return { success: true, order };
  } catch (error) {
    wx.hideLoading();
    if (error && error.errMsg && error.errMsg.indexOf('cancel') !== -1) {
      wx.showToast({ title: '支付已取消', icon: 'none' });
      return { success: false, cancelled: true };
    }
    ui.showError(extractErrorMessage(error, '网络请求失败'));
    return { success: false, cancelled: false, error };
  }
}

module.exports = {
  createOrderAndPay,
  safeCreateOrderAndPay,
};


================================================================================
### FILE: miniprogram\utils\token.js
================================================================================

// miniprogram/utils/token.js
const TOKEN_KEY = 'authToken';
const USER_ID_KEY = 'userId';

const setToken = (token) => wx.setStorageSync(TOKEN_KEY, token);
const getToken = () => wx.getStorageSync(TOKEN_KEY);
const setUserId = (userId) => wx.setStorageSync(USER_ID_KEY, userId);
const getUserId = () => wx.getStorageSync(USER_ID_KEY);
const clearToken = () => {
  wx.removeStorageSync(TOKEN_KEY);
  wx.removeStorageSync(USER_ID_KEY);
};

module.exports = {
  setToken,
  getToken,
  setUserId,
  getUserId,
  clearToken,
};


================================================================================
### FILE: miniprogram\utils\ui.js
================================================================================

function showError(message = '请求失败，请稍后再试') {
  wx.showToast({
    title: message,
    icon: 'none',
    duration: 2000
  });
}

module.exports = {
  showError
};


================================================================================
### FILE: package-lock.json
================================================================================

{
  "name": "miniprogram-13",
  "lockfileVersion": 3,
  "requires": true,
  "packages": {
    "": {
      "dependencies": {
        "axios": "^1.11.0",
        "dotenv": "^17.2.2",
        "jsonwebtoken": "^9.0.2",
        "wechatpay-node-v3": "^2.2.1"
      },
      "devDependencies": {
        "@types/jsonwebtoken": "^9.0.10"
      }
    },
    "node_modules/@fidm/asn1": {
      "version": "1.0.4",
      "resolved": "https://registry.npmmirror.com/@fidm/asn1/-/asn1-1.0.4.tgz",
      "integrity": "sha512-esd1jyNvRb2HVaQGq2Gg8Z0kbQPXzV9Tq5Z14KNIov6KfFD6PTaRIO8UpcsYiTNzOqJpmyzWgVTrUwFV3UF4TQ==",
      "license": "MIT",
      "engines": {
        "node": ">= 8"
      }
    },
    "node_modules/@fidm/x509": {
      "version": "1.2.1",
      "resolved": "https://registry.npmmirror.com/@fidm/x509/-/x509-1.2.1.tgz",
      "integrity": "sha512-nwc2iesjyc9hkuzcrMCBXQRn653XuAUKorfWM8PZyJawiy1QzLj4vahwzaI25+pfpwOLvMzbJ0uKpWLDNmo16w==",
      "license": "MIT",
      "dependencies": {
        "@fidm/asn1": "^1.0.4",
        "tweetnacl": "^1.0.1"
      },
      "engines": {
        "node": ">= 8"
      }
    },
    "node_modules/@noble/hashes": {
      "version": "1.8.0",
      "resolved": "https://registry.npmmirror.com/@noble/hashes/-/hashes-1.8.0.tgz",
      "integrity": "sha512-jCs9ldd7NwzpgXDIf6P3+NrHh9/sD6CQdxHyjQI+h/6rDNo88ypBxxz45UDuZHz9r3tNz7N/VInSVoVdtXEI4A==",
      "license": "MIT",
      "engines": {
        "node": "^14.21.3 || >=16"
      },
      "funding": {
        "url": "https://paulmillr.com/funding/"
      }
    },
    "node_modules/@paralleldrive/cuid2": {
      "version": "2.2.2",
      "resolved": "https://registry.npmmirror.com/@paralleldrive/cuid2/-/cuid2-2.2.2.tgz",
      "integrity": "sha512-ZOBkgDwEdoYVlSeRbYYXs0S9MejQofiVYoTbKzy/6GQa39/q5tQU2IX46+shYnUkpEl3wc+J6wRlar7r2EK2xA==",
      "license": "MIT",
      "dependencies": {
        "@noble/hashes": "^1.1.5"
      }
    },
    "node_modules/@types/jsonwebtoken": {
      "version": "9.0.10",
      "resolved": "https://registry.npmmirror.com/@types/jsonwebtoken/-/jsonwebtoken-9.0.10.tgz",
      "integrity": "sha512-asx5hIG9Qmf/1oStypjanR7iKTv0gXQ1Ov/jfrX6kS/EO0OFni8orbmGCn0672NHR3kXHwpAwR+B368ZGN/2rA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@types/ms": "*",
        "@types/node": "*"
      }
    },
    "node_modules/@types/ms": {
      "version": "2.1.0",
      "resolved": "https://registry.npmmirror.com/@types/ms/-/ms-2.1.0.tgz",
      "integrity": "sha512-GsCCIZDE/p3i96vtEqx+7dBUGXrc7zeSK3wwPHIaRThS+9OhWIXRqzs4d6k1SVU8g91DrNRWxWUGhp5KXQb2VA==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@types/node": {
      "version": "24.3.1",
      "resolved": "https://registry.npmmirror.com/@types/node/-/node-24.3.1.tgz",
      "integrity": "sha512-3vXmQDXy+woz+gnrTvuvNrPzekOi+Ds0ReMxw0LzBiK3a+1k0kQn9f2NWk+lgD4rJehFUmYy2gMhJ2ZI+7YP9g==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "undici-types": "~7.10.0"
      }
    },
    "node_modules/asap": {
      "version": "2.0.6",
      "resolved": "https://registry.npmmirror.com/asap/-/asap-2.0.6.tgz",
      "integrity": "sha512-BSHWgDSAiKs50o2Re8ppvp3seVHXSRM44cdSsT9FfNEUUZLOGWVCsiWaRPWM1Znn+mqZ1OfVZ3z3DWEzSp7hRA==",
      "license": "MIT"
    },
    "node_modules/asynckit": {
      "version": "0.4.0",
      "resolved": "https://registry.npmmirror.com/asynckit/-/asynckit-0.4.0.tgz",
      "integrity": "sha512-Oei9OH4tRh0YqU3GxhX79dM/mwVgvbZJaSNaRk+bshkj0S5cfHcgYakreBjrHwatXKbz+IoIdYLxrKim2MjW0Q==",
      "license": "MIT"
    },
    "node_modules/axios": {
      "version": "1.11.0",
      "resolved": "https://registry.npmmirror.com/axios/-/axios-1.11.0.tgz",
      "integrity": "sha512-1Lx3WLFQWm3ooKDYZD1eXmoGO9fxYQjrycfHFC8P0sCfQVXyROp0p9PFWBehewBOdCwHc+f/b8I0fMto5eSfwA==",
      "license": "MIT",
      "dependencies": {
        "follow-redirects": "^1.15.6",
        "form-data": "^4.0.4",
        "proxy-from-env": "^1.1.0"
      }
    },
    "node_modules/buffer-equal-constant-time": {
      "version": "1.0.1",
      "resolved": "https://registry.npmmirror.com/buffer-equal-constant-time/-/buffer-equal-constant-time-1.0.1.tgz",
      "integrity": "sha512-zRpUiDwd/xk6ADqPMATG8vc9VPrkck7T07OIx0gnjmJAnHnTVXNQG3vfvWNuiZIkwu9KrKdA1iJKfsfTVxE6NA==",
      "license": "BSD-3-Clause"
    },
    "node_modules/call-bind-apply-helpers": {
      "version": "1.0.2",
      "resolved": "https://registry.npmmirror.com/call-bind-apply-helpers/-/call-bind-apply-helpers-1.0.2.tgz",
      "integrity": "sha512-Sp1ablJ0ivDkSzjcaJdxEunN5/XvksFJ2sMBFfq6x0ryhQV/2b/KwFe21cMpmHtPOSij8K99/wSfoEuTObmuMQ==",
      "license": "MIT",
      "dependencies": {
        "es-errors": "^1.3.0",
        "function-bind": "^1.1.2"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/call-bound": {
      "version": "1.0.4",
      "resolved": "https://registry.npmmirror.com/call-bound/-/call-bound-1.0.4.tgz",
      "integrity": "sha512-+ys997U96po4Kx/ABpBCqhA9EuxJaQWDQg7295H4hBphv3IZg0boBKuwYpt4YXp6MZ5AmZQnU/tyMTlRpaSejg==",
      "license": "MIT",
      "dependencies": {
        "call-bind-apply-helpers": "^1.0.2",
        "get-intrinsic": "^1.3.0"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/combined-stream": {
      "version": "1.0.8",
      "resolved": "https://registry.npmmirror.com/combined-stream/-/combined-stream-1.0.8.tgz",
      "integrity": "sha512-FQN4MRfuJeHf7cBbBMJFXhKSDq+2kAArBlmRBvcvFE5BB1HZKXtSFASDhdlz9zOYwxh8lDdnvmMOe/+5cdoEdg==",
      "license": "MIT",
      "dependencies": {
        "delayed-stream": "~1.0.0"
      },
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/component-emitter": {
      "version": "1.3.1",
      "resolved": "https://registry.npmmirror.com/component-emitter/-/component-emitter-1.3.1.tgz",
      "integrity": "sha512-T0+barUSQRTUQASh8bx02dl+DhF54GtIDY13Y3m9oWTklKbb3Wv974meRpeZ3lp1JpLVECWWNHC4vaG2XHXouQ==",
      "license": "MIT",
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/cookiejar": {
      "version": "2.1.4",
      "resolved": "https://registry.npmmirror.com/cookiejar/-/cookiejar-2.1.4.tgz",
      "integrity": "sha512-LDx6oHrK+PhzLKJU9j5S7/Y3jM/mUHvD/DeI1WQmJn652iPC5Y4TBzC9l+5OMOXlyTTA+SmVUPm0HQUwpD5Jqw==",
      "license": "MIT"
    },
    "node_modules/debug": {
      "version": "4.4.1",
      "resolved": "https://registry.npmmirror.com/debug/-/debug-4.4.1.tgz",
      "integrity": "sha512-KcKCqiftBJcZr++7ykoDIEwSa3XWowTfNPo92BYxjXiyYEVrUQh2aLyhxBCwww+heortUFxEJYcRzosstTEBYQ==",
      "license": "MIT",
      "dependencies": {
        "ms": "^2.1.3"
      },
      "engines": {
        "node": ">=6.0"
      },
      "peerDependenciesMeta": {
        "supports-color": {
          "optional": true
        }
      }
    },
    "node_modules/delayed-stream": {
      "version": "1.0.0",
      "resolved": "https://registry.npmmirror.com/delayed-stream/-/delayed-stream-1.0.0.tgz",
      "integrity": "sha512-ZySD7Nf91aLB0RxL4KGrKHBXl7Eds1DAmEdcoVawXnLD7SDhpNgtuII2aAkg7a7QS41jxPSZ17p4VdGnMHk3MQ==",
      "license": "MIT",
      "engines": {
        "node": ">=0.4.0"
      }
    },
    "node_modules/dezalgo": {
      "version": "1.0.4",
      "resolved": "https://registry.npmmirror.com/dezalgo/-/dezalgo-1.0.4.tgz",
      "integrity": "sha512-rXSP0bf+5n0Qonsb+SVVfNfIsimO4HEtmnIpPHY8Q1UCzKlQrDMfdobr8nJOOsRgWCyMRqeSBQzmWUMq7zvVig==",
      "license": "ISC",
      "dependencies": {
        "asap": "^2.0.0",
        "wrappy": "1"
      }
    },
    "node_modules/dotenv": {
      "version": "17.2.2",
      "resolved": "https://registry.npmmirror.com/dotenv/-/dotenv-17.2.2.tgz",
      "integrity": "sha512-Sf2LSQP+bOlhKWWyhFsn0UsfdK/kCWRv1iuA2gXAwt3dyNabr6QSj00I2V10pidqz69soatm9ZwZvpQMTIOd5Q==",
      "license": "BSD-2-Clause",
      "engines": {
        "node": ">=12"
      },
      "funding": {
        "url": "https://dotenvx.com"
      }
    },
    "node_modules/dunder-proto": {
      "version": "1.0.1",
      "resolved": "https://registry.npmmirror.com/dunder-proto/-/dunder-proto-1.0.1.tgz",
      "integrity": "sha512-KIN/nDJBQRcXw0MLVhZE9iQHmG68qAVIBg9CqmUYjmQIhgij9U5MFvrqkUL5FbtyyzZuOeOt0zdeRe4UY7ct+A==",
      "license": "MIT",
      "dependencies": {
        "call-bind-apply-helpers": "^1.0.1",
        "es-errors": "^1.3.0",
        "gopd": "^1.2.0"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/ecdsa-sig-formatter": {
      "version": "1.0.11",
      "resolved": "https://registry.npmmirror.com/ecdsa-sig-formatter/-/ecdsa-sig-formatter-1.0.11.tgz",
      "integrity": "sha512-nagl3RYrbNv6kQkeJIpt6NJZy8twLB/2vtz6yN9Z4vRKHN4/QZJIEbqohALSgwKdnksuY3k5Addp5lg8sVoVcQ==",
      "license": "Apache-2.0",
      "dependencies": {
        "safe-buffer": "^5.0.1"
      }
    },
    "node_modules/es-define-property": {
      "version": "1.0.1",
      "resolved": "https://registry.npmmirror.com/es-define-property/-/es-define-property-1.0.1.tgz",
      "integrity": "sha512-e3nRfgfUZ4rNGL232gUgX06QNyyez04KdjFrF+LTRoOXmrOgFKDg4BCdsjW8EnT69eqdYGmRpJwiPVYNrCaW3g==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/es-errors": {
      "version": "1.3.0",
      "resolved": "https://registry.npmmirror.com/es-errors/-/es-errors-1.3.0.tgz",
      "integrity": "sha512-Zf5H2Kxt2xjTvbJvP2ZWLEICxA6j+hAmMzIlypy4xcBg1vKVnx89Wy0GbS+kf5cwCVFFzdCFh2XSCFNULS6csw==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/es-object-atoms": {
      "version": "1.1.1",
      "resolved": "https://registry.npmmirror.com/es-object-atoms/-/es-object-atoms-1.1.1.tgz",
      "integrity": "sha512-FGgH2h8zKNim9ljj7dankFPcICIK9Cp5bm+c2gQSYePhpaG5+esrLODihIorn+Pe6FGJzWhXQotPv73jTaldXA==",
      "license": "MIT",
      "dependencies": {
        "es-errors": "^1.3.0"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/es-set-tostringtag": {
      "version": "2.1.0",
      "resolved": "https://registry.npmmirror.com/es-set-tostringtag/-/es-set-tostringtag-2.1.0.tgz",
      "integrity": "sha512-j6vWzfrGVfyXxge+O0x5sh6cvxAog0a/4Rdd2K36zCMV5eJ+/+tOAngRO8cODMNWbVRdVlmGZQL2YS3yR8bIUA==",
      "license": "MIT",
      "dependencies": {
        "es-errors": "^1.3.0",
        "get-intrinsic": "^1.2.6",
        "has-tostringtag": "^1.0.2",
        "hasown": "^2.0.2"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/fast-safe-stringify": {
      "version": "2.1.1",
      "resolved": "https://registry.npmmirror.com/fast-safe-stringify/-/fast-safe-stringify-2.1.1.tgz",
      "integrity": "sha512-W+KJc2dmILlPplD/H4K9l9LcAHAfPtP6BY84uVLXQ6Evcz9Lcg33Y2z1IVblT6xdY54PXYVHEv+0Wpq8Io6zkA==",
      "license": "MIT"
    },
    "node_modules/follow-redirects": {
      "version": "1.15.11",
      "resolved": "https://registry.npmmirror.com/follow-redirects/-/follow-redirects-1.15.11.tgz",
      "integrity": "sha512-deG2P0JfjrTxl50XGCDyfI97ZGVCxIpfKYmfyrQ54n5FO/0gfIES8C/Psl6kWVDolizcaaxZJnTS0QSMxvnsBQ==",
      "funding": [
        {
          "type": "individual",
          "url": "https://github.com/sponsors/RubenVerborgh"
        }
      ],
      "license": "MIT",
      "engines": {
        "node": ">=4.0"
      },
      "peerDependenciesMeta": {
        "debug": {
          "optional": true
        }
      }
    },
    "node_modules/form-data": {
      "version": "4.0.4",
      "resolved": "https://registry.npmmirror.com/form-data/-/form-data-4.0.4.tgz",
      "integrity": "sha512-KrGhL9Q4zjj0kiUt5OO4Mr/A/jlI2jDYs5eHBpYHPcBEVSiipAvn2Ko2HnPe20rmcuuvMHNdZFp+4IlGTMF0Ow==",
      "license": "MIT",
      "dependencies": {
        "asynckit": "^0.4.0",
        "combined-stream": "^1.0.8",
        "es-set-tostringtag": "^2.1.0",
        "hasown": "^2.0.2",
        "mime-types": "^2.1.12"
      },
      "engines": {
        "node": ">= 6"
      }
    },
    "node_modules/formidable": {
      "version": "2.1.5",
      "resolved": "https://registry.npmmirror.com/formidable/-/formidable-2.1.5.tgz",
      "integrity": "sha512-Oz5Hwvwak/DCaXVVUtPn4oLMLLy1CdclLKO1LFgU7XzDpVMUU5UjlSLpGMocyQNNk8F6IJW9M/YdooSn2MRI+Q==",
      "license": "MIT",
      "dependencies": {
        "@paralleldrive/cuid2": "^2.2.2",
        "dezalgo": "^1.0.4",
        "once": "^1.4.0",
        "qs": "^6.11.0"
      },
      "funding": {
        "url": "https://ko-fi.com/tunnckoCore/commissions"
      }
    },
    "node_modules/function-bind": {
      "version": "1.1.2",
      "resolved": "https://registry.npmmirror.com/function-bind/-/function-bind-1.1.2.tgz",
      "integrity": "sha512-7XHNxH7qX9xG5mIwxkhumTox/MIRNcOgDrxWsMt2pAr23WHp6MrRlN7FBSFpCpr+oVO0F744iUgR82nJMfG2SA==",
      "license": "MIT",
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/get-intrinsic": {
      "version": "1.3.0",
      "resolved": "https://registry.npmmirror.com/get-intrinsic/-/get-intrinsic-1.3.0.tgz",
      "integrity": "sha512-9fSjSaos/fRIVIp+xSJlE6lfwhES7LNtKaCBIamHsjr2na1BiABJPo0mOjjz8GJDURarmCPGqaiVg5mfjb98CQ==",
      "license": "MIT",
      "dependencies": {
        "call-bind-apply-helpers": "^1.0.2",
        "es-define-property": "^1.0.1",
        "es-errors": "^1.3.0",
        "es-object-atoms": "^1.1.1",
        "function-bind": "^1.1.2",
        "get-proto": "^1.0.1",
        "gopd": "^1.2.0",
        "has-symbols": "^1.1.0",
        "hasown": "^2.0.2",
        "math-intrinsics": "^1.1.0"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/get-proto": {
      "version": "1.0.1",
      "resolved": "https://registry.npmmirror.com/get-proto/-/get-proto-1.0.1.tgz",
      "integrity": "sha512-sTSfBjoXBp89JvIKIefqw7U2CCebsc74kiY6awiGogKtoSGbgjYE/G/+l9sF3MWFPNc9IcoOC4ODfKHfxFmp0g==",
      "license": "MIT",
      "dependencies": {
        "dunder-proto": "^1.0.1",
        "es-object-atoms": "^1.0.0"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/gopd": {
      "version": "1.2.0",
      "resolved": "https://registry.npmmirror.com/gopd/-/gopd-1.2.0.tgz",
      "integrity": "sha512-ZUKRh6/kUFoAiTAtTYPZJ3hw9wNxx+BIBOijnlG9PnrJsCcSjs1wyyD6vJpaYtgnzDrKYRSqf3OO6Rfa93xsRg==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/has-symbols": {
      "version": "1.1.0",
      "resolved": "https://registry.npmmirror.com/has-symbols/-/has-symbols-1.1.0.tgz",
      "integrity": "sha512-1cDNdwJ2Jaohmb3sg4OmKaMBwuC48sYni5HUw2DvsC8LjGTLK9h+eb1X6RyuOHe4hT0ULCW68iomhjUoKUqlPQ==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/has-tostringtag": {
      "version": "1.0.2",
      "resolved": "https://registry.npmmirror.com/has-tostringtag/-/has-tostringtag-1.0.2.tgz",
      "integrity": "sha512-NqADB8VjPFLM2V0VvHUewwwsw0ZWBaIdgo+ieHtK3hasLz4qeCRjYcqfB6AQrBggRKppKF8L52/VqdVsO47Dlw==",
      "license": "MIT",
      "dependencies": {
        "has-symbols": "^1.0.3"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/hasown": {
      "version": "2.0.2",
      "resolved": "https://registry.npmmirror.com/hasown/-/hasown-2.0.2.tgz",
      "integrity": "sha512-0hJU9SCPvmMzIBdZFqNPXWa6dqh7WdH0cII9y+CyS8rG3nL48Bclra9HmKhVVUHyPWNH5Y7xDwAB7bfgSjkUMQ==",
      "license": "MIT",
      "dependencies": {
        "function-bind": "^1.1.2"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/jsonwebtoken": {
      "version": "9.0.2",
      "resolved": "https://registry.npmmirror.com/jsonwebtoken/-/jsonwebtoken-9.0.2.tgz",
      "integrity": "sha512-PRp66vJ865SSqOlgqS8hujT5U4AOgMfhrwYIuIhfKaoSCZcirrmASQr8CX7cUg+RMih+hgznrjp99o+W4pJLHQ==",
      "license": "MIT",
      "dependencies": {
        "jws": "^3.2.2",
        "lodash.includes": "^4.3.0",
        "lodash.isboolean": "^3.0.3",
        "lodash.isinteger": "^4.0.4",
        "lodash.isnumber": "^3.0.3",
        "lodash.isplainobject": "^4.0.6",
        "lodash.isstring": "^4.0.1",
        "lodash.once": "^4.0.0",
        "ms": "^2.1.1",
        "semver": "^7.5.4"
      },
      "engines": {
        "node": ">=12",
        "npm": ">=6"
      }
    },
    "node_modules/jwa": {
      "version": "1.4.2",
      "resolved": "https://registry.npmmirror.com/jwa/-/jwa-1.4.2.tgz",
      "integrity": "sha512-eeH5JO+21J78qMvTIDdBXidBd6nG2kZjg5Ohz/1fpa28Z4CcsWUzJ1ZZyFq/3z3N17aZy+ZuBoHljASbL1WfOw==",
      "license": "MIT",
      "dependencies": {
        "buffer-equal-constant-time": "^1.0.1",
        "ecdsa-sig-formatter": "1.0.11",
        "safe-buffer": "^5.0.1"
      }
    },
    "node_modules/jws": {
      "version": "3.2.2",
      "resolved": "https://registry.npmmirror.com/jws/-/jws-3.2.2.tgz",
      "integrity": "sha512-YHlZCB6lMTllWDtSPHz/ZXTsi8S00usEV6v1tjq8tOUZzw7DpSDWVXjXDre6ed1w/pd495ODpHZYSdkRTsa0HA==",
      "license": "MIT",
      "dependencies": {
        "jwa": "^1.4.1",
        "safe-buffer": "^5.0.1"
      }
    },
    "node_modules/lodash.includes": {
      "version": "4.3.0",
      "resolved": "https://registry.npmmirror.com/lodash.includes/-/lodash.includes-4.3.0.tgz",
      "integrity": "sha512-W3Bx6mdkRTGtlJISOvVD/lbqjTlPPUDTMnlXZFnVwi9NKJ6tiAk6LVdlhZMm17VZisqhKcgzpO5Wz91PCt5b0w==",
      "license": "MIT"
    },
    "node_modules/lodash.isboolean": {
      "version": "3.0.3",
      "resolved": "https://registry.npmmirror.com/lodash.isboolean/-/lodash.isboolean-3.0.3.tgz",
      "integrity": "sha512-Bz5mupy2SVbPHURB98VAcw+aHh4vRV5IPNhILUCsOzRmsTmSQ17jIuqopAentWoehktxGd9e/hbIXq980/1QJg==",
      "license": "MIT"
    },
    "node_modules/lodash.isinteger": {
      "version": "4.0.4",
      "resolved": "https://registry.npmmirror.com/lodash.isinteger/-/lodash.isinteger-4.0.4.tgz",
      "integrity": "sha512-DBwtEWN2caHQ9/imiNeEA5ys1JoRtRfY3d7V9wkqtbycnAmTvRRmbHKDV4a0EYc678/dia0jrte4tjYwVBaZUA==",
      "license": "MIT"
    },
    "node_modules/lodash.isnumber": {
      "version": "3.0.3",
      "resolved": "https://registry.npmmirror.com/lodash.isnumber/-/lodash.isnumber-3.0.3.tgz",
      "integrity": "sha512-QYqzpfwO3/CWf3XP+Z+tkQsfaLL/EnUlXWVkIk5FUPc4sBdTehEqZONuyRt2P67PXAk+NXmTBcc97zw9t1FQrw==",
      "license": "MIT"
    },
    "node_modules/lodash.isplainobject": {
      "version": "4.0.6",
      "resolved": "https://registry.npmmirror.com/lodash.isplainobject/-/lodash.isplainobject-4.0.6.tgz",
      "integrity": "sha512-oSXzaWypCMHkPC3NvBEaPHf0KsA5mvPrOPgQWDsbg8n7orZ290M0BmC/jgRZ4vcJ6DTAhjrsSYgdsW/F+MFOBA==",
      "license": "MIT"
    },
    "node_modules/lodash.isstring": {
      "version": "4.0.1",
      "resolved": "https://registry.npmmirror.com/lodash.isstring/-/lodash.isstring-4.0.1.tgz",
      "integrity": "sha512-0wJxfxH1wgO3GrbuP+dTTk7op+6L41QCXbGINEmD+ny/G/eCqGzxyCsh7159S+mgDDcoarnBw6PC1PS5+wUGgw==",
      "license": "MIT"
    },
    "node_modules/lodash.once": {
      "version": "4.1.1",
      "resolved": "https://registry.npmmirror.com/lodash.once/-/lodash.once-4.1.1.tgz",
      "integrity": "sha512-Sb487aTOCr9drQVL8pIxOzVhafOjZN9UU54hiN8PU3uAiSV7lx1yYNpbNmex2PK6dSJoNTSJUUswT651yww3Mg==",
      "license": "MIT"
    },
    "node_modules/math-intrinsics": {
      "version": "1.1.0",
      "resolved": "https://registry.npmmirror.com/math-intrinsics/-/math-intrinsics-1.1.0.tgz",
      "integrity": "sha512-/IXtbwEk5HTPyEwyKX6hGkYXxM9nbj64B+ilVJnC/R6B0pH5G4V3b0pVbL7DBj4tkhBAppbQUlf6F6Xl9LHu1g==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/methods": {
      "version": "1.1.2",
      "resolved": "https://registry.npmmirror.com/methods/-/methods-1.1.2.tgz",
      "integrity": "sha512-iclAHeNqNm68zFtnZ0e+1L2yUIdvzNoauKU4WBA3VvH/vPFieF7qfRlwUZU+DA9P9bPXIS90ulxoUoCH23sV2w==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/mime": {
      "version": "2.6.0",
      "resolved": "https://registry.npmmirror.com/mime/-/mime-2.6.0.tgz",
      "integrity": "sha512-USPkMeET31rOMiarsBNIHZKLGgvKc/LrjofAnBlOttf5ajRvqiRA8QsenbcooctK6d6Ts6aqZXBA+XbkKthiQg==",
      "license": "MIT",
      "bin": {
        "mime": "cli.js"
      },
      "engines": {
        "node": ">=4.0.0"
      }
    },
    "node_modules/mime-db": {
      "version": "1.52.0",
      "resolved": "https://registry.npmmirror.com/mime-db/-/mime-db-1.52.0.tgz",
      "integrity": "sha512-sPU4uV7dYlvtWJxwwxHD0PuihVNiE7TyAbQ5SWxDCB9mUYvOgroQOwYQQOKPJ8CIbE+1ETVlOoK1UC2nU3gYvg==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/mime-types": {
      "version": "2.1.35",
      "resolved": "https://registry.npmmirror.com/mime-types/-/mime-types-2.1.35.tgz",
      "integrity": "sha512-ZDY+bPm5zTTF+YpCrAU9nK0UgICYPT0QtT1NZWFv4s++TNkcgVaT0g6+4R2uI4MjQjzysHB1zxuWL50hzaeXiw==",
      "license": "MIT",
      "dependencies": {
        "mime-db": "1.52.0"
      },
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/ms": {
      "version": "2.1.3",
      "resolved": "https://registry.npmmirror.com/ms/-/ms-2.1.3.tgz",
      "integrity": "sha512-6FlzubTLZG3J2a/NVCAleEhjzq5oxgHyaCU9yYXvcLsvoVaHJq/s5xXI6/XXP6tz7R9xAOtHnSO/tXtF3WRTlA==",
      "license": "MIT"
    },
    "node_modules/object-inspect": {
      "version": "1.13.4",
      "resolved": "https://registry.npmmirror.com/object-inspect/-/object-inspect-1.13.4.tgz",
      "integrity": "sha512-W67iLl4J2EXEGTbfeHCffrjDfitvLANg0UlX3wFUUSTx92KXRFegMHUVgSqE+wvhAbi4WqjGg9czysTV2Epbew==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/once": {
      "version": "1.4.0",
      "resolved": "https://registry.npmmirror.com/once/-/once-1.4.0.tgz",
      "integrity": "sha512-lNaJgI+2Q5URQBkccEKHTQOPaXdUxnZZElQTZY0MFUAuaEqe1E+Nyvgdz/aIyNi6Z9MzO5dv1H8n58/GELp3+w==",
      "license": "ISC",
      "dependencies": {
        "wrappy": "1"
      }
    },
    "node_modules/proxy-from-env": {
      "version": "1.1.0",
      "resolved": "https://registry.npmmirror.com/proxy-from-env/-/proxy-from-env-1.1.0.tgz",
      "integrity": "sha512-D+zkORCbA9f1tdWRK0RaCR3GPv50cMxcrz4X8k5LTSUD1Dkw47mKJEZQNunItRTkWwgtaUSo1RVFRIG9ZXiFYg==",
      "license": "MIT"
    },
    "node_modules/qs": {
      "version": "6.14.0",
      "resolved": "https://registry.npmmirror.com/qs/-/qs-6.14.0.tgz",
      "integrity": "sha512-YWWTjgABSKcvs/nWBi9PycY/JiPJqOD4JA6o9Sej2AtvSGarXxKC3OQSk4pAarbdQlKAh5D4FCQkJNkW+GAn3w==",
      "license": "BSD-3-Clause",
      "dependencies": {
        "side-channel": "^1.1.0"
      },
      "engines": {
        "node": ">=0.6"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/safe-buffer": {
      "version": "5.2.1",
      "resolved": "https://registry.npmmirror.com/safe-buffer/-/safe-buffer-5.2.1.tgz",
      "integrity": "sha512-rp3So07KcdmmKbGvgaNxQSJr7bGVSVk5S9Eq1F+ppbRo70+YeaDxkw5Dd8NPN+GD6bjnYm2VuPuCXmpuYvmCXQ==",
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/feross"
        },
        {
          "type": "patreon",
          "url": "https://www.patreon.com/feross"
        },
        {
          "type": "consulting",
          "url": "https://feross.org/support"
        }
      ],
      "license": "MIT"
    },
    "node_modules/semver": {
      "version": "7.7.2",
      "resolved": "https://registry.npmmirror.com/semver/-/semver-7.7.2.tgz",
      "integrity": "sha512-RF0Fw+rO5AMf9MAyaRXI4AV0Ulj5lMHqVxxdSgiVbixSCXoEmmX/jk0CuJw4+3SqroYO9VoUh+HcuJivvtJemA==",
      "license": "ISC",
      "bin": {
        "semver": "bin/semver.js"
      },
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/side-channel": {
      "version": "1.1.0",
      "resolved": "https://registry.npmmirror.com/side-channel/-/side-channel-1.1.0.tgz",
      "integrity": "sha512-ZX99e6tRweoUXqR+VBrslhda51Nh5MTQwou5tnUDgbtyM0dBgmhEDtWGP/xbKn6hqfPRHujUNwz5fy/wbbhnpw==",
      "license": "MIT",
      "dependencies": {
        "es-errors": "^1.3.0",
        "object-inspect": "^1.13.3",
        "side-channel-list": "^1.0.0",
        "side-channel-map": "^1.0.1",
        "side-channel-weakmap": "^1.0.2"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/side-channel-list": {
      "version": "1.0.0",
      "resolved": "https://registry.npmmirror.com/side-channel-list/-/side-channel-list-1.0.0.tgz",
      "integrity": "sha512-FCLHtRD/gnpCiCHEiJLOwdmFP+wzCmDEkc9y7NsYxeF4u7Btsn1ZuwgwJGxImImHicJArLP4R0yX4c2KCrMrTA==",
      "license": "MIT",
      "dependencies": {
        "es-errors": "^1.3.0",
        "object-inspect": "^1.13.3"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/side-channel-map": {
      "version": "1.0.1",
      "resolved": "https://registry.npmmirror.com/side-channel-map/-/side-channel-map-1.0.1.tgz",
      "integrity": "sha512-VCjCNfgMsby3tTdo02nbjtM/ewra6jPHmpThenkTYh8pG9ucZ/1P8So4u4FGBek/BjpOVsDCMoLA/iuBKIFXRA==",
      "license": "MIT",
      "dependencies": {
        "call-bound": "^1.0.2",
        "es-errors": "^1.3.0",
        "get-intrinsic": "^1.2.5",
        "object-inspect": "^1.13.3"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/side-channel-weakmap": {
      "version": "1.0.2",
      "resolved": "https://registry.npmmirror.com/side-channel-weakmap/-/side-channel-weakmap-1.0.2.tgz",
      "integrity": "sha512-WPS/HvHQTYnHisLo9McqBHOJk2FkHO/tlpvldyrnem4aeQp4hai3gythswg6p01oSoTl58rcpiFAjF2br2Ak2A==",
      "license": "MIT",
      "dependencies": {
        "call-bound": "^1.0.2",
        "es-errors": "^1.3.0",
        "get-intrinsic": "^1.2.5",
        "object-inspect": "^1.13.3",
        "side-channel-map": "^1.0.1"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/superagent": {
      "version": "8.0.6",
      "resolved": "https://registry.npmmirror.com/superagent/-/superagent-8.0.6.tgz",
      "integrity": "sha512-HqSe6DSIh3hEn6cJvCkaM1BLi466f1LHi4yubR0tpewlMpk4RUFFy35bKz8SsPBwYfIIJy5eclp+3tCYAuX0bw==",
      "deprecated": "Please upgrade to superagent v10.2.2+, see release notes at https://github.com/forwardemail/superagent/releases/tag/v10.2.2 - maintenance is supported by Forward Email @ https://forwardemail.net",
      "license": "MIT",
      "dependencies": {
        "component-emitter": "^1.3.0",
        "cookiejar": "^2.1.3",
        "debug": "^4.3.4",
        "fast-safe-stringify": "^2.1.1",
        "form-data": "^4.0.0",
        "formidable": "^2.1.1",
        "methods": "^1.1.2",
        "mime": "2.6.0",
        "qs": "^6.11.0",
        "semver": "^7.3.8"
      },
      "engines": {
        "node": ">=6.4.0 <13 || >=14"
      }
    },
    "node_modules/tweetnacl": {
      "version": "1.0.3",
      "resolved": "https://registry.npmmirror.com/tweetnacl/-/tweetnacl-1.0.3.tgz",
      "integrity": "sha512-6rt+RN7aOi1nGMyC4Xa5DdYiukl2UWCbcJft7YhxReBGQD7OAM8Pbxw6YMo4r2diNEA8FEmu32YOn9rhaiE5yw==",
      "license": "Unlicense"
    },
    "node_modules/undici-types": {
      "version": "7.10.0",
      "resolved": "https://registry.npmmirror.com/undici-types/-/undici-types-7.10.0.tgz",
      "integrity": "sha512-t5Fy/nfn+14LuOc2KNYg75vZqClpAiqscVvMygNnlsHBFpSXdJaYtXMcdNLpl/Qvc3P2cB3s6lOV51nqsFq4ag==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/wechatpay-node-v3": {
      "version": "2.2.1",
      "resolved": "https://registry.npmmirror.com/wechatpay-node-v3/-/wechatpay-node-v3-2.2.1.tgz",
      "integrity": "sha512-z+n8Mrzn0UNoLJPBRrY8ZG6yo9xxNihlGvwvAbV8Nlnm4tTap2UjwIikGkhryC8gOmwrlvJfSUd+x1cK3ks1hA==",
      "license": "MIT",
      "dependencies": {
        "@fidm/x509": "1.2.1",
        "superagent": "8.0.6"
      }
    },
    "node_modules/wrappy": {
      "version": "1.0.2",
      "resolved": "https://registry.npmmirror.com/wrappy/-/wrappy-1.0.2.tgz",
      "integrity": "sha512-l4Sp/DRseor9wL6EvV2+TuQn63dMkPjZ/sp9XkghTEbV9KlPS1xUsZ3u7/IQO4wxtcFB4bgpQPRcR3QCvezPcQ==",
      "license": "ISC"
    }
  }
}


================================================================================
### FILE: package.json
================================================================================

{
  "dependencies": {
    "axios": "^1.11.0",
    "dotenv": "^17.2.2",
    "jsonwebtoken": "^9.0.2",
    "wechatpay-node-v3": "^2.2.1"
  },
  "devDependencies": {
    "@types/jsonwebtoken": "^9.0.10"
  }
}


================================================================================
### FILE: project.private.config.json
================================================================================

{
  "setting": {
    "compileHotReLoad": true,
    "urlCheck": false,
    "coverView": true,
    "lazyloadPlaceholderEnable": false,
    "skylineRenderEnable": false,
    "preloadBackgroundData": false,
    "autoAudits": false,
    "useApiHook": true,
    "useApiHostProcess": true,
    "showShadowRootInWxmlPanel": true,
    "useStaticServer": false,
    "useLanDebug": false,
    "showES6CompileOption": false,
    "checkInvalidKey": true,
    "ignoreDevUnusedFiles": true,
    "bigPackageSizeSupport": false,
    "useIsolateContext": true
  },
  "condition": {},
  "description": "项目私有配置文件。此文件中的内容将覆盖 project.config.json 中的相同字段。项目的改动优先同步到此文件中。详见文档：https://developers.weixin.qq.com/miniprogram/dev/devtools/projectconfig.html",
  "projectname": "%E5%9B%BE%E4%B9%A6",
  "libVersion": "3.9.3"
}


================================================================================
### FILE: update_user_metrics.js
================================================================================

const { PrismaClient } = require('@prisma/client');

const prisma = new PrismaClient();

async function updateUserMetrics() {
  try {
    // Get the current user count
    const userCount = await prisma.user.count();
    console.log(`Found ${userCount} users in database`);

    // Update the metrics by triggering the metrics object
    // Since we can't directly access the metrics object, we'll make an HTTP request
    const response = await fetch('http://localhost:8080/metrics');
    const metrics = await response.text();

    console.log('Current user metrics:');
    console.log(metrics.split('\n').filter(line => line.includes('bookworm_users_logged_in_total')));

  } catch (error) {
    console.error('Error updating metrics:', error);
  } finally {
    await prisma.$disconnect();
  }
}

updateUserMetrics();


================================================================================
### FILE: 审查 (v2 - 带脱敏功能).py
================================================================================

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Bookworm 项目代码审查文件生成器 (v3 - 智能包含机制)
基于文件扩展名和路径模式智能包含所有核心业务代码，避免遗漏关键文件。

使用方法:
1. 将此脚本保存为 `审查.py` 放在项目根目录。
2. 在终端中运行: `python3 审查.py`

输出:
    bookworm_code_review.txt
"""

import os
import datetime
import fnmatch

# ==============================================================================
# 智能文件包含规则 - 基于扩展名和路径模式
# ==============================================================================

# 核心业务文件扩展名 (精简版)
CORE_EXTENSIONS = {
    '.ts', '.js', '.prisma', '.md', '.env'
}

# 关键业务文件路径 (只包含核心逻辑)
ESSENTIAL_PATTERNS = [
    'CLAUDE.md',
    'bookworm-backend/src/index.ts',
    'bookworm-backend/src/config.ts',
    'bookworm-backend/src/db.ts',
    'bookworm-backend/src/errors.ts',
    'bookworm-backend/src/services/*.ts',
    'bookworm-backend/prisma/schema.prisma',
    'bookworm-backend/.env*',
    'bookworm-backend/package.json',
    'bookworm-backend/src/jobs/*.ts',
    'bookworm-backend/src/plugins/*.ts',
    # Re-include the most critical integration test as a representative sample
    'bookworm-backend/src/tests/order.integration.test.ts',
    'bookworm-backend/src/tests/concurrent-order-control.integration.test.ts',
    'bookworm-backend/src/tests/paymentSecurity.integration.test.ts',
    # Also include the setup files, they provide critical context on HOW tests are run
    'bookworm-backend/src/tests/database-integration-setup.ts',
    'bookworm-backend/src/tests/globalSetup.ts',
    'miniprogram/app.js',
    'miniprogram/app.json',
    'miniprogram/config.js',
    'miniprogram/utils/api.js',
    'miniprogram/utils/auth.js',
    'miniprogram/pages/*/index.js'
]

# 明确排除的文件类型 (减少噪音)
EXCLUDE_EXTENSIONS = {
    '.wxml', '.wxss', '.json', '.css', '.html', '.sql'
}

# 排除特定文件
EXCLUDE_SPECIFIC = {
    'miniprogram/sitemap.json',
    'project.config.json',
    '.eslintrc.js',
    'bookworm-backend/public/*',
    'bookworm-backend/src/tests/*'
}

# 排除目录和文件模式 (真正无用的文件)
EXCLUDE_DIRS = {
    'node_modules', '.git', '__pycache__', 'dist', 'build', '.idea', 
    '.vscode', 'miniprogram_npm', '.nyc_output', 'coverage'
}

EXCLUDE_FILES = {
    'package-lock.json', 'yarn.lock', '.DS_Store', 'Thumbs.db',
    'project.private.config.json', '*.log', '*.tmp', '*.cache'
}

# 敏感文件列表 (这些文件的内容将被脱敏)
SENSITIVE_FILES = {
    'bookworm-backend/.env'
}

def should_include_dir(dir_path):
    dir_name = os.path.basename(dir_path)
    return dir_name not in EXCLUDE_DIRS and not dir_name.startswith('.')

def matches_any_pattern(file_path, patterns):
    """检查文件路径是否匹配任何一个glob模式"""
    for pattern in patterns:
        if fnmatch.fnmatch(file_path, pattern):
            return True
    return False

def should_include_file(file_path, project_root):
    """精简判断文件是否应该包含在审查中 - 只要核心业务逻辑"""
    # 转换为相对路径
    try:
        rel_path = os.path.relpath(file_path, project_root).replace(os.sep, '/')
    except ValueError:
        return False
    
    # 排除明确不需要的文件
    for exclude_pattern in EXCLUDE_SPECIFIC:
        if fnmatch.fnmatch(rel_path, exclude_pattern):
            return False
    
    # 排除特定扩展名
    _, ext = os.path.splitext(file_path)
    if ext.lower() in EXCLUDE_EXTENSIONS:
        return False
    
    # 检查是否在排除文件列表中
    filename = os.path.basename(file_path)
    for exclude_pattern in EXCLUDE_FILES:
        if fnmatch.fnmatch(filename, exclude_pattern):
            return False
    
    # 只包含核心扩展名的文件
    if ext.lower() in CORE_EXTENSIONS:
        # 但必须匹配关键路径模式
        return matches_any_pattern(rel_path, ESSENTIAL_PATTERNS)
    
    return False

def collect_files_to_review(project_root):
    """收集所有需要审查的文件"""
    files_to_review = set()
    
    for root, dirs, files in os.walk(project_root):
        # 过滤目录
        dirs[:] = [d for d in dirs if should_include_dir(os.path.join(root, d))]
        
        for file in files:
            file_path = os.path.join(root, file)
            if should_include_file(file_path, project_root):
                rel_path = os.path.relpath(file_path, project_root)
                files_to_review.add(rel_path)
    
    return sorted(files_to_review)

def get_file_tree(root_path, prefix=""):
    items = []
    try:
        entries = sorted([e for e in os.listdir(root_path) if e not in EXCLUDE_FILES and should_include_dir(os.path.join(root_path, e))])
        for i, entry_name in enumerate(entries):
            is_last = i == len(entries) - 1
            connector = "└── " if is_last else "├── "
            full_path = os.path.join(root_path, entry_name)
            is_dir = os.path.isdir(full_path)
            items.append(f"{prefix}{connector}{entry_name}{'/' if is_dir else ''}")
            if is_dir:
                new_prefix = prefix + ("    " if is_last else "│   ")
                items.extend(get_file_tree(full_path, new_prefix))
    except PermissionError:
        items.append(f"{prefix}└── [Permission Denied]")
    return items

def read_file_content(file_path):
    encodings = ['utf-8', 'gbk', 'latin-1']
    for encoding in encodings:
        try:
            with open(file_path, 'r', encoding=encoding) as f:
                return f.read()
        except Exception:
            continue
    return f"[Error: Unable to decode file '{os.path.basename(file_path)}']"

def sanitize_sensitive_content(rel_path, content):
    """如果文件在敏感列表中，则对其内容进行脱敏处理"""
    normalized_path = rel_path.replace(os.sep, '/')
    if normalized_path in SENSITIVE_FILES:
        lines = content.strip().split('\n')
        sanitized_lines = []
        for line in lines:
            if line.strip().startswith('#') or not line.strip():
                sanitized_lines.append(line)
            else:
                parts = line.split('=', 1)
                if len(parts) == 2:
                    key = parts[0]
                    sanitized_lines.append(f"{key}=[REDACTED]")
                else:
                    sanitized_lines.append("[REDACTED]")
        return f"#\n# CONTENT OF SENSITIVE FILE '{normalized_path}' HAS BEEN REDACTED\n#\n" + "\n".join(sanitized_lines)
    return content

def generate_core_review_file(project_root):
    output_filename = 'bookworm_code_review.txt'
    output_filepath = os.path.join(project_root, output_filename)
    
    # 收集所有要审查的文件
    files_to_review = collect_files_to_review(project_root)
    
    with open(output_filepath, 'w', encoding='utf-8') as f:
        f.write("=" * 80 + "\nBOOKWORM PROJECT - COMPREHENSIVE CODE REVIEW\n" + "=" * 80 + "\n")
        f.write(f"Generated on: {datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
        f.write(f"Mode: Essential files only - Core business logic and architecture.\n")
        f.write(f"Total files included: {len(files_to_review)} (精简版)\n\n")

        f.write("### 📁 PROJECT FILE TREE ###\n" + "-" * 40 + "\n")
        f.write(f"{os.path.basename(project_root)}/\n")
        for item in get_file_tree(project_root):
            f.write(item + "\n")
        f.write("\n\n")
        
        # 按类型分组显示文件列表
        backend_files = [f for f in files_to_review if f.startswith('bookworm-backend/')]
        frontend_files = [f for f in files_to_review if f.startswith('miniprogram/')]
        root_files = [f for f in files_to_review if '/' not in f]
        
        f.write(f"### 📋 INCLUDED FILES SUMMARY ###\n" + "-" * 40 + "\n")
        f.write(f"Root files ({len(root_files)}): {', '.join(root_files)}\n")
        f.write(f"Backend files ({len(backend_files)}): {len(backend_files)} TypeScript/config files\n")
        f.write(f"Frontend files ({len(frontend_files)}): {len(frontend_files)} WeChat Mini Program files\n\n")
        
        f.write(f"### 📄 SOURCE CODE CONTENT ###\n" + "-" * 40 + "\n\n")

        for rel_path in files_to_review:
            full_path = os.path.join(project_root, rel_path)
            f.write("=" * 80 + f"\n### FILE: {rel_path}\n" + "=" * 80 + "\n\n")
            if os.path.exists(full_path) and os.path.isfile(full_path):
                content = read_file_content(full_path)
                sanitized_content = sanitize_sensitive_content(rel_path, content)
                f.write(sanitized_content.strip() + "\n\n\n")
            else:
                f.write(f"[FILE NOT FOUND]\n\n\n")

        f.write("=" * 80 + "\nCOMPREHENSIVE CODE REVIEW REPORT GENERATION COMPLETE.\n" + "=" * 80 + "\n")
    
    return output_filepath

def main():
    project_root = os.getcwd()
    print("[START] Generating core code review report for Bookworm...")
    try:
        output_file = generate_core_review_file(project_root)
        file_size = os.path.getsize(output_file)
        size_str = f"{file_size / 1024:.2f} KB" if file_size > 1024 else f"{file_size} bytes"
        files_count = len(collect_files_to_review(project_root))
        print(f"[SUCCESS] Comprehensive review report generated!")
        print(f"  - Output file: {os.path.basename(output_file)}")
        print(f"  - File size: {size_str}")
        print(f"  - Files included: {files_count} (smart inclusion algorithm)")
        print("[INFO] All core business files automatically detected and included.")
        print("[INFO] Sensitive files like '.env' have been automatically redacted.")
    except Exception as e:
        print(f"[ERROR] Failed to generate report: {e}")

if __name__ == "__main__":
    main()


================================================================================
### FILE: 审查.py
================================================================================

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Bookworm 项目代码审查文件生成器 (原始版 - 不脱敏)
基于文件扩展名和路径模式智能包含所有核心业务代码，保持原始数据不脱敏。

使用方法:
1. 将此脚本保存为 `审查.py` 放在项目根目录。
2. 在终端中运行: `python3 审查.py`

输出:
    bookworm_code_review.txt
"""

import os
import datetime
import fnmatch

# ==============================================================================
# 智能文件包含规则 (v4 - 健壮版)
# 哲学: 广泛包含所有潜在的源代码和配置文件，然后精确排除已知的噪音。
# 这比维护一个脆弱的"必要文件"白名单要健壮得多。
# ==============================================================================

# 1. 定义什么是源代码/配置文件 (通过扩展名)
#    这些是我们关心的东西。
SOURCE_CODE_EXTENSIONS = {
    '.ts', '.js', '.prisma', '.md', '.sql',  # Code & Schema
    '.json', '.env', '.toml', '.yml', '.yaml', # Configs
    '.py' # Include the script itself for context
}

# 2. 定义什么是绝对的噪音 (通过路径和文件名模式)
#    这些东西永远不应该出现在审查报告里。
EXCLUDE_PATTERNS = [
    # 目录
    '**/node_modules/**',
    '**/.git/**',
    '**/dist/**',
    '**/build/**',
    '**/coverage/**',
    '**/.nyc_output/**',
    '**/miniprogram_npm/**',
    '**/.vscode/**',
    '**/.idea/**',
    '**/__pycache__/**',

    # 锁文件和私有配置
    '**/package-lock.json',
    '**/yarn.lock',
    '**/project.private.config.json',

    # 编译输出或缓存
    '**/*.log',
    '**/*.tmp',
    '**/*.cache',
    '**/.DS_Store',

    # 明确不关心的前端资源和配置文件
    'miniprogram/images/**',
    'miniprogram/**/*.wxml',
    'miniprogram/**/*.wxss',
    'miniprogram/sitemap.json',
    'project.config.json',
    '.eslintrc.js',
    'bookworm-backend/public/**',

    # 我们只关心集成测试，单元测试噪音太大
    'bookworm-backend/src/tests/*.test.ts',
    'bookworm-backend/src/tests/__mocks__/**',
    'bookworm-backend/vitest.config.ts',
    'bookworm-backend/vitest.integration.config.ts',
    'bookworm-backend/vitest.database-integration.config.ts'
]

# 3. 定义敏感文件 (内容需要脱敏)
#    这个版本我们先不脱敏，但保留列表以便切换。
SENSITIVE_FILES = {
    # 'bookworm-backend/.env' # 暂时注释掉，以便你看到完整内容
}

def should_include_dir(dir_path):
    """A robust check to prevent descending into known garbage directories."""
    dir_name = os.path.basename(dir_path)
    # These are the top-level directories we ALWAYS want to skip.
    garbage_dirs = {'node_modules', '.git', 'dist', 'build', 'coverage', '.nyc_output', 'miniprogram_npm', '.vscode', '.idea', '__pycache__'}
    if dir_name in garbage_dirs:
        return False
    return True

def matches_any_pattern(file_path, patterns):
    """检查文件路径是否匹配任何一个glob模式"""
    for pattern in patterns:
        if fnmatch.fnmatch(file_path, pattern):
            return True
    return False

def should_include_file(file_path, project_root):
    """v4健壮版本：先包含所有源代码，然后排除噪音"""
    # 转换为相对路径
    try:
        rel_path = os.path.relpath(file_path, project_root).replace(os.sep, '/')
    except ValueError:
        return False

    # 第一步：检查是否是我们关心的源代码文件类型
    _, ext = os.path.splitext(file_path)
    if ext.lower() not in SOURCE_CODE_EXTENSIONS:
        return False

    # 第二步：检查是否匹配任何排除模式
    for exclude_pattern in EXCLUDE_PATTERNS:
        if fnmatch.fnmatch(rel_path, exclude_pattern):
            return False

    # 如果既是源代码文件，又不匹配排除模式，就包含它
    return True

def collect_files_to_review(project_root):
    """收集所有需要审查的文件"""
    files_to_review = set()
    
    for root, dirs, files in os.walk(project_root):
        # 过滤目录
        dirs[:] = [d for d in dirs if should_include_dir(os.path.join(root, d))]
        
        for file in files:
            file_path = os.path.join(root, file)
            if should_include_file(file_path, project_root):
                rel_path = os.path.relpath(file_path, project_root)
                files_to_review.add(rel_path)
    
    return sorted(files_to_review)

def get_file_tree(root_path, prefix=""):
    items = []
    try:
        entries = sorted(os.listdir(root_path))
        
        filtered_entries = [
            e for e in entries 
            if os.path.join(root_path, e) not in EXCLUDE_FILES
        ]
        
        dirs = [d for d in filtered_entries if os.path.isdir(os.path.join(root_path, d)) and should_include_dir(d)]
        files = [f for f in filtered_entries if os.path.isfile(os.path.join(root_path, f)) and f not in EXCLUDE_FILES]
        
        all_entries = dirs + files
        for i, entry_name in enumerate(all_entries):
            is_last = i == len(all_entries) - 1
            connector = "└── " if is_last else "├── "
            items.append(f"{prefix}{connector}{entry_name}{'/' if entry_name in dirs else ''}")
            
            if entry_name in dirs:
                new_prefix = prefix + ("    " if is_last else "│   ")
                items.extend(get_file_tree(os.path.join(root_path, entry_name), new_prefix))
    except PermissionError:
        items.append(f"{prefix}└── [Permission Denied]")
    return items

def read_file_content(file_path):
    encodings = ['utf-8', 'gbk', 'latin-1']
    for encoding in encodings:
        try:
            with open(file_path, 'r', encoding=encoding) as f:
                return f.read()
        except Exception:
            continue
    return f"[Error: Unable to decode file '{os.path.basename(file_path)}' with common encodings]"

def generate_core_review_file(project_root):
    output_filename = 'bookworm_code_review.txt'
    output_filepath = os.path.join(project_root, output_filename)
    
    # 收集所有要审查的文件
    files_to_review = collect_files_to_review(project_root)
    
    with open(output_filepath, 'w', encoding='utf-8') as f:
        f.write("=" * 80 + "\nBOOKWORM PROJECT - ESSENTIAL CODE REVIEW (UNREDACTED)\n" + "=" * 80 + "\n")
        f.write(f"Generated on: {datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
        f.write(f"Mode: Essential files only - Core business logic with original data.\n")
        f.write(f"Total files included: {len(files_to_review)} (精简版)\n\n")

        # f.write("### 📁 PROJECT FILE TREE ###\n" + "-" * 40 + "\n")
        # f.write(f"{os.path.basename(project_root)}/\n")
        # for item in get_file_tree(project_root):
        #     f.write(item + "\n")
        # f.write("\n\n")
        
        # 按类型分组显示文件列表
        backend_files = [f for f in files_to_review if f.startswith('bookworm-backend')]
        frontend_files = [f for f in files_to_review if f.startswith('miniprogram')]
        root_files = [f for f in files_to_review if os.sep not in f and '/' not in f]
        
        f.write(f"### 📋 INCLUDED FILES SUMMARY ###\n" + "-" * 40 + "\n")
        f.write(f"Root files ({len(root_files)}): {', '.join(root_files) if root_files else 'None'}\n")
        f.write(f"Backend files ({len(backend_files)}): {len(backend_files)} TypeScript/config files\n")
        f.write(f"Frontend files ({len(frontend_files)}): {len(frontend_files)} WeChat Mini Program files\n\n")
        
        f.write(f"### 📄 SOURCE CODE CONTENT ###\n" + "-" * 40 + "\n\n")

        for rel_path in files_to_review:
            full_path = os.path.join(project_root, rel_path)
            f.write("=" * 80 + f"\n### FILE: {rel_path}\n" + "=" * 80 + "\n\n")
            if os.path.exists(full_path) and os.path.isfile(full_path):
                content = read_file_content(full_path)
                f.write(content.strip() + "\n\n\n")
            else:
                f.write(f"[FILE NOT FOUND]\n\n\n")

        f.write("=" * 80 + "\nESSENTIAL CODE REVIEW REPORT GENERATION COMPLETE.\n" + "=" * 80 + "\n")
    
    return output_filepath

def main():
    project_root = os.getcwd()
    print("[START] Generating essential code review report for Bookworm (UNREDACTED)...")
    try:
        output_file = generate_core_review_file(project_root)
        files_count = len(collect_files_to_review(project_root))
        file_size = os.path.getsize(output_file)
        size_str = f"{file_size / 1024:.2f} KB" if file_size > 1024 else f"{file_size} bytes"
        print(f"[SUCCESS] Essential review report generated!")
        print(f"  - Output file: {os.path.basename(output_file)}")
        print(f"  - File size: {size_str}")
        print(f"  - Files included: {files_count} (smart inclusion algorithm)")
        print("[INFO] All core business files automatically detected and included.")
        print("[WARNING] This version contains original data - DO NOT share externally.")
    except Exception as e:
        print(f"[ERROR] Failed to generate report: {e}")

if __name__ == "__main__":
    main()


================================================================================
ESSENTIAL CODE REVIEW REPORT GENERATION COMPLETE.
================================================================================
