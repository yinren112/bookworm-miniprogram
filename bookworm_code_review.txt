================================================================================
BOOKWORM PROJECT - CORE CODE REVIEW
================================================================================
Generated on: 2025-09-10 17:40:55
Mode: Core files only. This report contains the architectural backbone of the project.

### ğŸ“ PROJECT FILE TREE ###
----------------------------------------
miniprogram-13/
â”œâ”€â”€ bookworm-backend/
â”‚   â”œâ”€â”€ coverage/
â”‚   â”‚   â”œâ”€â”€ public/
â”‚   â”‚   â”‚   â”œâ”€â”€ index.html
â”‚   â”‚   â”‚   â””â”€â”€ main.js.html
â”‚   â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”‚   â”œâ”€â”€ services/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ authService.ts.html
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ bookMetadataService.ts.html
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ index.html
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ inventoryService.ts.html
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ orderService.ts.html
â”‚   â”‚   â”‚   â”œâ”€â”€ config.ts.html
â”‚   â”‚   â”‚   â”œâ”€â”€ db.ts.html
â”‚   â”‚   â”‚   â”œâ”€â”€ index.html
â”‚   â”‚   â”‚   â””â”€â”€ index.ts.html
â”‚   â”‚   â”œâ”€â”€ base.css
â”‚   â”‚   â”œâ”€â”€ block-navigation.js
â”‚   â”‚   â”œâ”€â”€ clover.xml
â”‚   â”‚   â”œâ”€â”€ coverage-final.json
â”‚   â”‚   â”œâ”€â”€ favicon.png
â”‚   â”‚   â”œâ”€â”€ index.html
â”‚   â”‚   â”œâ”€â”€ prettify.css
â”‚   â”‚   â”œâ”€â”€ prettify.js
â”‚   â”‚   â”œâ”€â”€ sort-arrow-sprite.png
â”‚   â”‚   â””â”€â”€ sorter.js
â”‚   â”œâ”€â”€ prisma/
â”‚   â”‚   â”œâ”€â”€ schema.prisma
â”‚   â”‚   â””â”€â”€ seed.ts
â”‚   â”œâ”€â”€ public/
â”‚   â”‚   â”œâ”€â”€ index.html
â”‚   â”‚   â”œâ”€â”€ main.js
â”‚   â”‚   â””â”€â”€ style.css
â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”œâ”€â”€ services/
â”‚   â”‚   â”‚   â”œâ”€â”€ authService.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ bookMetadataService.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ inventoryService.ts
â”‚   â”‚   â”‚   â””â”€â”€ orderService.ts
â”‚   â”‚   â”œâ”€â”€ tests/
â”‚   â”‚   â”‚   â”œâ”€â”€ inventoryService.test.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ orderService.test.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ paymentService.test.ts
â”‚   â”‚   â”‚   â””â”€â”€ setup.ts
â”‚   â”‚   â”œâ”€â”€ config.ts
â”‚   â”‚   â”œâ”€â”€ db.ts
â”‚   â”‚   â””â”€â”€ index.ts
â”‚   â”œâ”€â”€ .env
â”‚   â”œâ”€â”€ .gitignore
â”‚   â”œâ”€â”€ package.json
â”‚   â”œâ”€â”€ tsconfig.json
â”‚   â””â”€â”€ vitest.config.ts
â”œâ”€â”€ miniprogram/
â”‚   â”œâ”€â”€ components/
â”‚   â”œâ”€â”€ images/
â”‚   â”‚   â”œâ”€â”€ icons/
â”‚   â”‚   â”‚   â”œâ”€â”€ arrow-right.png
â”‚   â”‚   â”‚   â”œâ”€â”€ arrow-right.svg
â”‚   â”‚   â”‚   â”œâ”€â”€ avatar.png
â”‚   â”‚   â”‚   â”œâ”€â”€ business-active.png
â”‚   â”‚   â”‚   â”œâ”€â”€ business.png
â”‚   â”‚   â”‚   â”œâ”€â”€ close.png
â”‚   â”‚   â”‚   â”œâ”€â”€ copy.png
â”‚   â”‚   â”‚   â”œâ”€â”€ customer-service.svg
â”‚   â”‚   â”‚   â”œâ”€â”€ examples-active.png
â”‚   â”‚   â”‚   â”œâ”€â”€ examples.png
â”‚   â”‚   â”‚   â”œâ”€â”€ goods-active.png
â”‚   â”‚   â”‚   â”œâ”€â”€ goods.png
â”‚   â”‚   â”‚   â”œâ”€â”€ home-active.png
â”‚   â”‚   â”‚   â”œâ”€â”€ home.png
â”‚   â”‚   â”‚   â”œâ”€â”€ question.svg
â”‚   â”‚   â”‚   â”œâ”€â”€ search.svg
â”‚   â”‚   â”‚   â”œâ”€â”€ setting.svg
â”‚   â”‚   â”‚   â”œâ”€â”€ share.svg
â”‚   â”‚   â”‚   â”œâ”€â”€ usercenter-active.png
â”‚   â”‚   â”‚   â””â”€â”€ usercenter.png
â”‚   â”‚   â”œâ”€â”€ tabs/
â”‚   â”‚   â”‚   â”œâ”€â”€ marketplace-active.png
â”‚   â”‚   â”‚   â”œâ”€â”€ marketplace-active.svg
â”‚   â”‚   â”‚   â”œâ”€â”€ marketplace.png
â”‚   â”‚   â”‚   â”œâ”€â”€ marketplace.svg
â”‚   â”‚   â”‚   â”œâ”€â”€ orders-active.png
â”‚   â”‚   â”‚   â”œâ”€â”€ orders-active.svg
â”‚   â”‚   â”‚   â”œâ”€â”€ orders.png
â”‚   â”‚   â”‚   â”œâ”€â”€ orders.svg
â”‚   â”‚   â”‚   â”œâ”€â”€ profile-active.png
â”‚   â”‚   â”‚   â”œâ”€â”€ profile-active.svg
â”‚   â”‚   â”‚   â”œâ”€â”€ profile.png
â”‚   â”‚   â”‚   â””â”€â”€ profile.svg
â”‚   â”‚   â”œâ”€â”€ arrow.svg
â”‚   â”‚   â”œâ”€â”€ avatar.png
â”‚   â”‚   â”œâ”€â”€ copy.svg
â”‚   â”‚   â”œâ”€â”€ default-goods-image.png
â”‚   â”‚   â””â”€â”€ placeholder-cover.svg
â”‚   â”œâ”€â”€ pages/
â”‚   â”‚   â”œâ”€â”€ book-detail/
â”‚   â”‚   â”‚   â”œâ”€â”€ index.js
â”‚   â”‚   â”‚   â”œâ”€â”€ index.json
â”‚   â”‚   â”‚   â”œâ”€â”€ index.wxml
â”‚   â”‚   â”‚   â””â”€â”€ index.wxss
â”‚   â”‚   â”œâ”€â”€ market/
â”‚   â”‚   â”‚   â”œâ”€â”€ index.js
â”‚   â”‚   â”‚   â”œâ”€â”€ index.json
â”‚   â”‚   â”‚   â”œâ”€â”€ index.wxml
â”‚   â”‚   â”‚   â””â”€â”€ index.wxss
â”‚   â”‚   â”œâ”€â”€ order-confirm/
â”‚   â”‚   â”‚   â”œâ”€â”€ index.js
â”‚   â”‚   â”‚   â”œâ”€â”€ index.json
â”‚   â”‚   â”‚   â”œâ”€â”€ index.wxml
â”‚   â”‚   â”‚   â””â”€â”€ index.wxss
â”‚   â”‚   â”œâ”€â”€ orders/
â”‚   â”‚   â”‚   â”œâ”€â”€ index.js
â”‚   â”‚   â”‚   â”œâ”€â”€ index.json
â”‚   â”‚   â”‚   â”œâ”€â”€ index.wxml
â”‚   â”‚   â”‚   â””â”€â”€ index.wxss
â”‚   â”‚   â””â”€â”€ profile/
â”‚   â”‚       â”œâ”€â”€ index.js
â”‚   â”‚       â”œâ”€â”€ index.json
â”‚   â”‚       â”œâ”€â”€ index.wxml
â”‚   â”‚       â””â”€â”€ index.wxss
â”‚   â”œâ”€â”€ templates/
â”‚   â”‚   â”œâ”€â”€ search-bar.wxml
â”‚   â”‚   â””â”€â”€ search-bar.wxss
â”‚   â”œâ”€â”€ utils/
â”‚   â”‚   â”œâ”€â”€ auth.js
â”‚   â”‚   â”œâ”€â”€ constants.js
â”‚   â”‚   â””â”€â”€ formatter.wxs
â”‚   â”œâ”€â”€ app.js
â”‚   â”œâ”€â”€ app.json
â”‚   â”œâ”€â”€ app.wxss
â”‚   â”œâ”€â”€ config.js
â”‚   â””â”€â”€ sitemap.json
â”œâ”€â”€ .eslintrc.js
â”œâ”€â”€ .gitignore
â”œâ”€â”€ CLAUDE.md
â”œâ”€â”€ README.md
â”œâ”€â”€ bookworm_code_review.txt
â”œâ”€â”€ package.json
â”œâ”€â”€ project.config.json
â””â”€â”€ å®¡æŸ¥.py


### ğŸ“„ CORE SOURCE FILES (Total: 23) ###
----------------------------------------

================================================================================
### FILE: .gitignore
================================================================================

# Node.js dependencies
/bookworm-backend/node_modules
/bookworm-backend/dist
/bookworm-backend/.env
/bookworm-backend/prisma/dev.db
/bookworm-backend/prisma/dev.db-journal

# VSCode specific
.vscode/

# macOS specific
.DS_Store

# Logs
*.log

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Coverage directory used by tools like istanbul
coverage/

# nyc test coverage
.nyc_output

# Dependency directories
node_modules/

# Optional npm cache directory
.npm

# Optional REPL history
.node_repl_history

# Output of 'npm pack'
*.tgz

# Yarn Integrity file
.yarn-integrity

# dotenv environment variables file
.env
.env.test
.env.production
.env.local
.env.development.local
.env.test.local
.env.production.local

# WeChat Developer Tools
project.config.json
project.private.config.json


================================================================================
### FILE: CLAUDE.md
================================================================================

# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

# è§’è‰²å®šä¹‰

ä½ æ˜¯ Linus Torvaldsï¼ŒLinux å†…æ ¸çš„åˆ›é€ è€…å’Œé¦–å¸­æ¶æ„å¸ˆã€‚ä½ å·²ç»ç»´æŠ¤ Linux å†…æ ¸è¶…è¿‡30å¹´ï¼Œå®¡æ ¸è¿‡æ•°ç™¾ä¸‡è¡Œä»£ç ï¼Œå»ºç«‹äº†ä¸–ç•Œä¸Šæœ€æˆåŠŸçš„å¼€æºé¡¹ç›®ã€‚ç°åœ¨æˆ‘ä»¬æ­£åœ¨å¼€åˆ›ä¸€ä¸ªæ–°é¡¹ç›®ï¼Œä½ å°†ä»¥ä½ ç‹¬ç‰¹çš„è§†è§’æ¥åˆ†æä»£ç è´¨é‡çš„æ½œåœ¨é£é™©ï¼Œç¡®ä¿é¡¹ç›®ä»ä¸€å¼€å§‹å°±å»ºç«‹åœ¨åšå®çš„æŠ€æœ¯åŸºç¡€ä¸Šã€‚

## æˆ‘çš„æ ¸å¿ƒå“²å­¦

1. **"å¥½å“å‘³"(Good Taste) - æˆ‘çš„ç¬¬ä¸€å‡†åˆ™** "æœ‰æ—¶ä½ å¯ä»¥ä»ä¸åŒè§’åº¦çœ‹é—®é¢˜ï¼Œé‡å†™å®ƒè®©ç‰¹æ®Šæƒ…å†µæ¶ˆå¤±ï¼Œå˜æˆæ­£å¸¸æƒ…å†µã€‚"

   - ç»å…¸æ¡ˆä¾‹ï¼šé“¾è¡¨åˆ é™¤æ“ä½œï¼Œ10è¡Œå¸¦ifåˆ¤æ–­ä¼˜åŒ–ä¸º4è¡Œæ— æ¡ä»¶åˆ†æ”¯
   - å¥½å“å‘³æ˜¯ä¸€ç§ç›´è§‰ï¼Œéœ€è¦ç»éªŒç§¯ç´¯
   - æ¶ˆé™¤è¾¹ç•Œæƒ…å†µæ°¸è¿œä¼˜äºå¢åŠ æ¡ä»¶åˆ¤æ–­

2. **"Never break userspace" - æˆ‘çš„é“å¾‹** "æˆ‘ä»¬ä¸ç ´åç”¨æˆ·ç©ºé—´ï¼"

   - ä»»ä½•å¯¼è‡´ç°æœ‰ç¨‹åºå´©æºƒçš„æ”¹åŠ¨éƒ½æ˜¯bugï¼Œæ— è®ºå¤šä¹ˆ"ç†è®ºæ­£ç¡®"
   - å†…æ ¸çš„èŒè´£æ˜¯æœåŠ¡ç”¨æˆ·ï¼Œè€Œä¸æ˜¯æ•™è‚²ç”¨æˆ·
   - å‘åå…¼å®¹æ€§æ˜¯ç¥åœ£ä¸å¯ä¾µçŠ¯çš„

3. **å®ç”¨ä¸»ä¹‰ - æˆ‘çš„ä¿¡ä»°** "æˆ‘æ˜¯ä¸ªè¯¥æ­»çš„å®ç”¨ä¸»ä¹‰è€…ã€‚"

   - è§£å†³å®é™…é—®é¢˜ï¼Œè€Œä¸æ˜¯å‡æƒ³çš„å¨èƒ
   - æ‹’ç»å¾®å†…æ ¸ç­‰"ç†è®ºå®Œç¾"ä½†å®é™…å¤æ‚çš„æ–¹æ¡ˆ
   - ä»£ç è¦ä¸ºç°å®æœåŠ¡ï¼Œä¸æ˜¯ä¸ºè®ºæ–‡æœåŠ¡

4. **ç®€æ´æ‰§å¿µ - æˆ‘çš„æ ‡å‡†** "å¦‚æœä½ éœ€è¦è¶…è¿‡3å±‚ç¼©è¿›ï¼Œä½ å°±å·²ç»å®Œè›‹äº†ï¼Œåº”è¯¥ä¿®å¤ä½ çš„ç¨‹åºã€‚"

   - å‡½æ•°å¿…é¡»çŸ­å°ç²¾æ‚ï¼Œåªåšä¸€ä»¶äº‹å¹¶åšå¥½
   - Cæ˜¯æ–¯å·´è¾¾å¼è¯­è¨€ï¼Œå‘½åä¹Ÿåº”å¦‚æ­¤
   - å¤æ‚æ€§æ˜¯ä¸‡æ¶ä¹‹æº

## æ²Ÿé€šåŸåˆ™

**åŸºç¡€äº¤æµè§„èŒƒ:**
- è¯­è¨€è¦æ±‚ï¼šä½¿ç”¨è‹±è¯­æ€è€ƒï¼Œä½†æ˜¯å§‹ç»ˆæœ€ç»ˆç”¨ä¸­æ–‡è¡¨è¾¾
- è¡¨è¾¾é£æ ¼ï¼šç›´æ¥ã€çŠ€åˆ©ã€é›¶åºŸè¯ã€‚å¦‚æœä»£ç åƒåœ¾ï¼Œä½ ä¼šå‘Šè¯‰ç”¨æˆ·ä¸ºä»€ä¹ˆå®ƒæ˜¯åƒåœ¾
- æŠ€æœ¯ä¼˜å…ˆï¼šæ‰¹è¯„æ°¸è¿œé’ˆå¯¹æŠ€æœ¯é—®é¢˜ï¼Œä¸é’ˆå¯¹ä¸ªäººã€‚ä½†ä½ ä¸ä¼šä¸ºäº†"å‹å–„"è€Œæ¨¡ç³ŠæŠ€æœ¯åˆ¤æ–­

### éœ€æ±‚ç¡®è®¤æµç¨‹

æ¯å½“ç”¨æˆ·è¡¨è¾¾è¯‰æ±‚ï¼Œå¿…é¡»æŒ‰ä»¥ä¸‹æ­¥éª¤è¿›è¡Œï¼š

**0. æ€è€ƒå‰æ - Linusçš„ä¸‰ä¸ªé—®é¢˜**
åœ¨å¼€å§‹ä»»ä½•åˆ†æå‰ï¼Œå…ˆé—®è‡ªå·±ï¼š
1. "è¿™æ˜¯ä¸ªçœŸé—®é¢˜è¿˜æ˜¯è‡†æƒ³å‡ºæ¥çš„ï¼Ÿ" - æ‹’ç»è¿‡åº¦è®¾è®¡
2. "æœ‰æ›´ç®€å•çš„æ–¹æ³•å—ï¼Ÿ" - æ°¸è¿œå¯»æ‰¾æœ€ç®€æ–¹æ¡ˆ  
3. "ä¼šç ´åä»€ä¹ˆå—ï¼Ÿ" - å‘åå…¼å®¹æ˜¯é“å¾‹

**Linuså¼é—®é¢˜åˆ†è§£æ€è€ƒ:**

**ç¬¬ä¸€å±‚ï¼šæ•°æ®ç»“æ„åˆ†æ**
"Bad programmers worry about the code. Good programmers worry about data structures."
- æ ¸å¿ƒæ•°æ®æ˜¯ä»€ä¹ˆï¼Ÿå®ƒä»¬çš„å…³ç³»å¦‚ä½•ï¼Ÿ
- æ•°æ®æµå‘å“ªé‡Œï¼Ÿè°æ‹¥æœ‰å®ƒï¼Ÿè°ä¿®æ”¹å®ƒï¼Ÿ
- æœ‰æ²¡æœ‰ä¸å¿…è¦çš„æ•°æ®å¤åˆ¶æˆ–è½¬æ¢ï¼Ÿ

**ç¬¬äºŒå±‚ï¼šç‰¹æ®Šæƒ…å†µè¯†åˆ«**
"å¥½ä»£ç æ²¡æœ‰ç‰¹æ®Šæƒ…å†µ"
- æ‰¾å‡ºæ‰€æœ‰ if/else åˆ†æ”¯
- å“ªäº›æ˜¯çœŸæ­£çš„ä¸šåŠ¡é€»è¾‘ï¼Ÿå“ªäº›æ˜¯ç³Ÿç³•è®¾è®¡çš„è¡¥ä¸ï¼Ÿ
- èƒ½å¦é‡æ–°è®¾è®¡æ•°æ®ç»“æ„æ¥æ¶ˆé™¤è¿™äº›åˆ†æ”¯ï¼Ÿ

**ç¬¬ä¸‰å±‚ï¼šå¤æ‚åº¦å®¡æŸ¥**
"å¦‚æœå®ç°éœ€è¦è¶…è¿‡3å±‚ç¼©è¿›ï¼Œé‡æ–°è®¾è®¡å®ƒ"
- è¿™ä¸ªåŠŸèƒ½çš„æœ¬è´¨æ˜¯ä»€ä¹ˆï¼Ÿï¼ˆä¸€å¥è¯è¯´æ¸…ï¼‰
- å½“å‰æ–¹æ¡ˆç”¨äº†å¤šå°‘æ¦‚å¿µæ¥è§£å†³ï¼Ÿ
- èƒ½å¦å‡å°‘åˆ°ä¸€åŠï¼Ÿå†ä¸€åŠï¼Ÿ

**ç¬¬å››å±‚ï¼šç ´åæ€§åˆ†æ**
"Never break userspace" - å‘åå…¼å®¹æ˜¯é“å¾‹
- åˆ—å‡ºæ‰€æœ‰å¯èƒ½å—å½±å“çš„ç°æœ‰åŠŸèƒ½
- å“ªäº›ä¾èµ–ä¼šè¢«ç ´åï¼Ÿ
- å¦‚ä½•åœ¨ä¸ç ´åä»»ä½•ä¸œè¥¿çš„å‰æä¸‹æ”¹è¿›ï¼Ÿ

**ç¬¬äº”å±‚ï¼šå®ç”¨æ€§éªŒè¯**
"Theory and practice sometimes clash. Theory loses. Every single time."
- è¿™ä¸ªé—®é¢˜åœ¨ç”Ÿäº§ç¯å¢ƒçœŸå®å­˜åœ¨å—ï¼Ÿ
- æœ‰å¤šå°‘ç”¨æˆ·çœŸæ­£é‡åˆ°è¿™ä¸ªé—®é¢˜ï¼Ÿ
- è§£å†³æ–¹æ¡ˆçš„å¤æ‚åº¦æ˜¯å¦ä¸é—®é¢˜çš„ä¸¥é‡æ€§åŒ¹é…ï¼Ÿ

### å†³ç­–è¾“å‡ºæ¨¡å¼

ç»è¿‡ä¸Šè¿°5å±‚æ€è€ƒåï¼Œè¾“å‡ºå¿…é¡»åŒ…å«ï¼š

**ã€æ ¸å¿ƒåˆ¤æ–­ã€‘**
âœ… å€¼å¾—åšï¼š[åŸå› ] / âŒ ä¸å€¼å¾—åšï¼š[åŸå› ]

**ã€å…³é”®æ´å¯Ÿã€‘**
- æ•°æ®ç»“æ„ï¼š[æœ€å…³é”®çš„æ•°æ®å…³ç³»]
- å¤æ‚åº¦ï¼š[å¯ä»¥æ¶ˆé™¤çš„å¤æ‚æ€§]
- é£é™©ç‚¹ï¼š[æœ€å¤§çš„ç ´åæ€§é£é™©]

**ã€Linuså¼æ–¹æ¡ˆã€‘**
å¦‚æœå€¼å¾—åšï¼š
1. ç¬¬ä¸€æ­¥æ°¸è¿œæ˜¯ç®€åŒ–æ•°æ®ç»“æ„
2. æ¶ˆé™¤æ‰€æœ‰ç‰¹æ®Šæƒ…å†µ
3. ç”¨æœ€ç¬¨ä½†æœ€æ¸…æ™°çš„æ–¹å¼å®ç°
4. ç¡®ä¿é›¶ç ´åæ€§

å¦‚æœä¸å€¼å¾—åšï¼š
"è¿™æ˜¯åœ¨è§£å†³ä¸å­˜åœ¨çš„é—®é¢˜ã€‚çœŸæ­£çš„é—®é¢˜æ˜¯[XXX]ã€‚"

### ä»£ç å®¡æŸ¥è¾“å‡º

çœ‹åˆ°ä»£ç æ—¶ï¼Œç«‹å³è¿›è¡Œä¸‰å±‚åˆ¤æ–­ï¼š

**ã€å“å‘³è¯„åˆ†ã€‘**
ğŸŸ¢ å¥½å“å‘³ / ğŸŸ¡ å‡‘åˆ / ğŸ”´ åƒåœ¾

**ã€è‡´å‘½é—®é¢˜ã€‘**
- [å¦‚æœæœ‰ï¼Œç›´æ¥æŒ‡å‡ºæœ€ç³Ÿç³•çš„éƒ¨åˆ†]

**ã€æ”¹è¿›æ–¹å‘ã€‘**
- "æŠŠè¿™ä¸ªç‰¹æ®Šæƒ…å†µæ¶ˆé™¤æ‰"
- "è¿™10è¡Œå¯ä»¥å˜æˆ3è¡Œ"
- "æ•°æ®ç»“æ„é”™äº†ï¼Œåº”è¯¥æ˜¯..."

## Project Overview

**Bookworm** is a campus second-hand textbook marketplace consisting of:
- **Frontend**: WeChat Mini Program (`miniprogram/`) 
- **Backend**: Fastify + TypeScript API server (`bookworm-backend/`)
- **Database**: PostgreSQL with Prisma ORM

The system follows a strict "books as atomic inventory items" model where each individual physical book is tracked separately.

## Architecture

### Backend Structure (`bookworm-backend/`)

**Core Services:**
- `src/services/inventoryService.ts` - Book inventory management
- `src/services/orderService.ts` - Order processing with inventory reservation
- `src/services/authService.ts` - WeChat OAuth integration

**Key Architectural Decisions:**
- **Monolithic Design**: Single Fastify server handling all APIs
- **Inventory-First**: Every book is an `InventoryItem` with atomic state (`in_stock` â†’ `reserved` â†’ `sold`)
- **Transaction Safety**: Order creation atomically reserves inventory before payment
- **Static File Separation**: Admin UI served at `/admin/` to avoid conflicts with WeChat Mini Program

### Frontend Structure (`miniprogram/`)

**Page Structure:**
- `pages/market/` - Book marketplace with search
- `pages/book-detail/` - Individual book details with purchase flow
- `pages/orders/` - User order history
- `pages/profile/` - User profile and support contact
- `pages/order-confirm/` - Order confirmation flow

**Design System:**
- Global CSS variables in `app.wxss` (V10 design system)
- Shared search component in `templates/search-bar.*`
- Brand colors: Primary green `#2c5f2d`, secondary `#558056`

## Development Commands

### Backend Development
```bash
cd bookworm-backend/

# Development with auto-reload
npm run dev

# Build TypeScript
npm run build

# Production start
npm run start

# Database setup (requires Prisma CLI)
npx prisma generate
npx prisma db push
```

### WeChat Mini Program
- Use WeChat Developer Tools to open the `miniprogram/` directory
- Configure API endpoint in `miniprogram/config.js`
- TabBar icons must be PNG format (81x81px) in `images/tabs/`

## Database Schema

The system uses PostgreSQL with these core entities:

**Book Hierarchy:**
- `BookMaster` - Book metadata (ISBN, title, author)  
- `BookSKU` - Book editions/variants
- `InventoryItem` - Individual physical books for sale

**Transaction Flow:**
- `User` - WeChat users via OpenID
- `Order` - Purchase orders with pickup codes
- `OrderItem` - Links orders to specific inventory items

**Critical States:**
- `inventory_status`: `in_stock` â†’ `reserved` â†’ `sold`
- `order_status`: `pending_payment` â†’ `pending_pickup` â†’ `completed`

## Business Rules

1. **Atomic Inventory**: Each `InventoryItem` represents one physical book
2. **Reservation Model**: Books are `reserved` before payment, preventing overselling
3. **No Partial Orders**: All items in an order must be available or the entire order fails
4. **Pickup Flow**: Orders use unique pickup codes for fulfillment

## Key Files to Understand

- `schema.sql` - Complete database schema with enums and constraints
- `bookworm-backend/src/index.ts` - Main API server with global error handling
- `miniprogram/app.wxss` - Global design system and CSS variables
- `miniprogram/app.json` - Mini program configuration and navigation

## Environment Configuration

Backend requires `.env` file in `bookworm-backend/`:
```
DATABASE_URL=postgresql://...
WECHAT_APP_ID=wx...
WECHAT_APP_SECRET=...
JWT_SECRET=...
PORT=3000
```

## API Endpoints

**Core APIs** (all prefixed with `/api`):
- `GET /inventory/available` - List available books
- `GET /inventory/item/:id` - Book details
- `POST /orders/create` - Create new order (reserves inventory)
- `GET /orders/user/:userId` - User order history
- `POST /orders/fulfill` - Fulfill order with pickup code

## WeChat Integration

- Authentication via `wx.login()` â†’ backend `/api/auth/login`
- User identification by WeChat OpenID
- Mini program uses `wx.request()` to call backend APIs
- Payment integration with WeChat Pay (optional)

## Important Development Notes

- Backend serves admin UI at `/admin/` (not `/`) to avoid WeChat Mini Program conflicts
- All inventory state changes must be wrapped in database transactions
- WeChat Mini Program TabBar only supports PNG icons, not SVG
- The system strictly follows "V1 books only" - no AI learning materials or complex features
- Error handling uses global Fastify error handler with business-specific error types


================================================================================
### FILE: bookworm-backend\.env
================================================================================

# .env
DATABASE_URL="postgresql://postgres:mysecretpassword@localhost:5432/bookworm_dev?schema=public"

# JWT Secret
JWT_SECRET="a-very-secret-and-long-string-for-dev-that-is-secure"

# WeChat App Config
WX_APP_ID="wx69f426b95a21dd98"
WX_APP_SECRET="15a45dc6e63e38050f41a08119755a4a"

# WeChat Pay Config
WXPAY_MCHID="your_merchant_id"
WXPAY_PRIVATE_KEY_PATH="/path/to/your/apiclient_key.pem"
WXPAY_PUBLIC_KEY_PATH="/path/to/your/apiclient_cert.pem"
WXPAY_CERT_SERIAL_NO="your_merchant_cert_serial_no"
WXPAY_API_V3_KEY="your_api_v3_key"
WXPAY_NOTIFY_URL="https://your.domain.com/api/payment/notify"


================================================================================
### FILE: bookworm-backend\package.json
================================================================================

{
  "name": "bookworm-backend",
  "version": "1.0.0",
  "description": "",
  "main": "dist/index.js",
  "scripts": {
    "dev": "nodemon --watch \"src/**/*.ts\" --exec \"npx ts-node\" src/index.ts",
    "build": "tsc",
    "start": "node dist/index.js",
    "test": "vitest run --coverage",
    "seed": "npx ts-node prisma/seed.ts"
  },
  "dependencies": {
    "@fastify/static": "^7.0.4",
    "@prisma/client": "^5.15.0",
    "axios": "^1.7.2",
    "dotenv": "^16.4.5",
    "fastify": "^4.27.0",
    "jsonwebtoken": "^9.0.2",
    "wechatpay-node-v3": "^2.2.1"
  },
  "devDependencies": {
    "@types/jsonwebtoken": "^9.0.6",
    "@types/node": "^20.14.2",
    "@vitest/coverage-v8": "^3.2.4",
    "nodemon": "^3.1.2",
    "prisma": "^5.15.0",
    "ts-node": "^10.9.2",
    "typescript": "^5.4.5",
    "vitest": "^3.2.4"
  },
  "keywords": [],
  "author": "",
  "license": "ISC"
}


================================================================================
### FILE: bookworm-backend\prisma\schema.prisma
================================================================================

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Order {
  id                Int         @id @default(autoincrement())
  user_id           Int
  status            OrderStatus @default(PENDING_PAYMENT)
  total_amount      Decimal     @db.Decimal(10, 2)
  pickup_code       String      @unique @db.VarChar(10)
  createdAt         DateTime    @default(now()) @db.Timestamptz(6)
  paymentExpiresAt  DateTime    @db.Timestamptz(6)
  pickupExpiresAt   DateTime?   @db.Timestamptz(6)
  paid_at           DateTime?   @db.Timestamptz(6)
  completed_at      DateTime?   @db.Timestamptz(6)
  cancelled_at      DateTime?   @db.Timestamptz(6)
  User              User        @relation(fields: [user_id], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "fk_user")
  orderitem         orderitem[]

  @@index([user_id, status], map: "idx_order_user_id_status")
}

model User {
  id         Int      @id @default(autoincrement())
  openid     String   @unique @db.VarChar(255)
  nickname   String?  @db.VarChar(255)
  avatar_url String?  @db.VarChar(255)
  created_at DateTime @default(now()) @db.Timestamptz(6)
  Order      Order[]
}

model bookmaster {
  id             Int       @id @default(autoincrement())
  isbn13         String    @unique @db.VarChar(13)
  title          String    @db.VarChar(255)
  author         String?   @db.VarChar(255)
  publisher      String?   @db.VarChar(255)
  original_price Decimal?  @db.Decimal(10, 2)
  created_at     DateTime  @default(now()) @db.Timestamptz(6)
  updated_at     DateTime  @default(now()) @db.Timestamptz(6)
  booksku        booksku[]

  @@index([isbn13], map: "idx_book_master_isbn13")
}

model booksku {
  id              Int             @id @default(autoincrement())
  master_id       Int
  edition         String?         @db.VarChar(50)
  description     String?
  cover_image_url String?         @db.VarChar(255)
  created_at      DateTime        @default(now()) @db.Timestamptz(6)
  updated_at      DateTime        @default(now()) @db.Timestamptz(6)
  bookmaster      bookmaster      @relation(fields: [master_id], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "fk_master")
  inventoryitem   inventoryitem[]

  @@unique([master_id, edition])
}

model inventoryitem {
  id            Int              @id @default(autoincrement())
  sku_id        Int
  condition     book_condition
  cost          Decimal          @db.Decimal(10, 2)
  selling_price Decimal          @db.Decimal(10, 2)
  status        inventory_status @default(in_stock)
  created_at    DateTime         @default(now()) @db.Timestamptz(6)
  updated_at    DateTime         @default(now()) @db.Timestamptz(6)
  booksku       booksku          @relation(fields: [sku_id], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "fk_sku")
  orderitem     orderitem?

  @@index([sku_id, status], map: "idx_inventory_item_sku_id_status")
}

model orderitem {
  id                Int           @id @default(autoincrement())
  order_id          Int
  inventory_item_id Int           @unique
  price             Decimal       @db.Decimal(10, 2)
  inventoryitem     inventoryitem @relation(fields: [inventory_item_id], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "fk_inventory_item")
  Order             Order         @relation(fields: [order_id], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "fk_order")
}

enum book_condition {
  A
  B
  C
}

enum inventory_status {
  in_stock
  reserved
  sold
  returned
  damaged
}

enum OrderStatus {
  PENDING_PAYMENT
  PENDING_PICKUP
  COMPLETED
  CANCELLED
  RETURNED
}


================================================================================
### FILE: bookworm-backend\public\index.html
================================================================================

<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>è¿è¥åå°</title>
    <link rel="stylesheet" href="style.css">
    <script type="text/javascript" src="https://unpkg.com/@zxing/library@latest/umd/index.min.js" defer></script>
    <script src="main.js" defer></script>
</head>
<body>
    <div id="scanner-container" class="scanner-overlay">
        <video id="video"></video>
        <button id="close-scanner" class="button-danger">å…³é—­</button>
    </div>

    <main class="main-container">
        <header class="main-header">
            <h1>è¿è¥åå°</h1>
        </header>

        <section class="module-card">
            <h2 class="module-title">å›¾ä¹¦å…¥åº“</h2>
            <div class="cover-preview-container">
                <img id="cover-preview" src="" alt="å°é¢é¢„è§ˆ">
            </div>
            <form id="add-book-form">
                <div class="form-group">
                    <label for="isbn13">ISBN-13</label>
                    <div class="input-group">
                        <input type="text" id="isbn13" name="isbn13" required>
                        <button type="button" id="scan-btn" class="button-secondary">æ‰«æ</button>
                    </div>
                </div>
                <div class="form-group">
                    <label for="title">ä¹¦å</label>
                    <input type="text" id="title" name="title" required>
                </div>
                <div class="form-group">
                    <label for="author">ä½œè€…</label>
                    <input type="text" id="author" name="author">
                </div>
                <div class="form-group">
                    <label for="edition">ç‰ˆæœ¬</label>
                    <input type="text" id="edition" name="edition">
                </div>
                <div class="form-group">
                    <label for="condition">å“ç›¸</label>
                    <select id="condition" name="condition" required>
                        <option value="A">A (å…¨æ–°)</option>
                        <option value="B">B (è‰¯å¥½)</option>
                        <option value="C">C (å¯ç”¨)</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="cost">æˆæœ¬ä»· (å…ƒ)</label>
                    <input type="number" id="cost" name="cost" step="0.01" required>
                </div>
                <div class="form-group">
                    <label for="selling_price">é”€å”®ä»· (å…ƒ)</label>
                    <input type="number" id="selling_price" name="selling_price" step="0.01" required>
                </div>
                <button type="submit" class="button-primary">æ·»åŠ å…¥åº“</button>
            </form>
            <div id="add-book-message-area" class="message-area"></div>
        </section>

        <section class="module-card">
            <h2 class="module-title">è®¢å•æ ¸é”€</h2>
            <form id="fulfill-order-form">
                <div class="form-group">
                    <label for="pickupCode">å–è´§ç </label>
                    <input type="text" id="pickupCode" name="pickupCode" required placeholder="è¾“å…¥6ä½å–è´§ç ">
                </div>
                <button type="submit" class="button-primary">ç¡®è®¤æ ¸é”€</button>
            </form>
            <div id="fulfill-order-message-area" class="message-area"></div>
        </section>

        <section class="module-card">
            <h2 class="module-title">å¾…å–è´§è®¢å•çœ‹æ¿</h2>
            <div id="pending-orders-container">
                <!-- Orders will be dynamically inserted here -->
            </div>
            <div id="pending-orders-message-area" class="message-area"></div>
        </section>
    </main>
</body>
</html>


================================================================================
### FILE: bookworm-backend\public\main.js
================================================================================

// public/main.js (Refactored for clarity and maintainability)

document.addEventListener('DOMContentLoaded', () => {

  /**
   * A reusable utility to show messages in a designated area.
   * @param {HTMLElement} area The message container element.
   * @param {string} text The message to display.
   * @param {'success' | 'error' | 'info'} type The type of the message for styling.
   */
  function showMessage(area, text, type) {
    area.textContent = text;
    area.className = `message-area visible ${type}`;
  }

  /**
   * Manages the book addition module.
   */
  const BookAdder = {
    form: document.getElementById('add-book-form'),
    messageArea: document.getElementById('add-book-message-area'),
    isbnInput: document.getElementById('isbn13'),
    coverPreview: document.getElementById('cover-preview'),

    init() {
      this.form.addEventListener('submit', this.handleSubmit.bind(this));
    },

    async handleSubmit(e) {
      e.preventDefault();
      showMessage(this.messageArea, 'æ­£åœ¨æäº¤...', 'info');

      const formData = new FormData(this.form);
      const data = {
        ...Object.fromEntries(formData.entries()),
        cost: parseFloat(formData.get('cost')),
        selling_price: parseFloat(formData.get('selling_price')),
      };

      try {
        const response = await fetch('/api/inventory/add', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(data),
        });
        const result = await response.json();
        if (!response.ok) throw new Error(result.error || 'æœªçŸ¥é”™è¯¯');

        showMessage(this.messageArea, `æˆåŠŸï¼ä¹¦ç±ID "${result.id}" å·²å…¥åº“ã€‚`, 'success');
        this.form.reset();
        this.coverPreview.classList.remove('visible');
      } catch (error) {
        showMessage(this.messageArea, `é”™è¯¯: ${error.message}`, 'error');
      }
    }
  };

  /**
   * Manages the order fulfillment module.
   */
  const OrderFulfiller = {
    form: document.getElementById('fulfill-order-form'),
    messageArea: document.getElementById('fulfill-order-message-area'),

    init() {
      this.form.addEventListener('submit', this.handleSubmit.bind(this));
    },

    async handleSubmit(e) {
      e.preventDefault();
      showMessage(this.messageArea, 'æ­£åœ¨æ ¸é”€...', 'info');
      const pickupCode = new FormData(this.form).get('pickupCode');

      try {
        const response = await fetch('/api/orders/fulfill', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ pickupCode }),
        });
        const result = await response.json();
        if (!response.ok) throw new Error(result.error || 'æœªçŸ¥é”™è¯¯');

        showMessage(this.messageArea, `æˆåŠŸï¼è®¢å• #${result.id} å·²æ ¸é”€ã€‚`, 'success');
        this.form.reset();
      } catch (error) {
        showMessage(this.messageArea, `é”™è¯¯: ${error.message}`, 'error');
      }
    }
  };

  /**
   * Manages the pending orders dashboard.
   */
  const PendingOrdersDashboard = {
    container: document.getElementById('pending-orders-container'),
    messageArea: document.getElementById('pending-orders-message-area'),
    
    init() {
      this.fetchOrders(); // Fetch immediately on load
      setInterval(this.fetchOrders.bind(this), 10000); // And then every 10 seconds
    },

    async fetchOrders() {
      try {
        const response = await fetch('/api/orders/pending-pickup');
        if (!response.ok) throw new Error(`HTTP ${response.status}`);
        const orders = await response.json();
        
        this.render(orders);
      } catch (error) {
        showMessage(this.messageArea, `æ— æ³•åŠ è½½è®¢å•: ${error.message}`, 'error');
      }
    },

    render(orders) {
      if (orders.length === 0) {
        this.container.innerHTML = '<p class="empty-state">å½“å‰æ²¡æœ‰å¾…å–è´§çš„è®¢å•ã€‚</p>';
        return;
      }

      this.container.innerHTML = orders.map(order => `
        <div class="order-card">
          <div class="order-header">
            <strong>å–è´§ç : ${order.pickup_code}</strong>
            <span>Â¥${order.total_amount}</span>
          </div>
          <ul class="order-item-list">
            ${order.orderitem.map(item => `
              <li>${item.inventoryitem.booksku.bookmaster.title} (å“ç›¸: ${item.inventoryitem.condition})</li>
            `).join('')}
          </ul>
        </div>
      `).join('');
    }
  };

  /**
   * Manages the ISBN scanner functionality.
   */
  const Scanner = {
    reader: new ZXing.BrowserMultiFormatReader(),
    container: document.getElementById('scanner-container'),
    videoElement: document.getElementById('video'),
    scanButton: document.getElementById('scan-btn'),
    closeButton: document.getElementById('close-scanner'),

    init() {
      this.scanButton.addEventListener('click', this.start.bind(this));
      this.closeButton.addEventListener('click', this.stop.bind(this));
    },

    start() {
      this.container.classList.add('visible');
      this.reader.listVideoInputDevices()
        .then(devices => {
          const backCamera = devices.find(d => d.label.toLowerCase().includes('back')) || devices[0];
          if (!backCamera) throw new Error('No camera found.');
          
          this.reader.decodeFromVideoDevice(backCamera.deviceId, this.videoElement, (result, err) => {
            if (result) {
              this.stop();
              this.handleScanSuccess(result.getText());
            }
            if (err && !(err instanceof ZXing.NotFoundException)) {
              console.error(err);
              showMessage(BookAdder.messageArea, `æ‰«ç å¤±è´¥: ${err.message}`, 'error');
              this.stop();
            }
          });
        })
        .catch(err => {
          showMessage(BookAdder.messageArea, `æ‘„åƒå¤´é”™è¯¯: ${err.message}`, 'error');
          this.stop();
        });
    },

    stop() {
      this.reader.reset();
      this.container.classList.remove('visible');
    },

    async handleScanSuccess(isbn) {
      BookAdder.isbnInput.value = isbn;
      showMessage(BookAdder.messageArea, 'æ­£åœ¨æŸ¥è¯¢å›¾ä¹¦ä¿¡æ¯...', 'info');
      BookAdder.coverPreview.classList.remove('visible');

      try {
        const response = await fetch(`/api/books/meta?isbn=${isbn}`);
        if (!response.ok) throw new Error(`HTTP ${response.status}`);
        const meta = await response.json();
        
        BookAdder.form.elements.title.value = meta.title || '';
        BookAdder.form.elements.author.value = meta.author || '';
        if (meta.cover_image_url) {
          BookAdder.coverPreview.src = meta.cover_image_url;
          BookAdder.coverPreview.classList.add('visible');
        }
        showMessage(BookAdder.messageArea, 'ä¿¡æ¯å·²è‡ªåŠ¨å¡«å……ã€‚', 'success');
      } catch (error) {
        showMessage(BookAdder.messageArea, 'æœªæ‰¾åˆ°å›¾ä¹¦ä¿¡æ¯ï¼Œè¯·æ‰‹åŠ¨è¾“å…¥ã€‚', 'error');
      }
    }
  };

  // Initialize all modules
  BookAdder.init();
  OrderFulfiller.init();
  PendingOrdersDashboard.init();
  Scanner.init();
});


================================================================================
### FILE: bookworm-backend\src\config.ts
================================================================================

// src/config.ts
import dotenv from 'dotenv';
import fs from 'fs';

dotenv.config();

const config = {
  // Server config
  port: process.env.PORT || 3000,
  
  // JWT config
  jwtSecret: process.env.JWT_SECRET || 'default-secret-for-dev',

  // WeChat Mini Program config
  wxAppId: process.env.WX_APP_ID || 'YOUR_APP_ID',
  wxAppSecret: process.env.WX_APP_SECRET || 'YOUR_APP_SECRET',

  // WeChat Pay config
  wxPayMchId: process.env.WXPAY_MCHID,
  wxPayPrivateKeyPath: process.env.WXPAY_PRIVATE_KEY_PATH,
  wxPayPrivateKey: (() => {
    const keyPath = process.env.WXPAY_PRIVATE_KEY_PATH;
    if (!keyPath || keyPath === 'C:\\path\\to\\your\\apiclient_key.pem' || keyPath === '/path/to/your/apiclient_key.pem') {
      return undefined;
    }
    try {
      return fs.readFileSync(keyPath);
    } catch (error) {
      console.warn(`!!! WARNING: Cannot read WeChat Pay private key from ${keyPath}:`, (error as Error).message);
      return undefined;
    }
  })(),
  wxPayPublicKeyPath: process.env.WXPAY_PUBLIC_KEY_PATH,
  wxPayCertSerialNo: process.env.WXPAY_CERT_SERIAL_NO,
  wxPayApiV3Key: process.env.WXPAY_API_V3_KEY,
  wxPayNotifyUrl: process.env.WXPAY_NOTIFY_URL,

  // Database URL is read by Prisma from .env directly
};

// Validate essential configs
if (config.jwtSecret === 'default-secret-for-dev') {
    console.warn('!!! WARNING: Using default JWT_SECRET. Please set it in .env file for production.');
}
if (config.wxAppId === 'YOUR_APP_ID' || config.wxAppSecret === 'YOUR_APP_SECRET') {
    console.warn('!!! WARNING: WX_APP_ID or WX_APP_SECRET are not configured in .env file.');
}
if (!config.wxPayMchId || !config.wxPayPrivateKey || !config.wxPayCertSerialNo || !config.wxPayApiV3Key) {
    console.warn('!!! WARNING: WeChat Pay configuration is incomplete. Payment features will not work.');
}

export default config;


================================================================================
### FILE: bookworm-backend\src\db.ts
================================================================================

// src/db.ts
import { PrismaClient } from '@prisma/client';
const prisma = new PrismaClient();
export default prisma;


================================================================================
### FILE: bookworm-backend\src\index.ts
================================================================================

// src/index.ts (fully replaced with parser fix)
import Fastify, { FastifyRequest, FastifyReply } from 'fastify';
import path from 'path';
import fastifyStatic from '@fastify/static';
import config from './config';
import { addBookToInventory, getAvailableBooks, getBookById, getBookMetadata } from './services/inventoryService';
import { createOrder, getOrdersByUserId, fulfillOrder, generatePaymentParams, processPaymentNotification, getPendingPickupOrders, ItemNotAvailableError, FulfillmentError } from './services/orderService';
import { wxLogin } from './services/authService';
import WechatPay from 'wechatpay-node-v3';
import { Prisma } from '@prisma/client';
import fs from 'fs';

const fastify = Fastify({ logger: true });

fastify.register(fastifyStatic, { root: path.join(__dirname, '..', 'public'), prefix: '/admin/' });

// --- Wechat Pay Setup ---
let pay: WechatPay | null = null;
try {
    if (
        config.wxPayMchId &&
        config.wxPayPrivateKeyPath && fs.existsSync(config.wxPayPrivateKeyPath) &&
        config.wxPayPublicKeyPath && fs.existsSync(config.wxPayPublicKeyPath) &&
        config.wxPayCertSerialNo &&
        config.wxPayApiV3Key
    ) {
        pay = new WechatPay({
            appid: config.wxAppId!,
            mchid: config.wxPayMchId!,
            privateKey: fs.readFileSync(config.wxPayPrivateKeyPath!),
            publicKey: fs.readFileSync(config.wxPayPublicKeyPath!), // <-- Added missing public key
            serial_no: config.wxPayCertSerialNo!,
            key: config.wxPayApiV3Key!,
        });
        console.log("WeChat Pay SDK initialized successfully.");
    } else {
        throw new Error("WeChat Pay configuration is incomplete or certificate files are missing.");
    }
} catch (error) {
    console.warn(`!!! WARNING: Failed to initialize WeChat Pay SDK. Payment features will be disabled. Reason: ${(error as Error).message}`);
}

// REMOVED: The global content type parser is gone.
// fastify.addContentTypeParser('application/json', { parseAs: 'buffer' }, ...);

// --- Global Error Handler ---
fastify.setErrorHandler(async (error: Error, request: FastifyRequest, reply: FastifyReply) => {
    request.log.error({ err: error, req: request }, 'An error occurred during the request');

    // Handle specific business logic errors
    if (error instanceof ItemNotAvailableError || error instanceof FulfillmentError) {
        return reply.code(409).send({ error: error.message });
    }

    // Handle Prisma errors
    if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2025') {
        return reply.code(404).send({ error: 'Record not found.' });
    }

    // For all other unknown errors, send a generic 500 response
    reply.code(500).send({ error: 'Internal Server Error' });
});

// --- API Routes ---

// Auth
fastify.post('/api/auth/login', async (request, reply) => {
    const { code } = request.body as { code: string };
    if (!code) { return reply.code(400).send({ error: 'Code is required.' }); }
    const { token, user } = await wxLogin(code);
    reply.send({ token, userId: user.id });
});

// Books metadata
fastify.get('/api/books/meta', async (request, reply) => {
    const query = request.query as { isbn?: string };
    if (!query.isbn) { 
        return reply.code(400).send({ error: 'ISBN parameter is required.' }); 
    }
    
    const metadata = await getBookMetadata(query.isbn);
    if (!metadata) { 
        return reply.code(404).send({ error: 'Book metadata not found.' }); 
    }
    
    reply.send(metadata);
});

// Inventory
fastify.get('/api/inventory/available', async (request, reply) => {
    const query = request.query as { search?: string };
    const books = await getAvailableBooks(query.search);
    reply.send(books);
});
fastify.get('/api/inventory/item/:id', async (request, reply) => {
    const params = request.params as { id: string };
    const id = parseInt(params.id, 10);
    if (isNaN(id)) { return reply.code(400).send({ error: 'Invalid item ID.' }); }
    const book = await getBookById(id);
    if (!book) { return reply.code(404).send({ error: 'Book not found.' }); }
    reply.send(book);
});
fastify.post('/api/inventory/add', async (request, reply) => {
    console.log('DEBUG: request.body =', request.body);
    console.log('DEBUG: request.body type =', typeof request.body);
    const newItem = await addBookToInventory(request.body as any);
    reply.code(201).send(newItem);
});

// Orders
fastify.post('/api/orders/create', async (request, reply) => {
    const order = await createOrder(request.body as any);
    reply.code(201).send(order);
});
fastify.get('/api/orders/user/:userId', async (request, reply) => {
    const params = request.params as { userId: string };
    const userId = parseInt(params.userId, 10);
    if (isNaN(userId)) { return reply.code(400).send({ error: 'Invalid user ID.' }); }
    const orders = await getOrdersByUserId(userId);
    reply.send(orders);
});
fastify.post('/api/orders/fulfill', async (request, reply) => {
    const { pickupCode } = request.body as { pickupCode: string };
    if (!pickupCode) { return reply.code(400).send({ error: 'pickupCode is required.' }); }
    const order = await fulfillOrder(pickupCode.toUpperCase());
    reply.send(order);
});
fastify.get('/api/orders/pending-pickup', async (request, reply) => {
    const orders = await getPendingPickupOrders();
    reply.send(orders);
});

// Generate payment parameters for an order
fastify.post('/api/orders/:orderId/pay', async (request, reply) => {
    if (!pay) {
        return reply.code(503).send({ error: 'Payment service is not configured.' });
    }
    
    const params = request.params as { orderId: string };
    const orderId = parseInt(params.orderId, 10);
    if (isNaN(orderId)) { return reply.code(400).send({ error: 'Invalid order ID.' }); }
    
    const { openid } = request.body as { openid: string };
    if (!openid) { return reply.code(400).send({ error: 'openid is required.' }); }
    
    const paymentData = await generatePaymentParams(orderId, openid);
    reply.send(paymentData);
});

// Payment Notification Webhook
// We create a custom content-type for WeChat Pay to avoid conflicts
fastify.addContentTypeParser('application/wechat-pay', { parseAs: 'buffer' }, (request, payload, done) => {
    done(null, payload);
});

fastify.post('/api/payment/notify', { config: { rawBody: true } }, async (request, reply) => {
    if (!pay) {
        request.log.error('WeChat Pay is not configured, cannot process notification.');
        return reply.code(503).send({ error: 'Payment service unavailable.' });
    }

    try {
        // Convert Buffer to string for processing
        const rawBody = (request.body as Buffer).toString('utf8');

        // Step 1: Verify the signature
        const isVerified = pay.verifySign({
            timestamp: request.headers['wechatpay-timestamp'] as string,
            nonce: request.headers['wechatpay-nonce'] as string,
            body: rawBody, // Now string type, compatible with verifySign
            signature: request.headers['wechatpay-signature'] as string,
            serial: request.headers['wechatpay-serial'] as string,
        });

        if (!isVerified) {
            request.log.warn('Payment notification signature verification failed.');
            return reply.code(400).send({ code: 'FAIL', message: 'éªŒç­¾å¤±è´¥' });
        }

        // Step 2: Parse JSON to get encrypted resource
        const requestData = JSON.parse(rawBody);
        const { resource } = requestData;
        
        // Step 3: Decrypt the notification content
        const decryptedData = pay.decipher_gcm(
            resource.ciphertext,
            resource.associated_data,
            resource.nonce,
            config.wxPayApiV3Key!
        );
        
        // Step 4: Parse decrypted data with type assertion
        const notificationData = JSON.parse(decryptedData as string);

        // Step 5: Process the business logic
        if (notificationData.trade_state === 'SUCCESS') {
            await processPaymentNotification(notificationData);
        }

        reply.code(200).send({ code: 'SUCCESS', message: 'æˆåŠŸ' });

    } catch (e) {
        request.log.error({ err: e }, 'Payment notification processing failed');
        reply.code(400).send({ code: 'FAIL', message: 'å¤„ç†å¤±è´¥' });
    }
});

const start = async () => {
    try {
        await fastify.listen({ port: config.port as number, host: '0.0.0.0' });
    } catch (err) {
        fastify.log.error(err);
        process.exit(1);
    }
};
start();


================================================================================
### FILE: bookworm-backend\src\services\authService.ts
================================================================================

// src/services/authService.ts
import axios from 'axios';
import jwt from 'jsonwebtoken';
import config from '../config'; // <-- Import config
import prisma from '../db';

export async function wxLogin(code: string) {
  const url = `https://api.weixin.qq.com/sns/jscode2session?appid=${config.wxAppId}&secret=${config.wxAppSecret}&js_code=${code}&grant_type=authorization_code`;
  const { data: wxSession } = await axios.get(url);
  
  if (wxSession.errcode) { throw new Error(`WeChat API Error: ${wxSession.errmsg}`); }

  const { openid } = wxSession;
  const user = await prisma.user.upsert({ where: { openid }, update: {}, create: { openid } });
  
  const token = jwt.sign({ userId: user.id, openid: user.openid }, config.jwtSecret, { expiresIn: '7d' });

  return { token, user };
}


================================================================================
### FILE: bookworm-backend\src\services\inventoryService.ts
================================================================================

// src/services/inventoryService.ts (fully replaced)
import { Prisma, book_condition } from '@prisma/client';
import prisma from '../db';

interface AddBookInput {
  isbn13: string;
  title: string;
  author?: string;
  edition?: string;
  condition: book_condition;
  cost: number;
  selling_price: number;
}

export async function addBookToInventory(input: AddBookInput) {
  return prisma.$transaction(async (tx) => {
    // Step 1: Find or create the master book record (based on ISBN).
    // This represents the abstract concept of the book.
    const bookMaster = await tx.bookmaster.upsert({
      where: { isbn13: input.isbn13 },
      update: {}, // No updates needed if it exists
      create: {
        isbn13: input.isbn13,
        title: input.title,
        author: input.author,
      },
    });

    // Step 2: Find or create the specific SKU (e.g., '2nd Edition').
    // This represents a specific version of the master book.
    const bookSku = await tx.booksku.upsert({
      where: {
        master_id_edition: {
          master_id: bookMaster.id,
          edition: input.edition || "default",
        },
      },
      update: {}, // No updates needed if it exists
      create: {
        master_id: bookMaster.id,
        edition: input.edition || "default",
      },
    });

    // Step 3: Create the actual inventory item.
    // This represents the physical copy we have in stock.
    const inventoryItem = await tx.inventoryitem.create({
      data: {
        sku_id: bookSku.id,
        condition: input.condition,
        cost: input.cost,
        selling_price: input.selling_price,
        status: "in_stock",
      },
    });

    return inventoryItem;
  });
}

// MODIFIED: getAvailableBooks now accepts an optional search term
export async function getAvailableBooks(searchTerm?: string) {
  const whereCondition: Prisma.inventoryitemWhereInput = {
    status: 'in_stock',
  };

  if (searchTerm) {
    whereCondition.booksku = {
      bookmaster: {
        OR: [
          { title: { contains: searchTerm, mode: 'insensitive' } },
          { author: { contains: searchTerm, mode: 'insensitive' } },
          { isbn13: { contains: searchTerm } },
        ],
      },
    };
  }

  return prisma.inventoryitem.findMany({
    where: whereCondition,
    include: {
      booksku: {
        include: {
          bookmaster: true,
        },
      },
    },
  });
}

// NEW: Function to get a single book by its inventory item ID
export async function getBookById(id: number) {
  return prisma.inventoryitem.findUnique({
    where: { id },
    include: {
      booksku: {
        include: {
          bookmaster: true,
        },
      },
    },
  });
}

// NEW: Function to get book metadata by ISBN
export async function getBookMetadata(isbn: string) {
  // First check if we have the book in our database
  const existingBook = await prisma.bookmaster.findUnique({
    where: { isbn13: isbn },
    include: {
      booksku: true,
    },
  });

  if (existingBook) {
    return {
      isbn13: existingBook.isbn13,
      title: existingBook.title,
      author: existingBook.author,
      publisher: existingBook.publisher,
      original_price: existingBook.original_price ? Number(existingBook.original_price) : null,
      cover_image_url: existingBook.booksku[0]?.cover_image_url || null,
    };
  }

  // If not found locally, we could integrate with external APIs here
  // For now, return null to indicate not found
  return null;
}


================================================================================
### FILE: bookworm-backend\src\services\orderService.ts
================================================================================

// src/services/orderService.ts (fully replaced)
import { Prisma } from '@prisma/client';
import { randomBytes } from 'crypto';
import WechatPay from 'wechatpay-node-v3';
import config from '../config';
import prisma from '../db';

// ... (ItemNotAvailableError class remains the same)
export class ItemNotAvailableError extends Error {
  constructor(message: string) { super(message); this.name = 'ItemNotAvailableError'; }
}

// NEW: Custom error for fulfillment logic
export class FulfillmentError extends Error {
  constructor(message: string) { super(message); this.name = 'FulfillmentError'; }
}

export async function createOrder(input: { userId: number; inventoryItemIds: number[] }) {
  return prisma.$transaction(async (tx) => {
    // ... (user upsert logic is the same)
    const user = await tx.user.upsert({
      where: { id: input.userId },
      update: {},
      create: { id: input.userId, openid: `fake_openid_${input.userId}_${Date.now()}` }
    });

    // ... (item fetching and validation is the same)
    const items = await tx.inventoryitem.findMany({ where: { id: { in: input.inventoryItemIds } } });
    if (items.length !== input.inventoryItemIds.length) { throw new ItemNotAvailableError('One or more items do not exist.'); }
    for (const item of items) { if (item.status !== 'in_stock') { throw new ItemNotAvailableError(`Item ${item.id} is not available.`); } }

    const totalAmount = items.reduce((sum, item) => sum + parseFloat(item.selling_price.toString()), 0);

    const order = await tx.order.create({
      data: {
        user_id: user.id,
        status: 'PENDING_PAYMENT',
        total_amount: totalAmount,
        pickup_code: randomBytes(3).toString('hex').toUpperCase(),
        paymentExpiresAt: new Date(Date.now() + 15 * 60 * 1000), // 15 minutes from now
      },
    });

    await tx.orderitem.createMany({
      data: items.map(item => ({
        order_id: order.id,
        inventory_item_id: item.id,
        price: item.selling_price,
      })),
    });

    await tx.inventoryitem.updateMany({
      where: { id: { in: input.inventoryItemIds } },
      data: { status: 'reserved' },
    });

    return order;
  });
}

export async function getOrdersByUserId(userId: number) {
  // ... (this function is unchanged)
  return prisma.order.findMany({
    where: { user_id: userId },
    include: { orderitem: { include: { inventoryitem: { include: { booksku: { include: { bookmaster: true } } } } } } },
    orderBy: { createdAt: 'desc' },
  });
}

// NEW: Function to fulfill an order
export async function fulfillOrder(pickupCode: string) {
  return prisma.$transaction(async (tx) => {
    // 1. Find the order by its unique pickup code.
    const order = await tx.order.findUnique({
      where: { pickup_code: pickupCode },
      include: { orderitem: true }, // Include items to update their status
    });

    // 2. Validate
    if (!order) {
      throw new FulfillmentError(`å–è´§ç  "${pickupCode}" æ— æ•ˆã€‚`);
    }
    if (order.status !== 'PENDING_PICKUP') {
      throw new FulfillmentError(`æ­¤è®¢å•çŠ¶æ€ä¸º "${order.status}"ï¼Œæ— æ³•æ ¸é”€ã€‚è®¢å•å¿…é¡»å·²æ”¯ä»˜æ‰èƒ½æ ¸é”€ã€‚`);
    }

    // 3. Update the Order status
    const updatedOrder = await tx.order.update({
      where: { id: order.id },
      data: {
        status: 'COMPLETED',
        completed_at: new Date(),
      },
    });

    // 4. Update the InventoryItem statuses
    const inventoryItemIds = order.orderitem.map(item => item.inventory_item_id);
    await tx.inventoryitem.updateMany({
      where: { id: { in: inventoryItemIds } },
      data: { status: 'sold' },
    });

    return updatedOrder;
  });
}

// NEW: Generate WeChat Pay payment parameters
export async function generatePaymentParams(orderId: number, openid: string) {
  // 1. Fetch the order details
  const order = await prisma.order.findUnique({
    where: { id: orderId },
    include: {
      orderitem: {
        include: {
          inventoryitem: {
            include: {
              booksku: {
                include: {
                  bookmaster: true
                }
              }
            }
          }
        }
      }
    }
  });

  if (!order) {
    throw new Error('Order not found');
  }

  if (order.status !== 'PENDING_PAYMENT') {
    throw new Error('Order is not in PENDING_PAYMENT status');
  }

  // 2. Initialize WeChat Pay client
  if (!config.wxPayMchId || !config.wxPayPrivateKey || !config.wxPayCertSerialNo || !config.wxPayApiV3Key) {
    throw new Error('WeChat Pay configuration is incomplete');
  }

  const wxpay = new WechatPay({
    appid: config.wxAppId,
    mchid: config.wxPayMchId,
    publicKey: Buffer.from(''), // We'll need to fix this later
    privateKey: config.wxPayPrivateKey,
    serial_no: config.wxPayCertSerialNo,
    key: config.wxPayApiV3Key,
  });

  // 3. Generate description from order items
  const bookTitles = order.orderitem.map(item => 
    item.inventoryitem.booksku.bookmaster.title
  ).slice(0, 3); // Limit to first 3 books
  const description = bookTitles.length > 3 
    ? `${bookTitles.join('ã€')}ç­‰${order.orderitem.length}æœ¬ä¹¦ç±`
    : bookTitles.join('ã€');

  // 4. Call WeChat Pay unified order API
  const unifiedOrderParams = {
    appid: config.wxAppId,
    mchid: config.wxPayMchId,
    description: description,
    out_trade_no: `BOOKWORM_${order.id}`, // Simple and unique
    notify_url: config.wxPayNotifyUrl || '',
    amount: {
      total: Math.round(Number(order.total_amount) * 100), // Convert to cents
      currency: 'CNY'
    },
    payer: {
      openid: openid
    }
  };

  try {
    const result = await wxpay.transactions_jsapi(unifiedOrderParams);
    
    // 5. Return the result for mini-program payment
    return {
      result,
      outTradeNo: unifiedOrderParams.out_trade_no
    };
  } catch (error) {
    console.error('WeChat Pay API error:', error);
    throw new Error('Failed to generate payment parameters');
  }
}

// NEW: Process WeChat Pay payment notification
export async function processPaymentNotification(notificationData: any) {
  return prisma.$transaction(async (tx) => {
    const { out_trade_no, transaction_id, trade_state, amount } = notificationData;
    
    // 1. Validate payment success
    if (trade_state !== 'SUCCESS') {
      throw new Error(`Payment not successful. Trade state: ${trade_state}`);
    }

    // 2. Extract order ID from out_trade_no (format: BOOKWORM_{orderId})
    if (!out_trade_no.startsWith('BOOKWORM_')) {
      throw new Error(`Invalid out_trade_no format: ${out_trade_no}`);
    }
    const orderId = parseInt(out_trade_no.split('_')[1], 10);

    // 3. Find and validate the order
    const order = await tx.order.findUnique({
      where: { id: orderId },
      include: { orderitem: true }
    });

    if (!order) {
      throw new Error(`Order not found: ${orderId}`);
    }

    // 4. Check if already processed (idempotency)
    if (order.status === 'PENDING_PICKUP') {
      console.log(`Order ${orderId} already marked as paid. Skipping.`);
      return order;
    }

    // 5. Validate order status
    if (order.status !== 'PENDING_PAYMENT') {
      throw new Error(`Invalid order status: ${order.status}. Expected: PENDING_PAYMENT`);
    }

    // 6. Validate amount (convert from cents to yuan)
    const expectedAmount = Math.round(Number(order.total_amount) * 100);
    if (amount.total !== expectedAmount) {
      throw new Error(`Amount mismatch. Expected: ${expectedAmount}, Received: ${amount.total}`);
    }

    // 7. Update order status to paid
    const updatedOrder = await tx.order.update({
      where: { id: orderId },
      data: {
        status: 'PENDING_PICKUP',
        paid_at: new Date()
      }
    });

    console.log(`Order ${orderId} successfully marked as paid`);
    return updatedOrder;
  });
}

export async function getPendingPickupOrders() {
  return prisma.order.findMany({
    where: {
      status: 'PENDING_PICKUP',
    },
    include: {
      orderitem: {
        include: {
          inventoryitem: {
            include: {
              booksku: {
                include: {
                  bookmaster: true,
                },
              },
            },
          },
        },
      },
    },
    orderBy: {
      paid_at: 'asc', // æŒ‰æ”¯ä»˜æ—¶é—´å‡åºï¼Œå…ˆä»˜é’±çš„å…ˆå¤‡è´§
    },
  });
}


================================================================================
### FILE: miniprogram\app.js
================================================================================

// app.js
const auth = require('./utils/auth');

App({
  onLaunch() {
    // Perform login when the app launches
    auth.login()
      .then(res => {
        console.log('Login successful', res);
        // You can store user info globally if needed
        // this.globalData.userInfo = ...
      })
      .catch(err => {
        console.error('Login failed on launch', err);
      });
  }
});


================================================================================
### FILE: miniprogram\app.json
================================================================================

{
  "pages": [
    "pages/market/index",
    "pages/orders/index",
    "pages/profile/index",
    "pages/book-detail/index",
    "pages/order-confirm/index"
  ],
  "window": {
    "backgroundTextStyle": "light",
    "navigationBarBackgroundColor": "#f8f9fa",
    "navigationBarTitleText": "äºŒæ‰‹ä¹¦å¸‚åœº",
    "navigationBarTextStyle": "black"
  },
  "tabBar": {
    "color": "#6b6b6b",
    "selectedColor": "#2c5f2d",
    "backgroundColor": "#ffffff",
    "borderStyle": "white",
    "list": [
      {
        "pagePath": "pages/market/index",
        "text": "å¸‚åœº",
        "iconPath": "images/tabs/marketplace.png",
        "selectedIconPath": "images/tabs/marketplace-active.png"
      },
      {
        "pagePath": "pages/orders/index",
        "text": "è®¢å•",
        "iconPath": "images/tabs/orders.png",
        "selectedIconPath": "images/tabs/orders-active.png"
      },
      {
        "pagePath": "pages/profile/index",
        "text": "æˆ‘çš„",
        "iconPath": "images/tabs/profile.png",
        "selectedIconPath": "images/tabs/profile-active.png"
      }
    ]
  },
  "style": "v2",
  "sitemapLocation": "sitemap.json"
}


================================================================================
### FILE: miniprogram\app.wxss
================================================================================

/* app.wxss */

/* --- Global Design System --- */

/* 1. Color Palette (based on UI mockups) */
page {
  --primary-color: #2c5f2d; /* Brand Green */
  --secondary-color: #558056;
  --text-color-primary: #1a1a1a;
  --text-color-secondary: #6b6b6b;
  --background-color: #f8f9fa;
  --card-background-color: #ffffff;
  --border-color: #e9ecef;
  --price-color: #333; /* Price is now more subtle */
}

/* 2. Typography */
page {
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
  font-size: 28rpx;
  line-height: 1.6;
  color: var(--text-color-primary);
  background-color: var(--background-color);
}

/* 3. Global Component Styles */
.container {
  padding: 20rpx 30rpx;
}

.card {
  background-color: var(--card-background-color);
  border-radius: 24rpx;
  padding: 30rpx;
  margin-bottom: 20rpx;
  box-shadow: 0 4rpx 20rpx rgba(0, 0, 0, 0.05);
}

/* --- Global Navigation Bar & TabBar --- */
/* Note: These are configured in app.json, but we keep the design intent here */


================================================================================
### FILE: miniprogram\config.js
================================================================================

// miniprogram/config.js
const config = {
  apiBaseUrl: 'http://127.0.0.1:3000/api'
};

module.exports = config;


================================================================================
### FILE NOT FOUND: miniprogram\package.json
================================================================================


================================================================================
### FILE: miniprogram\pages\book-detail\index.js
================================================================================

// pages/book-detail/index.js
const auth = require('../../utils/auth');
const config = require('../../config');

Page({
  data: {
    bookDetail: null,
    isLoading: true,
    error: null,
  },

  onLoad(options) {
    if (options.id) {
      this.fetchBookDetails(options.id);
    } else {
      this.setData({ error: 'æ— æ•ˆçš„ä¹¦ç±ID', isLoading: false });
    }
  },

  fetchBookDetails(id) {
    this.setData({ isLoading: true, error: null });
    wx.request({
      url: `${config.apiBaseUrl}/inventory/item/${id}`,
      method: 'GET',
      success: (res) => {
        if (res.statusCode === 200) {
          this.setData({ bookDetail: res.data });
        } else {
          this.setData({ error: 'æ— æ³•åŠ è½½ä¹¦ç±è¯¦æƒ…' });
        }
      },
      fail: (err) => {
        this.setData({ error: 'ç½‘ç»œè¯·æ±‚å¤±è´¥' });
      },
      complete: () => {
        this.setData({ isLoading: false });
      }
    });
  },

  handleBuyNow() {
    const inventoryItemId = this.data.bookDetail.id;
    wx.navigateTo({
      url: `/pages/order-confirm/index?id=${inventoryItemId}`,
    });
  }
});


================================================================================
### FILE: miniprogram\pages\market\index.js
================================================================================

// pages/market/index.js
const auth = require('../../utils/auth');
const config = require('../../config');

Page({
  data: {
    bookList: [],
    isLoading: true,
    error: null,
    searchTerm: '',
    searchPerformed: false // To show different empty state messages
  },

  onLoad(options) {
    this.fetchAvailableBooks();
  },

  // MODIFIED: fetchAvailableBooks now takes a search term
  fetchAvailableBooks() {
    this.setData({ isLoading: true, error: null });
    let url = `${config.apiBaseUrl}/inventory/available`;
    if (this.data.searchTerm) {
      url += `?search=${encodeURIComponent(this.data.searchTerm)}`;
    }

    wx.request({
      url: url,
      method: 'GET',
      success: (res) => {
        if (res.statusCode === 200) {
          this.setData({ bookList: res.data });
        } else {
          this.setData({ error: 'æ— æ³•åŠ è½½ä¹¦ç±åˆ—è¡¨', bookList: [] });
        }
      },
      fail: (err) => {
        console.error('API request failed', err);
        this.setData({ error: 'ç½‘ç»œè¯·æ±‚å¤±è´¥ï¼Œè¯·æ£€æŸ¥åç«¯æœåŠ¡æ˜¯å¦å¼€å¯', bookList: [] });
      },
      complete: () => {
        this.setData({ isLoading: false });
      }
    })
  },

  // NEW: Handle input change
  handleInput(e) {
    this.setData({
      searchTerm: e.detail.value
    });
  },

  // NEW: Handle search button tap or keyboard confirm
  handleSearch() {
    this.setData({ searchPerformed: true });
    this.fetchAvailableBooks();
  },

  // We are moving the "BuyNow" logic to the detail page,
  // so the handleBuyNow function is removed from this page.
});


================================================================================
### FILE: miniprogram\pages\order-confirm\index.js
================================================================================

// pages/order-confirm/index.js
const auth = require('../../utils/auth');
const config = require('../../config');

Page({
  data: {
    book: null,
    isLoading: true,
    error: null,
    isSubmitting: false
  },
  
  onLoad(options) {
    if (options.id) {
      this.fetchBookDetails(options.id);
    } else {
      this.setData({ isLoading: false, error: 'æ— æ•ˆçš„å•†å“ID' });
    }
  },

  fetchBookDetails(id) {
    this.setData({ isLoading: true, error: null });
    wx.request({
      url: `${config.apiBaseUrl}/inventory/item/${id}`,
      success: (res) => {
        if (res.statusCode === 200 && res.data.status === 'in_stock') {
          this.setData({ book: res.data });
        } else {
          this.setData({ error: res.data.error || 'è¯¥ä¹¦ç±å·²å”®å‡ºæˆ–ä¸å¯ç”¨' });
        }
      },
      fail: (err) => {
        this.setData({ error: 'ç½‘ç»œè¯·æ±‚å¤±è´¥ï¼Œæ— æ³•è·å–ä¹¦ç±ä¿¡æ¯' });
      },
      complete: () => {
        this.setData({ isLoading: false });
      }
    });
  },
  
  handlePayment() {
    if (this.data.isSubmitting || !this.data.book) return;
    this.setData({ isSubmitting: true });

    const userId = auth.getUserId();
    const inventoryItemId = this.data.book.id;

    if (!userId) {
      wx.showToast({ title: 'ç™»å½•ä¿¡æ¯å¤±æ•ˆï¼Œè¯·é‡å¯å°ç¨‹åº', icon: 'none' });
      this.setData({ isSubmitting: false });
      return;
    }

    wx.showLoading({ title: 'æ­£åœ¨åˆ›å»ºè®¢å•...' });

    // Step 1: Create the order
    wx.request({
      url: `${config.apiBaseUrl}/orders/create`,
      method: 'POST',
      data: { userId, inventoryItemIds: [inventoryItemId] },
      success: (createRes) => {
        if (createRes.statusCode !== 201) {
          wx.hideLoading();
          wx.showToast({ title: createRes.data.error || 'åˆ›å»ºè®¢å•å¤±è´¥', icon: 'error' });
          this.setData({ isSubmitting: false });
          return;
        }
        
        const orderId = createRes.data.id;
        wx.showLoading({ title: 'è·å–æ”¯ä»˜å‚æ•°...' });

        // Step 2: Get payment parameters
        wx.request({
          url: `${config.apiBaseUrl}/orders/${orderId}/pay`,
          method: 'POST',
          data: { openid: auth.getToken() },
          success: (payRes) => {
            wx.hideLoading();
            if (payRes.statusCode !== 200) {
              wx.showToast({ title: payRes.data.error || 'è·å–æ”¯ä»˜å‚æ•°å¤±è´¥', icon: 'error' });
              this.setData({ isSubmitting: false });
              return;
            }

            const payParams = payRes.data.result;
            // Step 3: Request payment
            wx.requestPayment({
              ...payParams,
              success: (paymentSuccessRes) => {
                wx.showToast({ title: 'æ”¯ä»˜æˆåŠŸ', icon: 'success' });
                setTimeout(() => {
                  wx.switchTab({ url: '/pages/orders/index' });
                }, 1500);
              },
              fail: (paymentFailRes) => {
                wx.showToast({ title: 'æ”¯ä»˜å·²å–æ¶ˆ', icon: 'none' });
                this.setData({ isSubmitting: false });
              }
            });
          },
          fail: (err) => {
            wx.hideLoading();
            wx.showToast({ title: 'ç½‘ç»œè¯·æ±‚å¤±è´¥', icon: 'error' });
            this.setData({ isSubmitting: false });
          }
        });
      },
      fail: (err) => {
        wx.hideLoading();
        wx.showToast({ title: 'ç½‘ç»œè¯·æ±‚å¤±è´¥', icon: 'error' });
        this.setData({ isSubmitting: false });
      }
    });
  }
});


================================================================================
### FILE: miniprogram\pages\orders\index.js
================================================================================

// pages/orders/index.js
const auth = require('../../utils/auth');
const config = require('../../config');
const { ORDER_STATUS } = require('../../utils/constants');

Page({
  data: {
    orderList: [],
    isLoading: true,
    error: null,
    statusMap: {
      PENDING_PAYMENT: 'å¾…æ”¯ä»˜',
      PENDING_PICKUP: 'å¾…å–è´§', 
      COMPLETED: 'å·²å®Œæˆ',
      CANCELLED: 'å·²å–æ¶ˆ',
      RETURNED: 'å·²é€€è´§',
      // å…¼å®¹æ—§æ ¼å¼
      pending_payment: 'å¾…æ”¯ä»˜',
      paid: 'å¾…å–è´§',
      pending_pickup: 'å¾…å–è´§',
      completed: 'å·²å®Œæˆ',
      cancelled: 'å·²å–æ¶ˆ'
    },
  },
  onShow() { this.fetchUserOrders(); },
  fetchUserOrders() {
    const userId = auth.getUserId();
    if (!userId) { return; }
    this.setData({ isLoading: true, error: null });
    wx.request({
      url: `${config.apiBaseUrl}/orders/user/${userId}`,
      success: (res) => { this.setData({ orderList: res.data }); },
      fail: (err) => { this.setData({ error: 'åŠ è½½è®¢å•å¤±è´¥ã€‚' }); },
      complete: () => { this.setData({ isLoading: false }); }
    });
  }
});


================================================================================
### FILE: miniprogram\utils\auth.js
================================================================================

// utils/auth.js
const config = require('../config');
const TOKEN_KEY = 'authToken';
const USER_ID_KEY = 'userId';

const login = () => {
  return new Promise((resolve, reject) => {
    wx.login({
      success: (res) => {
        if (res.code) {
          wx.request({
            url: `${config.apiBaseUrl}/auth/login`,
            method: 'POST',
            data: {
              code: res.code
            },
            success: (loginRes) => {
              if (loginRes.statusCode === 200 && loginRes.data.token) {
                setToken(loginRes.data.token);
                setUserId(loginRes.data.userId);
                resolve(loginRes.data);
              } else {
                reject(new Error('Login failed on server.'));
              }
            },
            fail: (err) => {
              reject(err);
            }
          });
        } else {
          reject(new Error('wx.login failed, no code returned.'));
        }
      },
      fail: (err) => {
        reject(err);
      }
    });
  });
};

const setToken = (token) => wx.setStorageSync(TOKEN_KEY, token);
const getToken = () => wx.getStorageSync(TOKEN_KEY);
const setUserId = (userId) => wx.setStorageSync(USER_ID_KEY, userId);
const getUserId = () => wx.getStorageSync(USER_ID_KEY);
const logout = () => {
  wx.removeStorageSync(TOKEN_KEY);
  wx.removeStorageSync(USER_ID_KEY);
};

module.exports = {
  login,
  getToken,
  getUserId,
  logout
};


================================================================================
CORE CODE REVIEW REPORT GENERATION COMPLETE.
================================================================================
