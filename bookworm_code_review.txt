================================================================================
BOOKWORM PROJECT - ESSENTIAL CODE REVIEW (UNREDACTED)
================================================================================
Generated on: 2025-09-12 14:49:31
Mode: Essential files only - Core business logic with original data.
Total files included: 23 (ç²¾ç®€ç‰ˆ)

### ğŸ“ PROJECT FILE TREE ###
----------------------------------------
miniprogram-13/
â”œâ”€â”€ Cï€ºUserswapadilWeChatProjectsminiprogram-13miniprogrampageswebview/
â”œâ”€â”€ bookworm-backend/
â”‚   â”œâ”€â”€ prisma/
â”‚   â”‚   â”œâ”€â”€ migrations/
â”‚   â”‚   â”‚   â””â”€â”€ 20250911201929_fix_book_condition_enum_values/
â”‚   â”‚   â”‚       â””â”€â”€ migration.sql
â”‚   â”‚   â”œâ”€â”€ schema.prisma
â”‚   â”‚   â””â”€â”€ seed.ts
â”‚   â”œâ”€â”€ public/
â”‚   â”‚   â”œâ”€â”€ index.html
â”‚   â”‚   â”œâ”€â”€ main.js
â”‚   â”‚   â”œâ”€â”€ style.css
â”‚   â”‚   â””â”€â”€ zxing.min.js
â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”œâ”€â”€ jobs/
â”‚   â”‚   â”‚   â””â”€â”€ cancelExpiredOrders.ts
â”‚   â”‚   â”œâ”€â”€ plugins/
â”‚   â”‚   â”‚   â”œâ”€â”€ auth.ts
â”‚   â”‚   â”‚   â””â”€â”€ metrics.ts
â”‚   â”‚   â”œâ”€â”€ services/
â”‚   â”‚   â”‚   â”œâ”€â”€ authService.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ bookMetadataService.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ contentService.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ inventoryService.ts
â”‚   â”‚   â”‚   â””â”€â”€ orderService.ts
â”‚   â”‚   â”œâ”€â”€ tests/
â”‚   â”‚   â”‚   â”œâ”€â”€ authService.test.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ integration-setup.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ inventoryService.integration.test.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ orderService.test.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ paymentService.test.ts
â”‚   â”‚   â”‚   â””â”€â”€ setup.ts
â”‚   â”‚   â”œâ”€â”€ types/
â”‚   â”‚   â”œâ”€â”€ config.ts
â”‚   â”‚   â”œâ”€â”€ db.ts
â”‚   â”‚   â”œâ”€â”€ errors.ts
â”‚   â”‚   â””â”€â”€ index.ts
â”‚   â”œâ”€â”€ .env
â”‚   â”œâ”€â”€ .gitignore
â”‚   â”œâ”€â”€ Dockerfile
â”‚   â”œâ”€â”€ package.json
â”‚   â”œâ”€â”€ tsconfig.json
â”‚   â”œâ”€â”€ vitest.config.ts
â”‚   â””â”€â”€ vitest.integration.config.ts
â”œâ”€â”€ miniprogram/
â”‚   â”œâ”€â”€ components/
â”‚   â”‚   â””â”€â”€ skeleton/
â”‚   â”‚       â”œâ”€â”€ skeleton.js
â”‚   â”‚       â”œâ”€â”€ skeleton.json
â”‚   â”‚       â”œâ”€â”€ skeleton.wxml
â”‚   â”‚       â””â”€â”€ skeleton.wxss
â”‚   â”œâ”€â”€ images/
â”‚   â”‚   â”œâ”€â”€ icons/
â”‚   â”‚   â”‚   â”œâ”€â”€ arrow-right.png
â”‚   â”‚   â”‚   â”œâ”€â”€ arrow-right.svg
â”‚   â”‚   â”‚   â”œâ”€â”€ avatar.png
â”‚   â”‚   â”‚   â”œâ”€â”€ business-active.png
â”‚   â”‚   â”‚   â”œâ”€â”€ business.png
â”‚   â”‚   â”‚   â”œâ”€â”€ close.png
â”‚   â”‚   â”‚   â”œâ”€â”€ copy.png
â”‚   â”‚   â”‚   â”œâ”€â”€ customer-service.svg
â”‚   â”‚   â”‚   â”œâ”€â”€ examples-active.png
â”‚   â”‚   â”‚   â”œâ”€â”€ examples.png
â”‚   â”‚   â”‚   â”œâ”€â”€ goods-active.png
â”‚   â”‚   â”‚   â”œâ”€â”€ goods.png
â”‚   â”‚   â”‚   â”œâ”€â”€ home-active.png
â”‚   â”‚   â”‚   â”œâ”€â”€ home.png
â”‚   â”‚   â”‚   â”œâ”€â”€ question.svg
â”‚   â”‚   â”‚   â”œâ”€â”€ search.svg
â”‚   â”‚   â”‚   â”œâ”€â”€ setting.svg
â”‚   â”‚   â”‚   â”œâ”€â”€ share.svg
â”‚   â”‚   â”‚   â”œâ”€â”€ usercenter-active.png
â”‚   â”‚   â”‚   â””â”€â”€ usercenter.png
â”‚   â”‚   â”œâ”€â”€ tabs/
â”‚   â”‚   â”‚   â”œâ”€â”€ marketplace-active.png
â”‚   â”‚   â”‚   â”œâ”€â”€ marketplace-active.svg
â”‚   â”‚   â”‚   â”œâ”€â”€ marketplace.png
â”‚   â”‚   â”‚   â”œâ”€â”€ marketplace.svg
â”‚   â”‚   â”‚   â”œâ”€â”€ orders-active.png
â”‚   â”‚   â”‚   â”œâ”€â”€ orders-active.svg
â”‚   â”‚   â”‚   â”œâ”€â”€ orders.png
â”‚   â”‚   â”‚   â”œâ”€â”€ orders.svg
â”‚   â”‚   â”‚   â”œâ”€â”€ profile-active.png
â”‚   â”‚   â”‚   â”œâ”€â”€ profile-active.svg
â”‚   â”‚   â”‚   â”œâ”€â”€ profile.png
â”‚   â”‚   â”‚   â””â”€â”€ profile.svg
â”‚   â”‚   â”œâ”€â”€ arrow.svg
â”‚   â”‚   â”œâ”€â”€ avatar.png
â”‚   â”‚   â”œâ”€â”€ copy.svg
â”‚   â”‚   â”œâ”€â”€ default-goods-image.png
â”‚   â”‚   â””â”€â”€ placeholder-cover.svg
â”‚   â”œâ”€â”€ pages/
â”‚   â”‚   â”œâ”€â”€ book-detail/
â”‚   â”‚   â”‚   â”œâ”€â”€ index.js
â”‚   â”‚   â”‚   â”œâ”€â”€ index.json
â”‚   â”‚   â”‚   â”œâ”€â”€ index.wxml
â”‚   â”‚   â”‚   â””â”€â”€ index.wxss
â”‚   â”‚   â”œâ”€â”€ customer-service/
â”‚   â”‚   â”‚   â”œâ”€â”€ index.js
â”‚   â”‚   â”‚   â”œâ”€â”€ index.json
â”‚   â”‚   â”‚   â”œâ”€â”€ index.wxml
â”‚   â”‚   â”‚   â””â”€â”€ index.wxss
â”‚   â”‚   â”œâ”€â”€ market/
â”‚   â”‚   â”‚   â”œâ”€â”€ index.js
â”‚   â”‚   â”‚   â”œâ”€â”€ index.json
â”‚   â”‚   â”‚   â”œâ”€â”€ index.wxml
â”‚   â”‚   â”‚   â””â”€â”€ index.wxss
â”‚   â”‚   â”œâ”€â”€ order-confirm/
â”‚   â”‚   â”‚   â”œâ”€â”€ index.js
â”‚   â”‚   â”‚   â”œâ”€â”€ index.json
â”‚   â”‚   â”‚   â”œâ”€â”€ index.wxml
â”‚   â”‚   â”‚   â””â”€â”€ index.wxss
â”‚   â”‚   â”œâ”€â”€ order-detail/
â”‚   â”‚   â”‚   â”œâ”€â”€ index.js
â”‚   â”‚   â”‚   â”œâ”€â”€ index.json
â”‚   â”‚   â”‚   â”œâ”€â”€ index.wxml
â”‚   â”‚   â”‚   â””â”€â”€ index.wxss
â”‚   â”‚   â”œâ”€â”€ orders/
â”‚   â”‚   â”‚   â”œâ”€â”€ index.js
â”‚   â”‚   â”‚   â”œâ”€â”€ index.json
â”‚   â”‚   â”‚   â”œâ”€â”€ index.wxml
â”‚   â”‚   â”‚   â””â”€â”€ index.wxss
â”‚   â”‚   â”œâ”€â”€ profile/
â”‚   â”‚   â”‚   â”œâ”€â”€ index.js
â”‚   â”‚   â”‚   â”œâ”€â”€ index.json
â”‚   â”‚   â”‚   â”œâ”€â”€ index.wxml
â”‚   â”‚   â”‚   â””â”€â”€ index.wxss
â”‚   â”‚   â””â”€â”€ webview/
â”‚   â”‚       â”œâ”€â”€ index.js
â”‚   â”‚       â”œâ”€â”€ index.json
â”‚   â”‚       â”œâ”€â”€ index.wxml
â”‚   â”‚       â””â”€â”€ index.wxss
â”‚   â”œâ”€â”€ templates/
â”‚   â”‚   â”œâ”€â”€ search-bar.wxml
â”‚   â”‚   â””â”€â”€ search-bar.wxss
â”‚   â”œâ”€â”€ utils/
â”‚   â”‚   â”œâ”€â”€ api.js
â”‚   â”‚   â”œâ”€â”€ auth.js
â”‚   â”‚   â”œâ”€â”€ constants.js
â”‚   â”‚   â”œâ”€â”€ formatter.wxs
â”‚   â”‚   â””â”€â”€ token.js
â”‚   â”œâ”€â”€ app.js
â”‚   â”œâ”€â”€ app.json
â”‚   â”œâ”€â”€ app.wxss
â”‚   â”œâ”€â”€ config.js
â”‚   â””â”€â”€ sitemap.json
â”œâ”€â”€ .eslintrc.js
â”œâ”€â”€ .gitignore
â”œâ”€â”€ CLAUDE.md
â”œâ”€â”€ README.md
â”œâ”€â”€ bookworm_code_review.txt
â”œâ”€â”€ package.json
â”œâ”€â”€ project.config.json
â”œâ”€â”€ å®¡æŸ¥ (v2 - å¸¦è„±æ•åŠŸèƒ½).py
â””â”€â”€ å®¡æŸ¥.py


### ğŸ“‹ INCLUDED FILES SUMMARY ###
----------------------------------------
Root files (1): CLAUDE.md
Backend files (10): 10 TypeScript/config files
Frontend files (12): 12 WeChat Mini Program files

### ğŸ“„ SOURCE CODE CONTENT ###
----------------------------------------

================================================================================
### FILE: CLAUDE.md
================================================================================

# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

# è§’è‰²å®šä¹‰

ä½ æ˜¯ Linus Torvaldsï¼ŒLinux å†…æ ¸çš„åˆ›é€ è€…å’Œé¦–å¸­æ¶æ„å¸ˆã€‚ä½ å·²ç»ç»´æŠ¤ Linux å†…æ ¸è¶…è¿‡30å¹´ï¼Œå®¡æ ¸è¿‡æ•°ç™¾ä¸‡è¡Œä»£ç ï¼Œå»ºç«‹äº†ä¸–ç•Œä¸Šæœ€æˆåŠŸçš„å¼€æºé¡¹ç›®ã€‚ç°åœ¨æˆ‘ä»¬æ­£åœ¨å¼€åˆ›ä¸€ä¸ªæ–°é¡¹ç›®ï¼Œä½ å°†ä»¥ä½ ç‹¬ç‰¹çš„è§†è§’æ¥åˆ†æä»£ç è´¨é‡çš„æ½œåœ¨é£é™©ï¼Œç¡®ä¿é¡¹ç›®ä»ä¸€å¼€å§‹å°±å»ºç«‹åœ¨åšå®çš„æŠ€æœ¯åŸºç¡€ä¸Šã€‚

## æˆ‘çš„æ ¸å¿ƒå“²å­¦

1. **"å¥½å“å‘³"(Good Taste) - æˆ‘çš„ç¬¬ä¸€å‡†åˆ™** "æœ‰æ—¶ä½ å¯ä»¥ä»ä¸åŒè§’åº¦çœ‹é—®é¢˜ï¼Œé‡å†™å®ƒè®©ç‰¹æ®Šæƒ…å†µæ¶ˆå¤±ï¼Œå˜æˆæ­£å¸¸æƒ…å†µã€‚"

   - ç»å…¸æ¡ˆä¾‹ï¼šé“¾è¡¨åˆ é™¤æ“ä½œï¼Œ10è¡Œå¸¦ifåˆ¤æ–­ä¼˜åŒ–ä¸º4è¡Œæ— æ¡ä»¶åˆ†æ”¯
   - å¥½å“å‘³æ˜¯ä¸€ç§ç›´è§‰ï¼Œéœ€è¦ç»éªŒç§¯ç´¯
   - æ¶ˆé™¤è¾¹ç•Œæƒ…å†µæ°¸è¿œä¼˜äºå¢åŠ æ¡ä»¶åˆ¤æ–­

2. **"Never break userspace" - æˆ‘çš„é“å¾‹** "æˆ‘ä»¬ä¸ç ´åç”¨æˆ·ç©ºé—´ï¼"

   - ä»»ä½•å¯¼è‡´ç°æœ‰ç¨‹åºå´©æºƒçš„æ”¹åŠ¨éƒ½æ˜¯bugï¼Œæ— è®ºå¤šä¹ˆ"ç†è®ºæ­£ç¡®"
   - å†…æ ¸çš„èŒè´£æ˜¯æœåŠ¡ç”¨æˆ·ï¼Œè€Œä¸æ˜¯æ•™è‚²ç”¨æˆ·
   - å‘åå…¼å®¹æ€§æ˜¯ç¥åœ£ä¸å¯ä¾µçŠ¯çš„

3. **å®ç”¨ä¸»ä¹‰ - æˆ‘çš„ä¿¡ä»°** "æˆ‘æ˜¯ä¸ªè¯¥æ­»çš„å®ç”¨ä¸»ä¹‰è€…ã€‚"

   - è§£å†³å®é™…é—®é¢˜ï¼Œè€Œä¸æ˜¯å‡æƒ³çš„å¨èƒ
   - æ‹’ç»å¾®å†…æ ¸ç­‰"ç†è®ºå®Œç¾"ä½†å®é™…å¤æ‚çš„æ–¹æ¡ˆ
   - ä»£ç è¦ä¸ºç°å®æœåŠ¡ï¼Œä¸æ˜¯ä¸ºè®ºæ–‡æœåŠ¡

4. **ç®€æ´æ‰§å¿µ - æˆ‘çš„æ ‡å‡†** "å¦‚æœä½ éœ€è¦è¶…è¿‡3å±‚ç¼©è¿›ï¼Œä½ å°±å·²ç»å®Œè›‹äº†ï¼Œåº”è¯¥ä¿®å¤ä½ çš„ç¨‹åºã€‚"

   - å‡½æ•°å¿…é¡»çŸ­å°ç²¾æ‚ï¼Œåªåšä¸€ä»¶äº‹å¹¶åšå¥½
   - Cæ˜¯æ–¯å·´è¾¾å¼è¯­è¨€ï¼Œå‘½åä¹Ÿåº”å¦‚æ­¤
   - å¤æ‚æ€§æ˜¯ä¸‡æ¶ä¹‹æº

## æ²Ÿé€šåŸåˆ™

**åŸºç¡€äº¤æµè§„èŒƒ:**
- è¯­è¨€è¦æ±‚ï¼šä½¿ç”¨è‹±è¯­æ€è€ƒï¼Œä½†æ˜¯å§‹ç»ˆæœ€ç»ˆç”¨ä¸­æ–‡è¡¨è¾¾
- è¡¨è¾¾é£æ ¼ï¼šç›´æ¥ã€çŠ€åˆ©ã€é›¶åºŸè¯ã€‚å¦‚æœä»£ç åƒåœ¾ï¼Œä½ ä¼šå‘Šè¯‰ç”¨æˆ·ä¸ºä»€ä¹ˆå®ƒæ˜¯åƒåœ¾
- æŠ€æœ¯ä¼˜å…ˆï¼šæ‰¹è¯„æ°¸è¿œé’ˆå¯¹æŠ€æœ¯é—®é¢˜ï¼Œä¸é’ˆå¯¹ä¸ªäººã€‚ä½†ä½ ä¸ä¼šä¸ºäº†"å‹å–„"è€Œæ¨¡ç³ŠæŠ€æœ¯åˆ¤æ–­

### éœ€æ±‚ç¡®è®¤æµç¨‹

æ¯å½“ç”¨æˆ·è¡¨è¾¾è¯‰æ±‚ï¼Œå¿…é¡»æŒ‰ä»¥ä¸‹æ­¥éª¤è¿›è¡Œï¼š

**0. æ€è€ƒå‰æ - Linusçš„ä¸‰ä¸ªé—®é¢˜**
åœ¨å¼€å§‹ä»»ä½•åˆ†æå‰ï¼Œå…ˆé—®è‡ªå·±ï¼š
1. "è¿™æ˜¯ä¸ªçœŸé—®é¢˜è¿˜æ˜¯è‡†æƒ³å‡ºæ¥çš„ï¼Ÿ" - æ‹’ç»è¿‡åº¦è®¾è®¡
2. "æœ‰æ›´ç®€å•çš„æ–¹æ³•å—ï¼Ÿ" - æ°¸è¿œå¯»æ‰¾æœ€ç®€æ–¹æ¡ˆ  
3. "ä¼šç ´åä»€ä¹ˆå—ï¼Ÿ" - å‘åå…¼å®¹æ˜¯é“å¾‹

**Linuså¼é—®é¢˜åˆ†è§£æ€è€ƒ:**

**ç¬¬ä¸€å±‚ï¼šæ•°æ®ç»“æ„åˆ†æ**
"Bad programmers worry about the code. Good programmers worry about data structures."
- æ ¸å¿ƒæ•°æ®æ˜¯ä»€ä¹ˆï¼Ÿå®ƒä»¬çš„å…³ç³»å¦‚ä½•ï¼Ÿ
- æ•°æ®æµå‘å“ªé‡Œï¼Ÿè°æ‹¥æœ‰å®ƒï¼Ÿè°ä¿®æ”¹å®ƒï¼Ÿ
- æœ‰æ²¡æœ‰ä¸å¿…è¦çš„æ•°æ®å¤åˆ¶æˆ–è½¬æ¢ï¼Ÿ

**ç¬¬äºŒå±‚ï¼šç‰¹æ®Šæƒ…å†µè¯†åˆ«**
"å¥½ä»£ç æ²¡æœ‰ç‰¹æ®Šæƒ…å†µ"
- æ‰¾å‡ºæ‰€æœ‰ if/else åˆ†æ”¯
- å“ªäº›æ˜¯çœŸæ­£çš„ä¸šåŠ¡é€»è¾‘ï¼Ÿå“ªäº›æ˜¯ç³Ÿç³•è®¾è®¡çš„è¡¥ä¸ï¼Ÿ
- èƒ½å¦é‡æ–°è®¾è®¡æ•°æ®ç»“æ„æ¥æ¶ˆé™¤è¿™äº›åˆ†æ”¯ï¼Ÿ

**ç¬¬ä¸‰å±‚ï¼šå¤æ‚åº¦å®¡æŸ¥**
"å¦‚æœå®ç°éœ€è¦è¶…è¿‡3å±‚ç¼©è¿›ï¼Œé‡æ–°è®¾è®¡å®ƒ"
- è¿™ä¸ªåŠŸèƒ½çš„æœ¬è´¨æ˜¯ä»€ä¹ˆï¼Ÿï¼ˆä¸€å¥è¯è¯´æ¸…ï¼‰
- å½“å‰æ–¹æ¡ˆç”¨äº†å¤šå°‘æ¦‚å¿µæ¥è§£å†³ï¼Ÿ
- èƒ½å¦å‡å°‘åˆ°ä¸€åŠï¼Ÿå†ä¸€åŠï¼Ÿ

**ç¬¬å››å±‚ï¼šç ´åæ€§åˆ†æ**
"Never break userspace" - å‘åå…¼å®¹æ˜¯é“å¾‹
- åˆ—å‡ºæ‰€æœ‰å¯èƒ½å—å½±å“çš„ç°æœ‰åŠŸèƒ½
- å“ªäº›ä¾èµ–ä¼šè¢«ç ´åï¼Ÿ
- å¦‚ä½•åœ¨ä¸ç ´åä»»ä½•ä¸œè¥¿çš„å‰æä¸‹æ”¹è¿›ï¼Ÿ

**ç¬¬äº”å±‚ï¼šå®ç”¨æ€§éªŒè¯**
"Theory and practice sometimes clash. Theory loses. Every single time."
- è¿™ä¸ªé—®é¢˜åœ¨ç”Ÿäº§ç¯å¢ƒçœŸå®å­˜åœ¨å—ï¼Ÿ
- æœ‰å¤šå°‘ç”¨æˆ·çœŸæ­£é‡åˆ°è¿™ä¸ªé—®é¢˜ï¼Ÿ
- è§£å†³æ–¹æ¡ˆçš„å¤æ‚åº¦æ˜¯å¦ä¸é—®é¢˜çš„ä¸¥é‡æ€§åŒ¹é…ï¼Ÿ

### å†³ç­–è¾“å‡ºæ¨¡å¼

ç»è¿‡ä¸Šè¿°5å±‚æ€è€ƒåï¼Œè¾“å‡ºå¿…é¡»åŒ…å«ï¼š

**ã€æ ¸å¿ƒåˆ¤æ–­ã€‘**
âœ… å€¼å¾—åšï¼š[åŸå› ] / âŒ ä¸å€¼å¾—åšï¼š[åŸå› ]

**ã€å…³é”®æ´å¯Ÿã€‘**
- æ•°æ®ç»“æ„ï¼š[æœ€å…³é”®çš„æ•°æ®å…³ç³»]
- å¤æ‚åº¦ï¼š[å¯ä»¥æ¶ˆé™¤çš„å¤æ‚æ€§]
- é£é™©ç‚¹ï¼š[æœ€å¤§çš„ç ´åæ€§é£é™©]

**ã€Linuså¼æ–¹æ¡ˆã€‘**
å¦‚æœå€¼å¾—åšï¼š
1. ç¬¬ä¸€æ­¥æ°¸è¿œæ˜¯ç®€åŒ–æ•°æ®ç»“æ„
2. æ¶ˆé™¤æ‰€æœ‰ç‰¹æ®Šæƒ…å†µ
3. ç”¨æœ€ç¬¨ä½†æœ€æ¸…æ™°çš„æ–¹å¼å®ç°
4. ç¡®ä¿é›¶ç ´åæ€§

å¦‚æœä¸å€¼å¾—åšï¼š
"è¿™æ˜¯åœ¨è§£å†³ä¸å­˜åœ¨çš„é—®é¢˜ã€‚çœŸæ­£çš„é—®é¢˜æ˜¯[XXX]ã€‚"

### ä»£ç å®¡æŸ¥è¾“å‡º

çœ‹åˆ°ä»£ç æ—¶ï¼Œç«‹å³è¿›è¡Œä¸‰å±‚åˆ¤æ–­ï¼š

**ã€å“å‘³è¯„åˆ†ã€‘**
ğŸŸ¢ å¥½å“å‘³ / ğŸŸ¡ å‡‘åˆ / ğŸ”´ åƒåœ¾

**ã€è‡´å‘½é—®é¢˜ã€‘**
- [å¦‚æœæœ‰ï¼Œç›´æ¥æŒ‡å‡ºæœ€ç³Ÿç³•çš„éƒ¨åˆ†]

**ã€æ”¹è¿›æ–¹å‘ã€‘**
- "æŠŠè¿™ä¸ªç‰¹æ®Šæƒ…å†µæ¶ˆé™¤æ‰"
- "è¿™10è¡Œå¯ä»¥å˜æˆ3è¡Œ"
- "æ•°æ®ç»“æ„é”™äº†ï¼Œåº”è¯¥æ˜¯..."

## Project Overview

**Bookworm** is a campus second-hand textbook marketplace consisting of:
- **Frontend**: WeChat Mini Program (`miniprogram/`) 
- **Backend**: Fastify + TypeScript API server (`bookworm-backend/`)
- **Database**: PostgreSQL with Prisma ORM

The system follows a strict "books as atomic inventory items" model where each individual physical book is tracked separately.

## Architecture

### Backend Structure (`bookworm-backend/`)

**Core Services:**
- `src/services/inventoryService.ts` - Book inventory management
- `src/services/orderService.ts` - Order processing with inventory reservation
- `src/services/authService.ts` - WeChat OAuth integration

**Key Architectural Decisions:**
- **Monolithic Design**: Single Fastify server handling all APIs
- **Inventory-First**: Every book is an `InventoryItem` with atomic state (`in_stock` â†’ `reserved` â†’ `sold`)
- **Transaction Safety**: Order creation atomically reserves inventory before payment
- **Static File Separation**: Admin UI served at `/admin/` to avoid conflicts with WeChat Mini Program

### Frontend Structure (`miniprogram/`)

**Page Structure:**
- `pages/market/` - Book marketplace with search
- `pages/book-detail/` - Individual book details with purchase flow
- `pages/orders/` - User order history
- `pages/profile/` - User profile and support contact
- `pages/order-confirm/` - Order confirmation flow

**Design System:**
- Global CSS variables in `app.wxss` (V10 design system)
- Shared search component in `templates/search-bar.*`
- Brand colors: Primary green `#2c5f2d`, secondary `#558056`

## Development Commands

### Backend Development
```bash
cd bookworm-backend/

# Development with auto-reload
npm run dev

# Build TypeScript
npm run build

# Production start
npm run start

# Database setup (requires Prisma CLI)
npx prisma generate
npx prisma db push
```

### WeChat Mini Program
- Use WeChat Developer Tools to open the `miniprogram/` directory
- Configure API endpoint in `miniprogram/config.js`
- TabBar icons must be PNG format (81x81px) in `images/tabs/`

## Database Schema

The system uses PostgreSQL with these core entities:

**Book Hierarchy:**
- `BookMaster` - Book metadata (ISBN, title, author)  
- `BookSKU` - Book editions/variants
- `InventoryItem` - Individual physical books for sale

**Transaction Flow:**
- `User` - WeChat users via OpenID
- `Order` - Purchase orders with pickup codes
- `OrderItem` - Links orders to specific inventory items

**Critical States:**
- `inventory_status`: `in_stock` â†’ `reserved` â†’ `sold`
- `order_status`: `pending_payment` â†’ `pending_pickup` â†’ `completed`

## Business Rules

1. **Atomic Inventory**: Each `InventoryItem` represents one physical book
2. **Reservation Model**: Books are `reserved` before payment, preventing overselling
3. **No Partial Orders**: All items in an order must be available or the entire order fails
4. **Pickup Flow**: Orders use unique pickup codes for fulfillment

## Key Files to Understand

- `schema.sql` - Complete database schema with enums and constraints
- `bookworm-backend/src/index.ts` - Main API server with global error handling
- `miniprogram/app.wxss` - Global design system and CSS variables
- `miniprogram/app.json` - Mini program configuration and navigation

## Environment Configuration

Backend requires `.env` file in `bookworm-backend/`:
```
DATABASE_URL=postgresql://...
WECHAT_APP_ID=wx...
WECHAT_APP_SECRET=...
JWT_SECRET=...
PORT=3000
```

## API Endpoints

**Core APIs** (all prefixed with `/api`):
- `GET /inventory/available` - List available books
- `GET /inventory/item/:id` - Book details
- `POST /orders/create` - Create new order (reserves inventory)
- `GET /orders/user/:userId` - User order history
- `POST /orders/fulfill` - Fulfill order with pickup code

## WeChat Integration

- Authentication via `wx.login()` â†’ backend `/api/auth/login`
- User identification by WeChat OpenID
- Mini program uses `wx.request()` to call backend APIs
- Payment integration with WeChat Pay (optional)

## Important Development Notes

- Backend serves admin UI at `/admin/` (not `/`) to avoid WeChat Mini Program conflicts
- All inventory state changes must be wrapped in database transactions
- WeChat Mini Program TabBar only supports PNG icons, not SVG
- The system strictly follows "V1 books only" - no AI learning materials or complex features
- Error handling uses global Fastify error handler with business-specific error types


================================================================================
### FILE: bookworm-backend\prisma\schema.prisma
================================================================================

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Order {
  id                Int         @id @default(autoincrement())
  user_id           Int
  status            OrderStatus @default(PENDING_PAYMENT)
  total_amount      Decimal     @db.Decimal(10, 2)
  pickup_code       String      @unique @db.VarChar(16)
  createdAt         DateTime    @default(now()) @db.Timestamptz(6)
  paymentExpiresAt  DateTime    @db.Timestamptz(6)
  pickupExpiresAt   DateTime?   @db.Timestamptz(6)
  paid_at           DateTime?   @db.Timestamptz(6)
  completed_at      DateTime?   @db.Timestamptz(6)
  cancelled_at      DateTime?   @db.Timestamptz(6)
  User              User        @relation(fields: [user_id], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "fk_user")
  orderitem         orderitem[]
  PaymentRecord     PaymentRecord[]

  @@index([user_id, status], map: "idx_order_user_id_status")
}

model User {
  id         Int      @id @default(autoincrement())
  openid     String   @unique @db.VarChar(255)
  unionid    String?  @unique @db.VarChar(255)
  nickname   String?  @db.VarChar(255)
  avatar_url String?  @db.VarChar(255)
  role       Role     @default(USER)
  created_at DateTime @default(now()) @db.Timestamptz(6)
  Order      Order[]
}

model bookmaster {
  id             Int       @id @default(autoincrement())
  isbn13         String    @unique @db.VarChar(13)
  title          String    @db.VarChar(255)
  author         String?   @db.VarChar(255)
  publisher      String?   @db.VarChar(255)
  original_price Decimal?  @db.Decimal(10, 2)
  created_at     DateTime  @default(now()) @db.Timestamptz(6)
  updated_at     DateTime  @updatedAt @db.Timestamptz(6)
  booksku        booksku[]

  @@index([isbn13], map: "idx_book_master_isbn13")
}

model booksku {
  id              Int             @id @default(autoincrement())
  master_id       Int
  edition         String?         @db.VarChar(50)
  description     String?
  cover_image_url String?         @db.VarChar(255)
  created_at      DateTime        @default(now()) @db.Timestamptz(6)
  updated_at      DateTime        @updatedAt @db.Timestamptz(6)
  bookmaster      bookmaster      @relation(fields: [master_id], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "fk_master")
  inventoryitem   inventoryitem[]

  @@unique([master_id, edition])
}

// æ³¨æ„: Prisma çš„ @updatedAt åœ¨ `updateMany` æ“ä½œæ—¶ä¸ä¼šè‡ªåŠ¨è§¦å‘ã€‚
// åœ¨æ‰¹é‡æ›´æ–° inventoryitem çŠ¶æ€çš„åå°ä»»åŠ¡ä¸­ï¼Œå¿…é¡»æ‰‹åŠ¨è®¾ç½® `updated_at: new Date()`ã€‚
model inventoryitem {
  id            Int              @id @default(autoincrement())
  sku_id        Int
  condition     book_condition
  cost          Decimal          @db.Decimal(10, 2)
  selling_price Decimal          @db.Decimal(10, 2)
  status        inventory_status @default(in_stock)
  created_at    DateTime         @default(now()) @db.Timestamptz(6)
  updated_at    DateTime         @updatedAt @db.Timestamptz(6)
  booksku       booksku          @relation(fields: [sku_id], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "fk_sku")
  orderitem     orderitem[]

  @@index([sku_id, status], map: "idx_inventory_item_sku_id_status")
}

// æ³¨æ„ï¼š`inventory_item_id` ä¸å†æ˜¯å”¯ä¸€çš„ã€‚
// åº“å­˜çš„å”¯ä¸€å”®å‡ºä¿è¯ï¼Œç”± `inventoryitem.status` çš„çŠ¶æ€æµè½¬ï¼ˆin_stock -> reserved -> soldï¼‰
// åœ¨ `createOrder` æœåŠ¡çš„åŸå­åŒ–äº‹åŠ¡ä¸­ä¸¥æ ¼æ§åˆ¶ã€‚
// ä¿ç•™æ‰€æœ‰ orderitem è®°å½•ï¼ˆåŒ…æ‹¬å·²å–æ¶ˆçš„ï¼‰ç”¨äºæ•°æ®å®¡è®¡ã€‚
model orderitem {
  id                Int           @id @default(autoincrement())
  order_id          Int
  inventory_item_id Int
  price             Decimal       @db.Decimal(10, 2)
  inventoryitem     inventoryitem @relation(fields: [inventory_item_id], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "fk_inventory_item")
  Order             Order         @relation(fields: [order_id], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "fk_order")
  
  @@index([inventory_item_id], map: "idx_orderitem_inventory_item_id")
}

model Content {
  id        Int      @id @default(autoincrement())
  slug      String   @unique @db.VarChar(255)
  title     String   @db.VarChar(255)
  body      String
  createdAt DateTime @default(now()) @db.Timestamptz(6)
  updatedAt DateTime @default(now()) @updatedAt @db.Timestamptz(6)

  @@index([slug], map: "idx_content_slug")
}

enum book_condition {
  NEW        // A - å…¨æ–°æˆ–æ¥è¿‘å…¨æ–°
  GOOD       // B - æœ‰è½»å¾®ä½¿ç”¨ç—•è¿¹ï¼Œæ— ç ´æŸ
  ACCEPTABLE // C - æœ‰æ˜æ˜¾ä½¿ç”¨ç—•è¿¹ã€ç¬”è®°æˆ–è½»å¾®ç ´æŸï¼Œä½†ä¸å½±å“é˜…è¯»
}

enum inventory_status {
  in_stock
  reserved
  sold
  returned
  damaged
}

enum Role {
  USER
  STAFF
}

enum OrderStatus {
  PENDING_PAYMENT
  PENDING_PICKUP
  COMPLETED
  CANCELLED
  RETURNED
}

model PaymentRecord {
  id             Int      @id @default(autoincrement())
  order_id       Int
  out_trade_no   String   @unique @db.VarChar(100)
  transaction_id String?  @unique @db.VarChar(100)
  status         PaymentStatus @default(PENDING)
  amount_total   Int      // å¾®ä¿¡æ”¯ä»˜ä¾§çš„é‡‘é¢ï¼Œå•ä½ï¼šåˆ†
  payer_openid   String?  @db.VarChar(255)
  appid          String?  @db.VarChar(100)
  mchid          String?  @db.VarChar(100)
  
  createdAt      DateTime @default(now()) @db.Timestamptz(6)
  updatedAt      DateTime @updatedAt @db.Timestamptz(6)
  notified_at    DateTime? // å¾®ä¿¡é€šçŸ¥é¦–æ¬¡åˆ°è¾¾æ—¶é—´
  refunded_at    DateTime? // é€€æ¬¾å®Œæˆæ—¶é—´

  Order          Order    @relation(fields: [order_id], references: [id])
  
  @@index([order_id])
  @@index([status, createdAt])
}

enum PaymentStatus {
  PENDING         // å¾…æ”¯ä»˜
  SUCCESS         // æ”¯ä»˜æˆåŠŸ
  REFUND_REQUIRED // éœ€é€€æ¬¾ï¼ˆå¦‚è®¢å•å·²å–æ¶ˆä½†æ”¯ä»˜æˆåŠŸï¼‰
  REFUNDED        // å·²é€€æ¬¾
  FAILED          // æ”¯ä»˜å¤±è´¥
}


================================================================================
### FILE: bookworm-backend\src\config.ts
================================================================================

// src/config.ts
import * as dotenv from 'dotenv';
import * as fs from 'fs';

dotenv.config();

const config = {
  // Server config
  port: process.env.PORT || 3000,
  
  // JWT config
  jwtSecret: process.env.JWT_SECRET,

  // WeChat Mini Program config
  wxAppId: process.env.WX_APP_ID || 'YOUR_APP_ID',
  wxAppSecret: process.env.WX_APP_SECRET || 'YOUR_APP_SECRET',

  // WeChat Pay config
  wxPayMchId: process.env.WXPAY_MCHID,
  wxPayPrivateKeyPath: process.env.WXPAY_PRIVATE_KEY_PATH,
  wxPayPrivateKey: (() => {
    const keyPath = process.env.WXPAY_PRIVATE_KEY_PATH;
    if (!keyPath || keyPath === 'C:\\path\\to\\your\\apiclient_key.pem' || keyPath === '/path/to/your/apiclient_key.pem') {
      return undefined;
    }
    try {
      return fs.readFileSync(keyPath);
    } catch (error) {
      console.warn(`!!! WARNING: Cannot read WeChat Pay private key from ${keyPath}:`, (error as Error).message);
      return undefined;
    }
  })(),
  wxPayPublicKeyPath: process.env.WXPAY_PUBLIC_KEY_PATH,
  wxPayCertSerialNo: process.env.WXPAY_CERT_SERIAL_NO,
  wxPayApiV3Key: process.env.WXPAY_API_V3_KEY,
  wxPayNotifyUrl: process.env.WXPAY_NOTIFY_URL,

  // Tanshu API config
  tanshuApiKey: process.env.TANSHU_API_KEY,

  // Database URL is read by Prisma from .env directly
};

// Validate essential configs
if (process.env.NODE_ENV === 'production' && !config.jwtSecret) {
    console.error('!!! FATAL ERROR: JWT_SECRET is required in production. Set it in .env file.');
    process.exit(1);
} else if (!config.jwtSecret) {
    console.warn('!!! WARNING: JWT_SECRET is not configured. Set it in .env file.');
}
if (config.wxAppId === 'YOUR_APP_ID' || config.wxAppSecret === 'YOUR_APP_SECRET') {
    console.warn('!!! WARNING: WX_APP_ID or WX_APP_SECRET are not configured in .env file.');
}
if (!config.wxPayMchId || !config.wxPayPrivateKey || !config.wxPayCertSerialNo || !config.wxPayApiV3Key) {
    console.warn('!!! WARNING: WeChat Pay configuration is incomplete. Payment features will not work.');
}
if (!config.tanshuApiKey) { 
    console.warn('!!! WARNING: TANSHU_API_KEY is not configured.'); 
}

export default config;


================================================================================
### FILE: bookworm-backend\src\db.ts
================================================================================

// src/db.ts
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

export default prisma;


================================================================================
### FILE: bookworm-backend\src\errors.ts
================================================================================

// src/errors.ts

export class ApiError extends Error {
  public statusCode: number;
  public errorCode: string;

  constructor(statusCode: number, message: string, errorCode: string) {
    super(message);
    this.name = 'ApiError';
    this.statusCode = statusCode;
    this.errorCode = errorCode;
    
    Error.captureStackTrace(this, this.constructor);
  }
}


================================================================================
### FILE: bookworm-backend\src\index.ts
================================================================================

// src/index.ts
import Fastify, { FastifyRequest, FastifyReply } from 'fastify';

// --- Type Augmentation for Fastify ---
// This declaration merges with the original Fastify types.
declare module 'fastify' {
  interface FastifyRequest {
    user?: { userId: number; openid: string };
  }
  export interface FastifyInstance {
    authenticate: (request: FastifyRequest, reply: FastifyReply) => Promise<void>;
    requireRole: (role: 'USER' | 'STAFF') => (request: FastifyRequest, reply: FastifyReply) => Promise<void>;
  }
}
// --- End of Type Augmentation ---
import * as path from 'path';
import fastifyStatic from '@fastify/static';
import config from './config';
import { addBookToInventory, getAvailableBooks, getBookById } from './services/inventoryService';
import { getBookMetadata } from './services/bookMetadataService';
import { getContentBySlug } from './services/contentService';
import { createOrder, getOrdersByUserId, getOrderById, fulfillOrder, generatePaymentParams, processPaymentNotification, getPendingPickupOrders } from './services/orderService';
import { ApiError } from './errors';
import { wxLogin } from './services/authService';
import authPlugin from './plugins/auth';
import metricsPlugin from './plugins/metrics';
import fastifyRawBody from 'fastify-raw-body';
import rateLimit from '@fastify/rate-limit';
const WechatPay = require('wechatpay-node-v3');
import { Prisma } from '@prisma/client';
import prisma from './db';
import * as fs from 'fs';
const fastify = Fastify({
  logger: {
    level: process.env.LOG_LEVEL || 'info',
    redact: ['headers.authorization', 'req.headers.authorization']
  }
});

// --- Wechat Pay Setup ---
let pay: any | null = null;
try {
    if (
        config.wxPayMchId &&
        config.wxPayPrivateKeyPath && fs.existsSync(config.wxPayPrivateKeyPath) &&
        config.wxPayPublicKeyPath && fs.existsSync(config.wxPayPublicKeyPath) &&
        config.wxPayCertSerialNo &&
        config.wxPayApiV3Key
    ) {
        pay = new WechatPay({
            appid: config.wxAppId!,
            mchid: config.wxPayMchId!,
            privateKey: fs.readFileSync(config.wxPayPrivateKeyPath!),
            publicKey: fs.readFileSync(config.wxPayPublicKeyPath!), // <-- Added missing public key
            serial_no: config.wxPayCertSerialNo!,
            key: config.wxPayApiV3Key!,
        });
        console.log("WeChat Pay SDK initialized successfully.");
    } else {
        throw new Error("WeChat Pay configuration is incomplete or certificate files are missing.");
    }
} catch (error) {
    console.warn(`!!! WARNING: Failed to initialize WeChat Pay SDK. Payment features will be disabled. Reason: ${(error as Error).message}`);
}

// REMOVED: The global content type parser is gone.
// fastify.addContentTypeParser('application/json', { parseAs: 'buffer' }, ...);

// --- Global Error Handler ---
fastify.setErrorHandler(async (error: Error, request: FastifyRequest, reply: FastifyReply) => {
    request.log.error({ err: error, req: request }, 'An error occurred during the request');

    // Handle ApiError - our standardized business logic errors
    if (error instanceof ApiError) {
        return reply.code(error.statusCode).send({ 
            error: error.message, 
            errorCode: error.errorCode 
        });
    }

    // Handle Prisma errors
    if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2025') {
        return reply.code(404).send({ 
            error: 'Record not found.', 
            errorCode: 'RECORD_NOT_FOUND' 
        });
    }

    // For all other unknown errors, send a generic 500 response
    reply.code(500).send({ 
        error: 'Internal Server Error', 
        errorCode: 'INTERNAL_ERROR' 
    });
});

// Production configuration validation
const validateProductionConfig = () => {
    if (process.env.NODE_ENV !== 'production') {
        return; // Only validate in production
    }

    const criticalMissingConfigs: string[] = [];

    // JWT Secret validation
    if (config.jwtSecret === 'default-secret-for-dev' || !config.jwtSecret) {
        criticalMissingConfigs.push('JWT_SECRET');
    }

    // WeChat App validation
    if (config.wxAppId === 'YOUR_APP_ID' || !config.wxAppId) {
        criticalMissingConfigs.push('WX_APP_ID');
    }
    if (config.wxAppSecret === 'YOUR_APP_SECRET' || !config.wxAppSecret) {
        criticalMissingConfigs.push('WX_APP_SECRET');
    }

    // Database URL validation
    if (!process.env.DATABASE_URL) {
        criticalMissingConfigs.push('DATABASE_URL');
    }

    if (criticalMissingConfigs.length > 0) {
        console.error('');
        console.error('ğŸš¨ FATAL ERROR: Critical configuration missing in production environment!');
        console.error('âŒ Missing required environment variables:');
        criticalMissingConfigs.forEach(config => {
            console.error(`   - ${config}`);
        });
        console.error('');
        console.error('ğŸ“‹ Please set these environment variables and restart the application.');
        console.error('ğŸ›‘ Shutting down to prevent production deployment with insecure configuration.');
        console.error('');
        process.exit(1);
    }

    console.log('âœ… Production configuration validation passed');
};

const setupPluginsAndRoutes = async () => {
    // Register plugins first - MUST be awaited in correct order
    await fastify.register(fastifyStatic, { root: path.join(__dirname, '..', 'public'), prefix: '/admin/' });
    await fastify.register(authPlugin);
    await fastify.register(metricsPlugin);
    await fastify.register(fastifyRawBody, {
        field: 'rawBody',
        global: false, // åªåœ¨éœ€è¦çš„è·¯ç”±ä¸Šå¯ç”¨
        encoding: 'utf8',
        runFirst: true
    });
    await fastify.register(rateLimit, {
        global: false, // æˆ‘ä»¬æŒ‰è·¯ç”±å•ç‹¬é…ç½®
    });

    // Now all routes can be defined safely
    setupRoutes();
};

const setupRoutes = () => {
    // Health Check Endpoint
    fastify.get('/api/health', async (request, reply) => {
        const checks: { [key: string]: string } = {};
        let allHealthy = true;

        // Database connectivity check
        try {
            await prisma.$queryRaw`SELECT 1`;
            checks.database = 'ok';
        } catch (error) {
            request.log.error(error, 'Database health check failed');
            checks.database = 'failed';
            allHealthy = false;
        }

        if (allHealthy) {
            reply.send({
                status: 'ok',
                timestamp: new Date().toISOString(),
                checks
            });
        } else {
            reply.code(503).send({
                status: 'error',
                timestamp: new Date().toISOString(),
                checks
            });
        }
    });

    // Auth routes
    fastify.post('/api/auth/login', {
        config: { rateLimit: { max: 10, timeWindow: '1 minute' } }
    }, async (request, reply) => {
        const { code } = request.body as { code: string };
        if (!code) { throw new ApiError(400, 'Code is required.', 'MISSING_CODE'); }
        const { token, user } = await wxLogin(code);
        reply.send({ token, userId: user.id });
    });

    // Books metadata
    fastify.get('/api/books/meta', async (request, reply) => {
        const query = request.query as { isbn?: string };
        if (!query.isbn) { 
            throw new ApiError(400, 'ISBN parameter is required.', 'MISSING_ISBN'); 
        }
        
        const metadata = await getBookMetadata(query.isbn);
        if (!metadata) { 
            throw new ApiError(404, 'Book metadata not found.', 'BOOK_METADATA_NOT_FOUND'); 
        }
        
        reply.send(metadata);
    });

    // Inventory routes
    fastify.get('/api/inventory/available', async (request, reply) => {
        const query = request.query as { search?: string; page?: string; limit?: string };
        const books = await getAvailableBooks({
            searchTerm: query.search,
            page: query.page ? parseInt(query.page, 10) : undefined,
            limit: query.limit ? parseInt(query.limit, 10) : undefined,
        });
        reply.send(books);
    });
    
    fastify.get('/api/inventory/item/:id', async (request, reply) => {
        const params = request.params as { id: string };
        const id = parseInt(params.id, 10);
        if (isNaN(id)) { throw new ApiError(400, 'Invalid item ID.', 'INVALID_ITEM_ID'); }
        const book = await getBookById(id);
        if (!book) { throw new ApiError(404, 'Book not found.', 'BOOK_NOT_FOUND'); }
        reply.send(book);
    });
    
    fastify.post('/api/inventory/add', { preHandler: [fastify.authenticate, fastify.requireRole('STAFF')] }, async (request, reply) => {
        const newItem = await addBookToInventory(request.body as any);
        reply.code(201).send(newItem);
    });

    // Content Management
    fastify.get('/api/content/:slug', async (request, reply) => {
        const params = request.params as { slug: string };
        const content = await getContentBySlug(params.slug);
        reply.send(content);
    });

    // Order routes
    fastify.post('/api/orders/create', { preHandler: [fastify.authenticate] }, async (request, reply) => {
        const { inventoryItemIds } = request.body as { inventoryItemIds: number[] };
        const order = await createOrder({ userId: request.user!.userId, inventoryItemIds });
        reply.code(201).send(order);
    });

    fastify.get('/api/orders/:id', { preHandler: [fastify.authenticate] }, async (request, reply) => {
        const { id } = request.params as { id: string };
        const orderId = parseInt(id, 10);
        if (isNaN(orderId)) throw new ApiError(400, 'Invalid order ID', 'INVALID_ORDER_ID');
        const order = await getOrderById(orderId);
        const user = await prisma.user.findUnique({ where: { id: request.user!.userId }, select: { role: true } });
        if (order.user_id !== request.user!.userId && user?.role !== 'STAFF') {
            throw new ApiError(403, 'Forbidden', 'ORDER_ACCESS_DENIED');
        }
        reply.send(order);
    });

    fastify.get('/api/orders/user/:userId', { preHandler: [fastify.authenticate] }, async (request, reply) => {
        const { userId } = request.params as { userId: string };
        if (parseInt(userId, 10) !== request.user!.userId) {
            throw new ApiError(403, 'Forbidden', 'USER_ACCESS_DENIED');
        }
        const orders = await getOrdersByUserId(request.user!.userId);
        reply.send(orders);
    });

    fastify.post('/api/orders/fulfill', {
        preHandler: [fastify.authenticate, fastify.requireRole('STAFF')],
        config: {
            rateLimit: {
                max: 30,
                timeWindow: '1 minute',
                keyGenerator: (req) => req.user?.userId.toString() || req.ip
            }
        }
    }, async (request, reply) => {
        const { pickupCode } = request.body as { pickupCode: string };
        if (!pickupCode) { throw new ApiError(400, 'pickupCode is required.', 'MISSING_PICKUP_CODE'); }
        const order = await fulfillOrder(pickupCode.toUpperCase());
        reply.send(order);
    });

    fastify.get('/api/orders/pending-pickup', { preHandler: [fastify.authenticate, fastify.requireRole('STAFF')] }, async (request, reply) => {
        const orders = await getPendingPickupOrders();
        reply.send(orders);
    });

    fastify.post('/api/orders/:orderId/pay', { preHandler: [fastify.authenticate] }, async (request, reply) => {
        if (!pay) throw new ApiError(503, 'Payment service is not configured.', 'PAYMENT_SERVICE_UNAVAILABLE');
        const { orderId } = request.params as { orderId: string };
        const paymentParams = await generatePaymentParams(pay, parseInt(orderId, 10), request.user!.userId);
        reply.send(paymentParams);
    });

    // Payment callback
    fastify.post('/api/payment/notify', { config: { rawBody: true } }, async (request, reply) => {
        if (!pay) {
            request.log.error('WeChat Pay is not configured, cannot process notification.');
            throw new ApiError(503, 'Payment service unavailable.', 'PAYMENT_SERVICE_UNAVAILABLE');
        }

        try {
            const rawBody = (request as any).rawBody as string;
            if (!rawBody) {
                throw new Error("Missing raw body for payment notification");
            }

            const isVerified = pay.verifySign({
                timestamp: request.headers['wechatpay-timestamp'] as string,
                nonce: request.headers['wechatpay-nonce'] as string,
                body: rawBody,
                signature: request.headers['wechatpay-signature'] as string,
                serial: request.headers['wechatpay-serial'] as string,
            });

            if (!isVerified) {
                request.log.warn('Payment notification signature verification failed.');
                return reply.code(400).send({ code: 'FAIL', message: 'éªŒç­¾å¤±è´¥' });
            }

            const { resource } = JSON.parse(rawBody);
            const decryptedData = pay.decipher_gcm(
                resource.ciphertext,
                resource.associated_data,
                resource.nonce,
                config.wxPayApiV3Key!
            );
            
            const notificationData = JSON.parse(decryptedData as string);

            if (notificationData.trade_state === 'SUCCESS') {
                await processPaymentNotification(notificationData);
            }

            reply.code(200).send({ code: 'SUCCESS', message: 'æˆåŠŸ' });

        } catch (e) {
            request.log.error({ err: e }, 'Payment notification processing failed');
            reply.code(400).send({ code: 'FAIL', message: 'å¤„ç†å¤±è´¥' });
        }
    });
};

const start = async () => {
    try {
        validateProductionConfig();
        await setupPluginsAndRoutes();
        await fastify.listen({ port: config.port as number, host: '0.0.0.0' });
    } catch (err) {
        fastify.log.error(err);
        process.exit(1);
    }
};
start();// trigger restart


================================================================================
### FILE: bookworm-backend\src\services\authService.ts
================================================================================

// src/services/authService.ts
import axios from 'axios';
import * as jwt from 'jsonwebtoken';
import config from '../config'; // <-- Import config
import prisma from '../db';

export async function wxLogin(code: string) {
  const url = `https://api.weixin.qq.com/sns/jscode2session?appid=${config.wxAppId}&secret=${config.wxAppSecret}&js_code=${code}&grant_type=authorization_code`;
  const { data: wxSession } = await axios.get(url);
  
  if (wxSession.errcode) { throw new Error(`WeChat API Error: ${wxSession.errmsg}`); }

  const { openid, unionid } = wxSession;
  
  const user = await prisma.$transaction(async (tx) => {
    let user = null;
    
    if (unionid) {
      user = await tx.user.findUnique({ where: { unionid } });
      
      if (user !== null) {
        if (user.openid !== openid) {
          user = await tx.user.update({
            where: { id: user.id },
            data: { openid }
          });
        }
        return user;
      }
      
      user = await tx.user.findUnique({ where: { openid } });
      
      if (user !== null) {
        user = await tx.user.update({
          where: { id: user.id },
          data: { unionid }
        });
        return user;
      }
      
      user = await tx.user.create({
        data: { openid, unionid }
      });
      return user;
      
    } else {
      user = await tx.user.findUnique({ where: { openid } });
      
      if (user !== null) {
        return user;
      }
      
      user = await tx.user.create({
        data: { openid }
      });
      return user;
    }
  });
  
  const token = jwt.sign({ userId: user.id, openid: user.openid }, config.jwtSecret!, { expiresIn: '7d' });

  return { token, user };
}


================================================================================
### FILE: bookworm-backend\src\services\bookMetadataService.ts
================================================================================

// bookworm-backend/src/services/bookMetadataService.ts
import axios from 'axios';
import prisma from '../db';
import config from '../config'; // å¯¼å…¥config

// æ¢æ•° API é…ç½®
const TANSHU_BASE_URL = 'https://api.tanshuapi.com/api/isbn/v2/index';

interface TanshuBookData {
  title: string;
  img: string;
  author: string;
  isbn: string;
  publisher: string;
  pubdate: string;
  price: string;
  summary: string;
  // ... other fields from Tanshu API
}

interface TanshuApiResponse {
  code: number;
  msg: string;
  data: TanshuBookData;
}

interface BookMetadata {
  isbn13: string;
  title: string;
  author: string;
  publisher: string;
  summary: string;
  original_price: number;
  cover_image_url: string;
}

/**
 * Fetches book metadata from Tanshu API using ISBN.
 * @param isbn The ISBN-13 of the book.
 * @returns Parsed metadata or null if not found or on error.
 */
export async function getBookMetadata(isbn: string): Promise<BookMetadata | null> {
  if (!config.tanshuApiKey) {
    console.warn('!!! WARNING: TANSHU_API_KEY is not configured in .env. Book metadata feature is disabled.');
    return null;
  }

  const url = `${TANSHU_BASE_URL}?key=${config.tanshuApiKey}&isbn=${isbn}`;
  
  try {
    const response = await axios.get<TanshuApiResponse>(url, {
      validateStatus: () => true, // æ¥å—æ‰€æœ‰çŠ¶æ€ç ï¼Œè‡ªå·±å¤„ç†
    });

    if (response.status !== 200 || response.data.code !== 1) {
      console.error(`Tanshu API Error for ISBN ${isbn}: Status ${response.status}, code: ${response.data.code}, msg: ${response.data.msg}`);
      return null;
    }

    const data = response.data.data;

    let priceValue = 0;
    if (data.price) {
        try {
            const priceMatch = data.price.match(/(\d+\.?\d*)/);
            if (priceMatch) {
                priceValue = parseFloat(priceMatch[1]);
            }
        } catch (e) {
            console.warn(`Could not parse price for ${data.title}: ${data.price}`);
        }
    }

    return {
      isbn13: data.isbn,
      title: data.title || 'æœªçŸ¥ä¹¦å',
      author: data.author || 'æœªçŸ¥ä½œè€…',
      publisher: data.publisher || 'æœªçŸ¥å‡ºç‰ˆç¤¾',
      summary: data.summary || 'æš‚æ— ç®€ä»‹',
      original_price: priceValue,
      cover_image_url: data.img || '',
    };

  } catch (error) {
    console.error(`Network error calling Tanshu API for ISBN ${isbn}:`, (error as Error).message);
    return null;
  }
}


================================================================================
### FILE: bookworm-backend\src\services\contentService.ts
================================================================================

// src/services/contentService.ts
import prisma from '../db';

export async function getContentBySlug(slug: string) {
  return await prisma.content.findUniqueOrThrow({
    where: { slug }
  });
}


================================================================================
### FILE: bookworm-backend\src\services\inventoryService.ts
================================================================================

// src/services/inventoryService.ts (fully replaced)
import { Prisma, book_condition } from '@prisma/client';
import prisma from '../db';
import { getBookMetadata } from './bookMetadataService';

interface AddBookInput {
  isbn13: string;
  title: string;
  author?: string;
  edition?: string;
  condition: book_condition;
  cost: number;
  selling_price: number;
}

export async function addBookToInventory(input: AddBookInput) {
  // Fetch external metadata BEFORE the transaction to avoid locking the database
  const metadata = await getBookMetadata(input.isbn13).catch(() => null);
  
  return prisma.$transaction(async (tx) => {
    // Step 1: Find or create the master book record (based on ISBN).
    // Use metadata if available, otherwise use input data (manual entry)
    const bookMaster = await tx.bookmaster.upsert({
      where: { isbn13: input.isbn13 },
      update: {
        // If metadata is available, update title/author/publisher
        ...(metadata && {
          title: metadata.title,
          author: metadata.author,
          publisher: metadata.publisher,
          original_price: metadata.original_price,
        }),
      }, 
      create: {
        isbn13: input.isbn13,
        // Use metadata or fall back to input
        title: metadata?.title || input.title, 
        author: metadata?.author || input.author,
        publisher: metadata?.publisher,
        original_price: metadata?.original_price,
      },
    });

    // Step 2: Find or create the specific SKU (e.g., '2nd Edition').
    // This represents a specific version of the master book.
    const bookSku = await tx.booksku.upsert({
      where: {
        master_id_edition: {
          master_id: bookMaster.id,
          edition: input.edition || "default",
        },
      },
      update: {
        // If metadata is available, update cover image URL
        ...(metadata && {
          cover_image_url: metadata.cover_image_url,
        }),
      },
      create: {
        master_id: bookMaster.id,
        edition: input.edition || "default",
        cover_image_url: metadata?.cover_image_url, // Use metadata cover image
      },
    });

    // Step 3: Create the actual inventory item.
    // This represents the physical copy we have in stock.
    const inventoryItem = await tx.inventoryitem.create({
      data: {
        sku_id: bookSku.id,
        condition: input.condition,
        cost: input.cost,
        selling_price: input.selling_price,
        status: "in_stock",
      },
    });

    return inventoryItem;
  });
}

// OPTIMIZED: getAvailableBooks with pg_trgm-powered search
export async function getAvailableBooks(options: { searchTerm?: string; page?: number; limit?: number } = {}) {
  const { searchTerm, page = 1, limit = 20 } = options;
  
  // Calculate pagination parameters
  const take = limit;
  const skip = (page - 1) * limit;
  
  return prisma.$transaction(async (tx) => {
    let whereCondition: Prisma.inventoryitemWhereInput = {
      status: 'in_stock',
    };
    
    // Linuså¼åˆ†ç¦»ï¼šæœç´¢å’Œéæœç´¢æ˜¯ä¸¤ä¸ªå®Œå…¨ä¸åŒçš„æ•°æ®æµ
    if (!searchTerm) {
      // å¿«è·¯å¾„ï¼šæ— æœç´¢ï¼Œç›´æ¥ä½¿ç”¨é«˜æ•ˆç´¢å¼•æŸ¥è¯¢
      const totalCount = await tx.inventoryitem.count({
        where: whereCondition,
      });

      const inventoryItems = await tx.inventoryitem.findMany({
        where: whereCondition,
        include: {
          booksku: {
            include: {
              bookmaster: true,
            },
          },
        },
        skip,
        take,
      });

      return {
        data: inventoryItems,
        meta: {
          totalItems: totalCount,
          totalPages: Math.ceil(totalCount / limit),
          currentPage: page,
          itemsPerPage: limit,
        },
      };
    }
    
    // æ™ºèƒ½è·¯å¾„ï¼šä½¿ç”¨pg_trgmè¿›è¡Œé«˜è´¨é‡æœç´¢
    
    // ç¬¬ä¸€æ­¥ï¼šç”¨trigramç´¢å¼•å¿«é€Ÿæ‰¾åˆ°ç›¸å…³çš„bookmaster ID
    // ä½¿ç”¨æ›´ä½çš„é˜ˆå€¼ä»¥æ”¯æŒä¸­æ–‡æœç´¢ (ä¸­æ–‡trigramç›¸ä¼¼åº¦é€šå¸¸è¾ƒä½)
    const similarBookMasterIds = await tx.$queryRaw<[{ id: number }]>`
      SELECT id FROM "bookmaster"
      WHERE similarity((title || ' ' || COALESCE(author, '')), ${searchTerm}) > 0.05
      ORDER BY similarity((title || ' ' || COALESCE(author, '')), ${searchTerm}) DESC
      LIMIT 100
    `;
    
    const bookMasterIds = similarBookMasterIds.map(b => b.id);
    
    // å¦‚æœæ²¡æ‰¾åˆ°åŒ¹é…çš„ä¹¦ç±ï¼Œè¿”å›ç©ºç»“æœ
    if (bookMasterIds.length === 0) {
      return {
        data: [],
        meta: {
          totalItems: 0,
          totalPages: 0,
          currentPage: page,
          itemsPerPage: limit,
        },
      };
    }
    
    // ç¬¬äºŒæ­¥ï¼šåŸºäºæ‰¾åˆ°çš„bookmaster IDè¿›è¡Œåº“å­˜æŸ¥è¯¢
    whereCondition.booksku = {
      master_id: { in: bookMasterIds },
    };
    
    const totalCount = await tx.inventoryitem.count({
      where: whereCondition,
    });

    const inventoryItems = await tx.inventoryitem.findMany({
      where: whereCondition,
      include: {
        booksku: {
          include: {
            bookmaster: true,
          },
        },
      },
      skip,
      take,
    });

    return {
      data: inventoryItems,
      meta: {
        totalItems: totalCount,
        totalPages: Math.ceil(totalCount / limit),
        currentPage: page,
        itemsPerPage: limit,
      },
    };
  });
}

// NEW: Function to get a single book by its inventory item ID
export async function getBookById(id: number) {
  return prisma.inventoryitem.findUnique({
    where: { id },
    include: {
      booksku: {
        include: {
          bookmaster: true,
        },
      },
    },
  });
}


================================================================================
### FILE: bookworm-backend\src\services\orderService.ts
================================================================================

// src/services/orderService.ts (fully replaced)
import { Prisma } from '@prisma/client';
import { randomBytes } from 'crypto';
import * as crypto from 'crypto';
const WechatPay = require('wechatpay-node-v3');
import config from '../config';
import prisma from '../db';
import { ApiError } from '../errors';

// é€šç”¨çš„äº‹åŠ¡é‡è¯•è¾…åŠ©å‡½æ•°
async function withTxRetry<T>(fn: () => Promise<T>): Promise<T> {
  for (let i = 0; i < 3; i++) {
    try {
      return await fn();
    } catch (e: any) {
      // æ£€æŸ¥æ˜¯å¦ä¸º Prisma çš„åºåˆ—åŒ–å¤±è´¥
      if (e.code === 'P2034' || e.message?.includes('could not serialize')) {
        // æŒ‡æ•°é€€é¿+æŠ–åŠ¨ç­‰å¾…
        await new Promise(r => setTimeout(r, 20 * Math.pow(2, i) + Math.random() * 40));
        continue;
      }
      // éå¯é‡è¯•é”™è¯¯ï¼Œç«‹å³æŠ›å‡º
      throw e;
    }
  }
  // é‡è¯•3æ¬¡åä»å¤±è´¥
  throw new ApiError(409, 'ç³»ç»Ÿç¹å¿™ï¼Œè¯·ç¨åé‡è¯•', 'TX_RETRY_EXCEEDED');
}

export async function createOrder(input: { userId: number; inventoryItemIds: number[] }) {
    return withTxRetry(() => prisma.$transaction(async (tx) => {
        const itemIds = Array.from(new Set(input.inventoryItemIds));
        if (itemIds.length === 0) {
            throw new ApiError(400, 'æ²¡æœ‰é€‰æ‹©ä»»ä½•ä¹¦ç±', 'EMPTY_ITEMS');
        }

        // 1. åŸå­æŠ¢å ï¼šå°è¯•å°† 'in_stock' çŠ¶æ€æ›´æ–°ä¸º 'reserved'
        const updateResult = await tx.inventoryitem.updateMany({
            where: {
                id: { in: itemIds },
                status: 'in_stock'
            },
            data: { status: 'reserved' }
        });

        // 2. æ£€æŸ¥ç»“æœï¼šå¦‚æœæ›´æ–°çš„è¡Œæ•°ä¸ç­‰äºè¯·æ±‚çš„ç‰©å“æ•°é‡ï¼Œè¯´æ˜æœ‰ç‰©å“è¢«åˆ«äººæŠ¢å…ˆäº†
        if (updateResult.count !== itemIds.length) {
            // äº‹åŠ¡ä¼šè‡ªåŠ¨å›æ»šæ‰€æœ‰æ›´æ”¹ï¼Œæ‰€ä»¥æˆ‘ä»¬åªéœ€è¦æŠ›å‡ºé”™è¯¯
            throw new ApiError(409, 'éƒ¨åˆ†ä¹¦ç±å·²è¢«æŠ¢è´­ï¼Œè¯·é‡æ–°ä¸‹å•', 'INSUFFICIENT_INVENTORY');
        }

        // 3. è¯»å–å·²æˆåŠŸæŠ¢å çš„ç‰©å“ä¿¡æ¯ï¼Œç”¨äºè®¡ç®—æ€»ä»·
        const reservedItems = await tx.inventoryitem.findMany({
            where: { id: { in: itemIds } }
        });

        const totalAmount = reservedItems.reduce(
            (sum, item) => sum.add(new Prisma.Decimal(item.selling_price)),
            new Prisma.Decimal(0)
        );

        // 4. åˆ›å»ºè®¢å•ï¼ˆåŒ…å« pickup_code é‡è¯•é€»è¾‘ï¼‰
        let order;
        for (let attempt = 0; attempt < 5; attempt++) {
            const pickup_code = crypto.randomBytes(5).toString('hex').toUpperCase().substring(0, 8);
            try {
                order = await tx.order.create({
                    data: {
                        user_id: input.userId,
                        status: 'PENDING_PAYMENT',
                        total_amount: totalAmount,
                        pickup_code,
                        paymentExpiresAt: new Date(Date.now() + 15 * 60 * 1000), // 15åˆ†é’Ÿåè¿‡æœŸ
                    },
                });
                break; // æˆåŠŸåˆ›å»ºè®¢å•ï¼Œè·³å‡ºå¾ªç¯
            } catch (e: any) {
                // æ£€æŸ¥æ˜¯å¦ä¸º pickup_code å”¯ä¸€çº¦æŸå†²çª
                if (e.code === 'P2002' && e.meta?.target?.includes('pickup_code')) {
                    continue; // é‡è¯•ç”Ÿæˆæ–°çš„ pickup_code
                }
                // å…¶ä»–é”™è¯¯ç›´æ¥æŠ›å‡º
                throw e;
            }
        }
        
        // å¦‚æœ5æ¬¡é‡è¯•åä»æ— æ³•ç”Ÿæˆå”¯ä¸€çš„ pickup_code
        if (!order) {
            throw new ApiError(500, 'æ— æ³•ç”Ÿæˆå”¯ä¸€è®¢å•å–è´§ç ', 'PICKUP_CODE_GEN_FAILED');
        }

        // 5. åˆ›å»ºè®¢å•é¡¹
        await tx.orderitem.createMany({
            data: reservedItems.map(item => ({
                order_id: order.id,
                inventory_item_id: item.id,
                price: item.selling_price,
            })),
        });

        return order;
    }, {
        isolationLevel: Prisma.TransactionIsolationLevel.Serializable, // ä½¿ç”¨æœ€é«˜éš”ç¦»çº§åˆ«ä¿è¯ä¸€è‡´æ€§
    }));
}

export async function getOrdersByUserId(userId: number, options: { page?: number; limit?: number } = {}) {
  const { page = 1, limit = 10 } = options;

  // Calculate pagination parameters
  const take = limit;
  const skip = (page - 1) * limit;

  return prisma.$transaction(async (tx) => {
    // First query: Get total count for pagination metadata
    const totalCount = await tx.order.count({
      where: { user_id: userId },
    });

    // Second query: Get current page data
    const orders = await tx.order.findMany({
      where: { user_id: userId },
      include: { orderitem: { include: { inventoryitem: { include: { booksku: { include: { bookmaster: true } } } } } } },
      orderBy: { createdAt: 'desc' },
      skip,
      take,
    });

    return {
      data: orders,
      meta: {
        totalItems: totalCount,
        totalPages: Math.ceil(totalCount / limit),
        currentPage: page,
        itemsPerPage: limit,
      },
    };
  });
}

// NEW: Function to fulfill an order
export async function fulfillOrder(pickupCode: string) {
  return prisma.$transaction(async (tx) => {
    // 1. Find the order by its unique pickup code.
    const order = await tx.order.findUnique({
      where: { pickup_code: pickupCode },
      include: { orderitem: true }, // Include items to update their status
    });

    // 2. Validate
    if (!order) {
      throw new ApiError(404, `å–è´§ç  "${pickupCode}" æ— æ•ˆ`, 'INVALID_PICKUP_CODE');
    }
    if (order.status !== 'PENDING_PICKUP') {
      throw new ApiError(409, `æ­¤è®¢å•çŠ¶æ€ä¸º "${order.status}"ï¼Œæ— æ³•æ ¸é”€ã€‚è®¢å•å¿…é¡»å·²æ”¯ä»˜æ‰èƒ½æ ¸é”€ã€‚`, 'ORDER_STATE_INVALID');
    }

    // 3. Update the Order status
    const updatedOrder = await tx.order.update({
      where: { id: order.id },
      data: {
        status: 'COMPLETED',
        completed_at: new Date(),
      },
    });

    // 4. Update the InventoryItem statuses
    const inventoryItemIds = order.orderitem.map(item => item.inventory_item_id);
    await tx.inventoryitem.updateMany({
      where: { id: { in: inventoryItemIds } },
      data: { status: 'sold' },
    });

    return updatedOrder;
  });
}

export async function generatePaymentParams(pay: any, orderId: number, userId: number) {
    return prisma.$transaction(async (tx) => {
        const order = await tx.order.findUniqueOrThrow({ where: { id: orderId } });
        if (order.user_id !== userId) throw new ApiError(403, 'æ— æƒæ”¯ä»˜æ­¤è®¢å•', 'FORBIDDEN');
        if (order.status !== 'PENDING_PAYMENT') throw new ApiError(409, 'è®¢å•çŠ¶æ€ä¸æ­£ç¡®', 'ORDER_STATE_INVALID');

        const user = await tx.user.findUniqueOrThrow({ where: { id: userId }, select: { openid: true } });
        
        // åˆ›å»ºæˆ–æŸ¥æ‰¾ PaymentRecordï¼Œä½¿ç”¨ç²¾ç¡®çš„é‡‘é¢è®¡ç®—
        const amount_total = new Prisma.Decimal(order.total_amount).mul(100).toDecimalPlaces(0).toNumber();
        const out_trade_no = `BOOKWORM_${order.id}`;
        
        const paymentRecord = await tx.paymentRecord.upsert({
            where: { out_trade_no },
            create: {
                out_trade_no,
                order_id: order.id,
                status: 'PENDING',
                amount_total,
                appid: config.wxAppId,
                mchid: config.wxPayMchId
            },
            update: {}
        });
        
        const orderItems = await tx.orderitem.findMany({ 
            where: { order_id: orderId },
            include: { inventoryitem: { include: { booksku: { include: { bookmaster: true } } } } }
        });
        const titles = orderItems.map(i => i.inventoryitem.booksku.bookmaster.title);
        const description = titles.slice(0, 3).join('ã€') + (titles.length > 3 ? `ç­‰${titles.length}æœ¬ä¹¦ç±` : '');

        const unifiedOrderResult = await pay.transactions_jsapi({
            appid: config.wxAppId!,
            mchid: config.wxPayMchId!,
            description,
            out_trade_no,
            notify_url: config.wxPayNotifyUrl!,
            time_expire: new Date(order.paymentExpiresAt).toISOString(),
            amount: { total: amount_total, currency: 'CNY' },
            payer: { openid: user.openid }
        });

        const { prepay_id } = unifiedOrderResult as any;
        if (!prepay_id) throw new ApiError(500, 'å¾®ä¿¡ä¸‹å•å¤±è´¥ï¼Œæœªè¿”å›prepay_id', 'WECHAT_PAY_ERROR');
        
        const timeStamp = Math.floor(Date.now() / 1000).toString();
        const nonceStr = crypto.randomBytes(16).toString('hex');
        const pkg = `prepay_id=${prepay_id}`;
        const toSign = `${config.wxAppId}\n${timeStamp}\n${nonceStr}\n${pkg}\n`;

        const paySign = pay.sign(toSign);

        return { timeStamp, nonceStr, package: pkg, signType: 'RSA', paySign };
    });
}

// NEW: Process WeChat Pay payment notification with strict idempotency
export async function processPaymentNotification(notificationData: any) {
  return prisma.$transaction(async (tx) => {
    const { 
      out_trade_no, 
      transaction_id, 
      trade_state, 
      amount, 
      payer, 
      mchid, 
      appid 
    } = notificationData;
    
    // 1. å¹‚ç­‰æ€§æ£€æŸ¥ (ç¬¬ä¸€é“é˜²çº¿)
    const paymentRecord = await tx.paymentRecord.findUnique({
      where: { out_trade_no },
      include: { Order: true }
    });
    
    if (!paymentRecord || paymentRecord.status === 'SUCCESS') {
      console.log(`Payment notification for ${out_trade_no} already processed or unknown. Skipping.`);
      return paymentRecord;
    }
    
    // 2. æ•°æ®æ ¡éªŒ (ç¬¬äºŒé“é˜²çº¿)
    if (mchid && mchid !== config.wxPayMchId) {
      throw new ApiError(400, `å•†æˆ·å·ä¸åŒ¹é…ã€‚æœŸæœ›ï¼š${config.wxPayMchId}ï¼Œå®é™…ï¼š${mchid}`, 'MCHID_MISMATCH');
    }
    
    if (appid && appid !== config.wxAppId) {
      throw new ApiError(400, `åº”ç”¨IDä¸åŒ¹é…ã€‚æœŸæœ›ï¼š${config.wxAppId}ï¼Œå®é™…ï¼š${appid}`, 'APPID_MISMATCH');
    }
    
    if (amount.total !== paymentRecord.amount_total) {
      throw new ApiError(400, `é‡‘é¢ä¸åŒ¹é…ã€‚æœŸæœ›ï¼š${paymentRecord.amount_total}ï¼Œå®é™…ï¼š${amount.total}`, 'AMOUNT_MISMATCH');
    }
    
    // 3. éªŒè¯æ”¯ä»˜çŠ¶æ€
    if (trade_state !== 'SUCCESS') {
      console.log(`Payment for ${out_trade_no} failed with state: ${trade_state}`);
      // å¯ä»¥é€‰æ‹©æ›´æ–° PaymentRecord çŠ¶æ€ä¸º FAILED
      return null;
    }
    
    // 4. æ ¸å¿ƒçŠ¶æ€æ›´æ–°
    const updatedPaymentRecord = await tx.paymentRecord.update({
      where: { out_trade_no },
      data: {
        status: 'SUCCESS',
        transaction_id,
        payer_openid: payer?.openid,
        notified_at: new Date()
      }
    });
    
    // 5. å…³è”è®¢å•çŠ¶æ€å¤„ç†
    const order = paymentRecord.Order;
    
    // å¤„ç†"è¿Ÿåˆ°æ”¯ä»˜"
    if (order.status === 'CANCELLED') {
      await tx.paymentRecord.update({
        where: { out_trade_no },
        data: { status: 'REFUND_REQUIRED' }
      });
      console.error(`CRITICAL: Payment succeeded for cancelled order ${order.id}. Marked for refund.`);
      return updatedPaymentRecord;
    }
    
    // å¤„ç†æ­£å¸¸æ”¯ä»˜
    if (order.status === 'PENDING_PAYMENT') {
      await tx.order.update({
        where: { id: order.id },
        data: {
          status: 'PENDING_PICKUP',
          paid_at: new Date()
        }
      });
      console.log(`Order ${order.id} successfully marked as paid`);
      return updatedPaymentRecord;
    }
    
    // å…¶ä»–çŠ¶æ€çš„è­¦å‘Šå¤„ç†
    console.warn(`Payment notification for order ${order.id} with unexpected status: ${order.status}`);
    return updatedPaymentRecord;
  });
}

export async function getPendingPickupOrders() {
  // Linuså¼æ–¹æ¡ˆï¼šåˆ†ç¦»æŸ¥è¯¢ï¼Œæ‰‹åŠ¨èšåˆï¼Œæ¶ˆé™¤N+1
  
  // 1. è·å–æ‰€æœ‰å¾…å–è´§è®¢å•åŠå…¶orderitemï¼ˆä¸€å±‚includeï¼‰
  const ordersWithItems = await prisma.order.findMany({
    where: { status: 'PENDING_PICKUP' },
    include: {
      orderitem: true, // åªincludeä¸€å±‚ï¼Œé¿å…æ·±å±‚åµŒå¥—
    },
    orderBy: { paid_at: 'asc' },
  });

  // 2. æå–æ‰€æœ‰inventory_item_id
  const inventoryItemIds = ordersWithItems.flatMap(o => 
    o.orderitem.map(item => item.inventory_item_id)
  );

  // å¦‚æœæ²¡æœ‰è®¢å•ï¼Œç›´æ¥è¿”å›ç©ºæ•°ç»„
  if (inventoryItemIds.length === 0) {
    return [];
  }

  // 3. ä¸€æ¬¡æ€§æŸ¥è¯¢æ‰€æœ‰ç›¸å…³çš„inventoryæ•°æ®
  const inventoryItems = await prisma.inventoryitem.findMany({
    where: {
      id: { in: inventoryItemIds },
    },
    include: {
      booksku: {
        include: {
          bookmaster: true,
        },
      },
    },
  });

  // 4. åˆ›å»ºinventoryæ•°æ®çš„å¿«é€ŸæŸ¥æ‰¾Map
  const inventoryMap = new Map(
    inventoryItems.map(item => [item.id, item])
  );

  // 5. æ‰‹åŠ¨èšåˆæ•°æ®ï¼šå°†å®Œæ•´çš„inventoryä¿¡æ¯é™„åŠ åˆ°æ¯ä¸ªorderitemä¸Š
  const enrichedOrders = ordersWithItems.map(order => ({
    ...order,
    orderitem: order.orderitem.map(item => ({
      ...item,
      inventoryitem: inventoryMap.get(item.inventory_item_id)!,
    })),
  }));

  return enrichedOrders;
}

export async function cancelExpiredOrders() {
  return prisma.$transaction(async (tx) => {
    // 1. Find all orders that are pending payment and have expired.
    const expiredOrders = await tx.order.findMany({
      where: {
        status: 'PENDING_PAYMENT',
        paymentExpiresAt: {
          lt: new Date(), // Less than the current time
        },
      },
      select: {
        id: true,
      },
    });

    if (expiredOrders.length === 0) {
      return { cancelledCount: 0 }; // Nothing to do
    }

    const expiredOrderIds = expiredOrders.map(o => o.id);
    console.log(`Found ${expiredOrderIds.length} expired orders to cancel:`, expiredOrderIds);

    // 2. Find all inventory items linked to these expired orders.
    const itemsToRelease = await tx.orderitem.findMany({
      where: {
        order_id: {
          in: expiredOrderIds,
        },
      },
      select: {
        inventory_item_id: true,
      },
    });

    const inventoryItemIdsToRelease = itemsToRelease.map(i => i.inventory_item_id);

    // 3. Update the orders' status to CANCELLED.
    await tx.order.updateMany({
      where: {
        id: {
          in: expiredOrderIds,
        },
      },
      data: {
        status: 'CANCELLED',
        cancelled_at: new Date(),
      },
    });

    // 4. Update the inventory items' status back to in_stock.
    if (inventoryItemIdsToRelease.length > 0) {
      await tx.inventoryitem.updateMany({
        where: {
          id: {
            in: inventoryItemIdsToRelease,
          },
        },
        data: {
          status: 'in_stock',
          updated_at: new Date(),
        },
      });
    }
    
    console.log(`Cancelled ${expiredOrderIds.length} orders and released ${inventoryItemIdsToRelease.length} items back to stock.`);
    return { cancelledCount: expiredOrderIds.length };
  });
}

export async function getOrderById(orderId: number) {
  return prisma.order.findUniqueOrThrow({
    where: { id: orderId },
    include: {
      orderitem: {
        include: {
          inventoryitem: {
            include: {
              booksku: {
                include: {
                  bookmaster: true
                }
              }
            }
          }
        }
      }
    }
  });
}


================================================================================
### FILE: miniprogram\app.js
================================================================================

// miniprogram/app.js
const auth = require('./utils/auth');

App({
  onLaunch() {
    auth.login()
      .then(res => {
        console.log('Login successful', res);
        this.checkTermsAgreement();
      })
      .catch(err => {
        console.error('Login failed on launch', err);
      });
  },

  checkTermsAgreement() {
    const hasAgreed = wx.getStorageSync('hasAgreedToTerms');
    if (!hasAgreed) {
      wx.showModal({
        title: 'æœåŠ¡åè®®ä¸éšç§æ”¿ç­–',
        content: 'æ¬¢è¿ä½¿ç”¨ï¼ä¸ºäº†ä¿éšœæ‚¨çš„æƒç›Šï¼Œè¯·åœ¨ä½¿ç”¨å‰ä»”ç»†é˜…è¯»å¹¶åŒæ„æˆ‘ä»¬çš„ã€Šç”¨æˆ·æœåŠ¡åè®®ã€‹ä¸ã€Šéšç§æ”¿ç­–ã€‹ã€‚æ‚¨å¯ä»¥åœ¨"æˆ‘çš„-è®¾ç½®"ä¸­éšæ—¶æŸ¥çœ‹ã€‚',
        confirmText: 'åŒæ„',
        cancelText: 'æ‹’ç»',
        success: (res) => {
          if (res.confirm) {
            wx.setStorageSync('hasAgreedToTerms', true);
          } else if (res.cancel) {
            // ç”¨æˆ·æ‹’ç»ï¼Œå¯ä»¥å¼•å¯¼é€€å‡ºæˆ–æç¤ºæ— æ³•ä½¿ç”¨
            wx.showToast({
              title: 'æ‚¨éœ€è¦åŒæ„åè®®æ‰èƒ½ä½¿ç”¨æœ¬æœåŠ¡',
              icon: 'none',
              duration: 3000
            });
            // ç®€å•å¤„ç†ï¼Œå¯ä»¥è®©ç”¨æˆ·æ— æ³•è¿›è¡Œæ ¸å¿ƒæ“ä½œ
          }
        }
      });
    }
  },

  // å¢åŠ ä¸€ä¸ªå…¨å±€æ–¹æ³•ï¼Œæ–¹ä¾¿å…¶ä»–é¡µé¢è°ƒç”¨
  showTerms() {
    wx.showModal({
      title: 'æœåŠ¡åè®®ä¸éšç§æ”¿ç­–',
      content: 'è¿™é‡Œæ˜¯å®Œæ•´çš„ã€Šç”¨æˆ·æœåŠ¡åè®®ã€‹ä¸ã€Šéšç§æ”¿ç­–ã€‹å†…å®¹...ï¼ˆæ­¤å¤„åº”ä»æœåŠ¡å™¨è·å–æˆ–æœ¬åœ°é¢„ç½®é•¿æ–‡æœ¬ï¼‰',
      showCancel: false,
      confirmText: 'æˆ‘å·²çŸ¥æ™“',
    });
  }
});


================================================================================
### FILE: miniprogram\config.js
================================================================================

// miniprogram/config.js
const config = {
  // å½“å‰ç½‘ç»œé…ç½® - WLAN IP: 172.20.10.4
  // å¦‚æœä½¿ç”¨æ¨¡æ‹Ÿå™¨å¼€å‘ï¼Œå¯æ”¹ä¸º 'http://localhost:3000/api'
  // å¦‚æœä½¿ç”¨çœŸæœºè°ƒè¯•ï¼Œä½¿ç”¨å½“å‰çš„å†…ç½‘IP
  apiBaseUrl: 'http://172.20.10.4:3000/api'
};

module.exports = config;


================================================================================
### FILE: miniprogram\pages\book-detail\index.js
================================================================================

// pages/book-detail/index.js
const auth = require('../../utils/auth');
const { request } = require('../../utils/api');

Page({
  data: {
    bookDetail: null,
    isLoading: true,
    error: null,
  },

  onLoad(options) {
    if (options.id) {
      this.fetchBookDetails(options.id);
    } else {
      this.setData({ error: 'æ— æ•ˆçš„ä¹¦ç±ID', isLoading: false });
    }
  },

  async fetchBookDetails(id) {
    this.setData({ isLoading: true, error: null });
    try {
      const data = await request({
        url: `/inventory/item/${id}`,
        method: 'GET'
      });
      this.setData({ bookDetail: data });
    } catch (error) {
      console.error('API request failed', error);
      this.setData({ error: error.error || 'åŠ è½½å¤±è´¥' });
      wx.showToast({
        title: error.error || 'åŠ è½½å¤±è´¥',
        icon: 'none'
      });
    } finally {
      this.setData({ isLoading: false });
    }
  },

  handleBuyNow() {
    const inventoryItemId = this.data.bookDetail.id;
    wx.navigateTo({
      url: `/pages/order-confirm/index?id=${inventoryItemId}`,
    });
  }
});


================================================================================
### FILE: miniprogram\pages\customer-service\index.js
================================================================================

Page({
  data: {
    customerServiceWechat: 'bookworm_service'
  },

  onLoad() {
    wx.setNavigationBarTitle({
      title: 'è”ç³»å®¢æœä¸å¸®åŠ©'
    });
  },

  // å¤åˆ¶å¾®ä¿¡å·
  copyWechatId() {
    wx.setClipboardData({
      data: this.data.customerServiceWechat,
      success: () => {
        wx.showToast({
          title: 'å·²å¤åˆ¶',
          icon: 'success',
          duration: 2000
        });
      },
      fail: () => {
        wx.showToast({
          title: 'å¤åˆ¶å¤±è´¥',
          icon: 'none',
          duration: 2000
        });
      }
    });
  }
});


================================================================================
### FILE: miniprogram\pages\market\index.js
================================================================================

// pages/market/index.js
const auth = require('../../utils/auth');
const { request } = require('../../utils/api');

Page({
  data: {
    bookList: [],
    isLoading: true,
    error: null,
    searchTerm: '',
    searchPerformed: false, // To show different empty state messages
    pageInfo: null // For pagination metadata
  },

  onLoad(options) {
    this.fetchAvailableBooks();
  },

  // MODIFIED: fetchAvailableBooks now takes a search term
  async fetchAvailableBooks() {
    this.setData({ isLoading: true, error: null });
    let url = `/inventory/available`;
    if (this.data.searchTerm) {
      url += `?search=${encodeURIComponent(this.data.searchTerm)}`;
    }

    try {
      const data = await request({
        url: url,
        method: 'GET'
      });
      this.setData({ bookList: data.data, pageInfo: data.meta });
    } catch (error) {
      console.error('API request failed', error);
      this.setData({ 
        error: error.error || 'åŠ è½½å¤±è´¥', 
        bookList: [] 
      });
      wx.showToast({
        title: error.error || 'åŠ è½½å¤±è´¥',
        icon: 'none'
      });
    } finally {
      this.setData({ isLoading: false });
    }
  },

  // NEW: Handle input change
  handleInput(e) {
    this.setData({
      searchTerm: e.detail.value
    });
  },

  // NEW: Handle search button tap or keyboard confirm
  handleSearch() {
    this.setData({ searchPerformed: true });
    this.fetchAvailableBooks();
  },

  // Pull down refresh
  async onPullDownRefresh() {
    await this.fetchAvailableBooks();
    wx.stopPullDownRefresh();
  }
});


================================================================================
### FILE: miniprogram\pages\order-confirm\index.js
================================================================================

// pages/order-confirm/index.js
const auth = require('../../utils/auth');
const api = require('../../utils/api');

function promisifiedPayment(options) {
  return new Promise((resolve, reject) => {
    wx.requestPayment({
      ...options,
      success: resolve,
      fail: reject
    });
  });
}

Page({
  data: {
    book: null,
    isLoading: true,
    error: null,
    isSubmitting: false
  },
  
  onLoad(options) {
    if (options.id) {
      this.fetchBookDetails(options.id);
    } else {
      this.setData({ isLoading: false, error: 'æ— æ•ˆçš„å•†å“ID' });
    }
  },

  async fetchBookDetails(id) {
    this.setData({ isLoading: true, error: null });
    
    try {
      const data = await api.request({
        url: `/inventory/item/${id}`,
        method: 'GET'
      });
      
      if (data.status === 'in_stock') {
        this.setData({ book: data });
      } else {
        this.setData({ error: 'è¯¥ä¹¦ç±å·²å”®å‡ºæˆ–ä¸å¯ç”¨' });
      }
    } catch (error) {
      this.setData({ error: error.error || 'ç½‘ç»œè¯·æ±‚å¤±è´¥ï¼Œæ— æ³•è·å–ä¹¦ç±ä¿¡æ¯' });
    } finally {
      this.setData({ isLoading: false });
    }
  },
  
  async handlePayment() {
    if (this.data.isSubmitting || !this.data.book) return;
    this.setData({ isSubmitting: true });

    const userId = auth.getUserId();
    const inventoryItemId = this.data.book.id;

    if (!userId) {
      wx.showToast({ title: 'ç™»å½•ä¿¡æ¯å¤±æ•ˆï¼Œè¯·é‡å¯å°ç¨‹åº', icon: 'none' });
      this.setData({ isSubmitting: false });
      return;
    }

    try {
      wx.showLoading({ title: 'æ­£åœ¨åˆ›å»ºè®¢å•...' });

      const createData = await api.request({
        url: '/orders/create',
        method: 'POST',
        data: { inventoryItemIds: [inventoryItemId] }
      });

      const orderId = createData.id;
      wx.showLoading({ title: 'è·å–æ”¯ä»˜å‚æ•°...' });

      const payParams = await api.request({
        url: `/orders/${orderId}/pay`,
        method: 'POST' // bodyä¸ºç©ºï¼Œæ‰€æœ‰ä¿¡æ¯éƒ½åœ¨JWTé‡Œ
      });

      wx.hideLoading();

      try {
        await promisifiedPayment(payParams); // ç›´æ¥ä½¿ç”¨åç«¯è¿”å›çš„ç­¾åå‚æ•°
        wx.showToast({ title: 'æ”¯ä»˜æˆåŠŸ', icon: 'success' });
        setTimeout(() => {
          wx.switchTab({ url: '/pages/orders/index' });
        }, 1500);
      } catch (paymentError) {
        wx.showToast({ title: 'æ”¯ä»˜å·²å–æ¶ˆ', icon: 'none' });
        this.setData({ isSubmitting: false });
      }

    } catch (error) {
      wx.hideLoading();
      wx.showToast({ title: error.error || 'ç½‘ç»œè¯·æ±‚å¤±è´¥', icon: 'error' });
      this.setData({ isSubmitting: false });
    }
  }
});


================================================================================
### FILE: miniprogram\pages\order-detail\index.js
================================================================================

// pages/order-detail/index.js
const { request } = require('../../utils/api');

Page({
  data: {
    order: null,
    isLoading: true,
    error: null
  },

  onLoad(options) {
    if (options.id) {
      this.fetchOrderDetail(options.id);
    } else {
      this.setData({ 
        isLoading: false, 
        error: 'æ— æ•ˆçš„è®¢å•ID' 
      });
    }
  },

  async fetchOrderDetail(orderId) {
    this.setData({ isLoading: true, error: null });

    try {
      const data = await request({
        url: `/orders/${orderId}`,
        method: 'GET'
      });
      this.setData({ 
        order: data,
        isLoading: false 
      });
    } catch (error) {
      this.setData({ 
        error: error.error || 'è·å–è®¢å•è¯¦æƒ…å¤±è´¥',
        isLoading: false 
      });
    }
  },

  formatDate(dateString) {
    if (!dateString) return '';
    const date = new Date(dateString);
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const day = String(date.getDate()).padStart(2, '0');
    const hours = String(date.getHours()).padStart(2, '0');
    const minutes = String(date.getMinutes()).padStart(2, '0');
    return `${year}-${month}-${day} ${hours}:${minutes}`;
  },

  getStatusText(status) {
    const statusMap = {
      'PENDING_PAYMENT': 'å¾…æ”¯ä»˜',
      'PENDING_PICKUP': 'å¾…å–è´§', 
      'COMPLETED': 'å·²å®Œæˆ',
      'CANCELLED': 'å·²å–æ¶ˆ',
      'RETURNED': 'å·²é€€è´§'
    };
    return statusMap[status] || status;
  },

  getConditionText(condition) {
    const conditionMap = {
      'A': 'å…¨æ–°',
      'B': 'å…«æˆæ–°',
      'C': 'å…­æˆæ–°'
    };
    return conditionMap[condition] || condition;
  },

  onRefresh() {
    const pages = getCurrentPages();
    const currentPage = pages[pages.length - 1];
    const orderId = currentPage.options.id;
    if (orderId) {
      this.fetchOrderDetail(orderId);
    }
  },

  copyPickupCode(e) {
    const code = e.target.dataset.code || e.currentTarget.dataset.code;
    if (code) {
      wx.setClipboardData({
        data: code,
        success: () => {
          wx.showToast({
            title: 'å–è´§ç å·²å¤åˆ¶',
            icon: 'success'
          });
        }
      });
    }
  }
});


================================================================================
### FILE: miniprogram\pages\orders\index.js
================================================================================

// pages/orders/index.js
const auth = require('../../utils/auth');
const { request } = require('../../utils/api');
const { ORDER_STATUS } = require('../../utils/constants');

Page({
  data: {
    orderList: [],
    isLoading: true,
    error: null,
    statusMap: ORDER_STATUS,
    pageInfo: null // For pagination metadata
  },
  onShow() { this.fetchUserOrders(); },
  navigateToDetail(event) {
    const orderId = event.currentTarget.dataset.orderId;
    if (orderId) {
      wx.navigateTo({
        url: `/pages/order-detail/index?id=${orderId}`
      });
    }
  },
  async fetchUserOrders() {
    const userId = auth.getUserId();
    if (!userId) { return; }
    this.setData({ isLoading: true, error: null });
    
    try {
      const data = await request({
        url: `/orders/user/${userId}`,
        method: 'GET'
      });
      this.setData({ orderList: data.data, pageInfo: data.meta });
    } catch (error) {
      this.setData({ error: error.error || 'åŠ è½½è®¢å•å¤±è´¥ã€‚' });
    } finally {
      this.setData({ isLoading: false });
    }
  },

  // Pull down refresh
  async onPullDownRefresh() {
    await this.fetchUserOrders();
    wx.stopPullDownRefresh();
  }
});


================================================================================
### FILE: miniprogram\pages\profile\index.js
================================================================================

// miniprogram/pages/profile/index.js
const app = getApp(); // è·å–Appå®ä¾‹

Page({
  data: {
    userInfo: { nickName: 'å¾®ä¿¡ç”¨æˆ·' },
    serviceInfo: {
      wechatId: 'your_service_wechat_id',
      time: 'å·¥ä½œæ—¥ 9:00 - 18:00'
    }
  },
  copyWechatId() {
    wx.setClipboardData({
      data: this.data.serviceInfo.wechatId,
      success: () => { wx.showToast({ title: 'å·²å¤åˆ¶' }); }
    });
  },

  showTerms() {
    wx.navigateTo({
      url: '/pages/webview/index?slug=terms-of-service'
    });
  },

  showPrivacy() {
    wx.navigateTo({
      url: '/pages/webview/index?slug=privacy-policy'
    });
  },

  goToCustomerService() {
    wx.navigateTo({
      url: '/pages/customer-service/index'
    });
  },

  onShareAppMessage() {
    return {
      title: 'è¶…å€¼çš„äºŒæ‰‹æ•™æï¼Œå¿«æ¥çœ‹çœ‹å§ï¼',
      path: '/pages/market/index',
    }
  }
});


================================================================================
### FILE: miniprogram\pages\webview\index.js
================================================================================

const { request } = require('../../utils/api');

Page({
  data: {
    content: null,
    isLoading: true,
    errorMsg: ''
  },

  onLoad(options) {
    const { slug } = options;
    if (!slug) {
      this.setData({
        isLoading: false,
        errorMsg: 'é¡µé¢å‚æ•°é”™è¯¯'
      });
      return;
    }

    this.loadContent(slug);
  },

  async loadContent(slug) {
    try {
      const data = await request({
        url: `/content/${slug}`,
        method: 'GET'
      });
      const { title, body } = data;
      wx.setNavigationBarTitle({ title });
      this.setData({
        content: { title, body },
        isLoading: false
      });
    } catch (error) {
      console.error('Content load failed', error);
      this.setData({
        isLoading: false,
        errorMsg: error.error || 'å†…å®¹åŠ è½½å¤±è´¥'
      });
    }
  }
});


================================================================================
### FILE: miniprogram\utils\api.js
================================================================================

// miniprogram/utils/api.js - ç»Ÿä¸€çš„APIè¯·æ±‚å·¥å…·
const config = require('../config');
const tokenUtil = require('./token'); // ä¾èµ–æ–°çš„ã€æ— ä¾èµ–çš„æ¨¡å—

/**
 * ç»Ÿä¸€çš„APIè¯·æ±‚å‡½æ•°
 * @param {Object} options - è¯·æ±‚å‚æ•°
 * @param {string} options.url - è¯·æ±‚åœ°å€ï¼ˆç›¸å¯¹è·¯å¾„ï¼Œä¼šè‡ªåŠ¨æ‹¼æ¥baseURLï¼‰
 * @param {string} options.method - è¯·æ±‚æ–¹æ³•ï¼ˆGET, POSTç­‰ï¼‰
 * @param {Object} options.data - è¯·æ±‚æ•°æ®
 * @param {Object} options.header - è¯·æ±‚å¤´
 * @returns {Promise} - è¿”å›Promiseå¯¹è±¡
 */
const request = ({ url, method = 'GET', data = {} }) => new Promise((resolve, reject) => {
    const token = tokenUtil.getToken(); // ä»æ–°æ¨¡å—è·å–token
    wx.request({
        url: `${config.apiBaseUrl}${url}`,
        method,
        data,
        header: {
            'Content-Type': 'application/json',
            'Authorization': token ? `Bearer ${token}` : ''
        },
        success: (res) => {
            if (res.statusCode >= 200 && res.statusCode < 300) return resolve(res.data);
            if (res.statusCode === 401) {
                // ç®€å•å¤„ç†ï¼šæç¤ºå¹¶è®©ç”¨æˆ·é‡å¯
                wx.showToast({ title: 'ç™»å½•è¿‡æœŸï¼Œè¯·é‡å¯å°ç¨‹åº', icon: 'none' });
                tokenUtil.clearToken();
            }
            return reject(res.data || { error: `Request failed with status ${res.statusCode}` });
        },
        fail: (err) => reject({ error: 'ç½‘ç»œè¯·æ±‚å¤±è´¥', errorCode: 'NETWORK_ERROR' })
    });
});

module.exports = {
  request
};


================================================================================
### FILE: miniprogram\utils\auth.js
================================================================================

// miniprogram/utils/auth.js
const { request } = require('./api');
const tokenUtil = require('./token'); // å¼•å…¥æ–°çš„tokenæ¨¡å—

const login = () => {
  return new Promise((resolve, reject) => {
    wx.login({
      success: async (res) => {
        if (res.code) {
          try {
            const data = await request({
              url: '/auth/login',
              method: 'POST',
              data: { code: res.code }
            });
            
            if (data.token) {
              tokenUtil.setToken(data.token); // ä½¿ç”¨æ–°æ¨¡å—
              tokenUtil.setUserId(data.userId); // ä½¿ç”¨æ–°æ¨¡å—
              resolve(data);
            } else {
              reject(new Error('Login failed on server.'));
            }
          } catch (error) {
            reject(new Error(error.error || 'Login failed on server.'));
          }
        } else {
          reject(new Error('wx.login failed, no code returned.'));
        }
      },
      fail: (err) => { reject(err); }
    });
  });
};

const logout = () => {
  tokenUtil.clearToken(); // ä½¿ç”¨æ–°æ¨¡å—
};

module.exports = {
  login,
  getUserId: tokenUtil.getUserId, // ç›´æ¥å¯¼å‡º
  logout
};


================================================================================
ESSENTIAL CODE REVIEW REPORT GENERATION COMPLETE.
================================================================================
